<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Workflow Vector — Login & Jobs</title>
<style>
  :root{
    --bg:#0b1220;--card:#111a2b;--muted:#7e8aa0;--text:#eaf0ff;--accent:#6aa6ff;--accent-2:#8b5cf6;
    --ring:0 0 0 3px rgba(106,166,255,.25);
    --topbar-h:64px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background:
      radial-gradient(1200px 1200px at 10% -10%,rgba(138,92,246,.15),transparent 50%),
      radial-gradient(900px 900px at 120% 10%,rgba(106,166,255,.15),transparent 60%),
      var(--bg);
    color:var(--text);
    min-height:100vh;
  }
  /* ====== LOGIN ====== */
  .app{width:min(1300px,100%); display:grid; gap:18px; margin:0 auto; padding:24px}
  .title{text-align:center; line-height:1.2}
  .title h1{margin:.2rem 0;font-size:clamp(22px,4vw,34px)}
  .title p{margin:0;color:var(--muted)}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.45); overflow:hidden}
  .login{display:grid; grid-template-columns: 1.1fr .9fr; gap:0; min-height:380px}
  @media (max-width:920px){.login{grid-template-columns:1fr}.side{display:none}}
  .panel{padding:28px}
  .side{background:
    radial-gradient(100% 100% at 0% 0%, rgba(139,92,246,.25), transparent 55%),
    radial-gradient(100% 100% at 100% 0%, rgba(106,166,255,.25), transparent 55%),
      linear-gradient(180deg, #0c172a, #0a1424);
    border-left:1px solid rgba(255,255,255,.06); display:grid; place-items:center; padding:24px}
  .brand{display:grid; gap:12px; text-align:center; place-items:center}
  .logo{width:180px;height:180px;border-radius:18px;
    background:conic-gradient(from 180deg at 50% 50%, var(--accent), var(--accent-2));
    display:grid;place-items:center;font-weight:800;font-size:3.3rem; color:#fff}
  .field{display:grid; gap:6px; margin:10px 0}
  label{font-size:.9rem;color:var(--muted)}
  input,select,textarea{
    width:100%; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.12);
    background:#0b1426; color:var(--text);outline:none; transition:.2s border-color,.2s box-shadow; font-size:.95rem}
  textarea{min-height:90px; resize:vertical}
  input:focus, select:focus, textarea:focus{border-color:var(--accent); box-shadow:var(--ring)}
  .row{display:flex; gap:12px; flex-wrap:wrap; margin-top:8px}
  .btn{appearance:none; border:1px solid rgba(255,255,255,.12); background:#0d1628; color:#eaf0ff;
    padding:10px 14px; border-radius:10px; cursor:pointer;transition:.2s transform,.2s background,.2s border-color, .2s box-shadow; font-weight:600}
  .btn:hover{transform:translateY(-1px); border-color:rgba(255,255,255,.25)}
  .btn:focus{outline:none; box-shadow:var(--ring)}
  .btn.primary{background:linear-gradient(180deg, #2a60ff, #1b47c9); border-color:transparent}
  .btn.ghost{background:transparent}
  .btn.small{padding:6px 10px; font-size:.85rem}
  .muted{color:var(--muted); font-size:.9rem}
  .warning{font-size:.85rem;color:#f8c37a}
  dialog{border:none; border-radius:14px; max-width:1200px; width:min(98vw,1200px); box-shadow:0 20px 60px rgba(0,0,0,.6); background:var(--card); color:var(--text)}
  dialog::backdrop{background:rgba(0,0,0,.55)}
  .modal{padding:18px}
  .modal h3{margin:0 0 8px 0}
  .modal .actions{display:flex; justify-content:flex-end; gap:10px; margin-top:10px}
  #busy{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;place-items:center;z-index:99999}
  #busy .box{background:#0e1730;border:1px solid rgba(255,255,255,.12);padding:14px 16px;border-radius:12px}
  /* ====== APP ====== */
  .hide{display:none !important}
  .topbar{
    height:var(--topbar-h);
    display:flex; align-items:center; gap:12px; padding:10px 14px;
    border-bottom:1px solid rgba(255,255,255,.08);
    background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
    box-shadow:0 10px 30px rgba(0,0,0,.25);
    position: sticky; top: 0; z-index: 50;
  }
  .left{display:flex; gap:10px; flex-wrap:wrap}
  .right{margin-left:auto; display:flex; align-items:center; gap:10px}
  .userName{font-weight:700}
  .content{ flex:1; display:flex; align-items:stretch; justify-content:stretch; min-height:0; padding:12px; }
  .box{ width:100%; height:100%; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); border-radius:12px; padding:14px; overflow:hidden; }
  #toast{position:fixed;left:50%;top:18px;transform:translateX(-50%);background:#1f2a44;color:#eaf0ff;padding:10px 14px;border:1px solid rgba(255,255,255,.16);border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,.5);z-index:9999;display:none}
  /* tabela jobs */
  #mainBox .tableWrap{height:100%; overflow:auto;}
  #mainBox table{ table-layout: fixed; width:100%; border-collapse:collapse; font-size:.95rem }
  #mainBox thead th{ font-size:.82rem; padding:8px 10px; position:sticky; top:0; z-index:2; background:#0f182b; border-bottom:1px solid rgba(255,255,255,.12); border-right:1px solid rgba(255,255,255,.12) }
  #mainBox thead th:last-child{ border-right:none }
  #mainBox tbody td{ text-align:center; vertical-align:middle; padding:8px 10px; border-bottom:1px solid rgba(255,255,255,.06); border-right:1px solid rgba(255,255,255,.12); font-size:.84rem; line-height:1.25 }
  #mainBox tbody td:last-child{ border-right:none }
  #mainBox .sep-row td{ text-align:center; font-size:.82rem; font-weight:700; letter-spacing:.02em; padding:8px 10px; background:rgba(255,255,255,.02); border-top:1px solid rgba(255,255,255,.08); }
  #mainBox .sub-row td{ text-align:left; font-size:.82rem; font-weight:700; letter-spacing:.01em; padding:8px 10px 8px 24px; background:rgba(255,255,255,.03); border-top:1px dashed rgba(255,255,255,.12); color:var(--text); }
  /* status cores */
  #mainBox tbody tr.st-novo{background:#ffffff; color:#111827}
  #mainBox tbody tr.st-lista{background:#cfe8ff; color:#111827}
  #mainBox tbody tr.st-layout{background:#4c1d95; color:#ffffff}
  #mainBox tbody tr.st-digitando{background:#1e3a8a; color:#ffffff}
  #mainBox tbody tr.st-diagramando{background:#f59e0b; color:#111827}
  #mainBox tbody tr.st-revisando{background:#fbcfe8; color:#111827}
  #mainBox tbody tr.st-aprovado{background:#bbf7d0; color:#065f46}
  #mainBox tbody tr.st-encerrando{background:#fde68a; color:#111827}
  #mainBox tbody tr.st-site{background:#d8b4fe; color:#111827}
  #mainBox tbody tr.st-cancelado{background:#991b1b; color:#ffffff}
  #mainBox tbody tr.st-finalizado{background:#4b5563; color:#ffffff}
  #mainBox tbody tr[class^="st-"] .btn{ border-color: rgba(0,0,0,.2); box-shadow:none }
  #mainBox tbody tr.st-layout .btn, #mainBox tbody tr.st-digitando .btn, #mainBox tbody tr.st-cancelado .btn{ border-color: rgba(255,255,255,.4) }
  #mainBox tbody td .clip{ display:inline-block; max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; cursor:pointer; border-bottom:1px dotted rgba(255,255,255,.35); }
  #mainBox tbody tr.sel{ outline:2px solid var(--accent); outline-offset:-2px; }
  /* chips cargos */
  .role-chip{ display:inline-block; padding:4px 8px; border-radius:999px; font-size:.8rem; font-weight:700; border:1px solid rgba(255,255,255,.18) }
  .role-prata{background:linear-gradient(180deg,#d1d5db,#9ca3af); color:#111827}
  .role-verde{background:rgba(130,230,150,.25); border-color:rgba(130,230,150,.4)}
  .role-roxo{background:rgba(150,114,255,.22); border-color:rgba(150,114,255,.35)}
  .role-azul{background:rgba(129,199,245,.22); border-color:rgba(129,199,245,.35)}
  .role-laranja{background:rgba(255,170,86,.25); border-color:rgba(255,255,255,.4)}
  .role-rosa{background:rgba(255,140,200,.25); border-color:rgba(255,140,200,.4)}
  .role-amarelo{background:rgba(255,220,120,.3); border-color:rgba(255,255,255,.5)}
  .role-roxoclaro{background:rgba(192,132,252,.25); border-color:rgba(192,132,252,.4)}
  /* grids/inputs modais app */
  .grid{ display:grid; grid-template-columns:repeat(12,1fr); gap:10px }
  .col-6{ grid-column:span 6 } .col-4{ grid-column:span 4 } .col-3{ grid-column:span 3 } .col-2{ grid-column:span 2 } .col-12{ grid-column:span 12 }
  .actions{ display:flex; justify-content:flex-end; gap:10px; margin-top:12px }
  .err{border-color:#f87171 !important; box-shadow:0 0 0 3px rgba(248,113,113,.25) !important}
  /* listas em modais */
  .frow{ display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 12px }
  .list{ border:1px solid rgba(255,255,255,.12); border-radius:10px; overflow:hidden }
  .list table{ width:100%; border-collapse:collapse }
  .list thead th{ background:#0f182b; font-size:.82rem; padding:8px 10px; text-align:left }
  .list tbody td{ padding:8px 10px; border-top:1px solid rgba(255,255,255,.08); font-size:.9rem }
  .list .hint{ padding:12px; color:var(--muted) }
</style>
</head>
<body>
<!-- ===== VIEW LOGIN ===== -->
<div id="loginView" class="app">
  <div class="title">
    <h1>Workflow Vector</h1>
    <p>Seja bem vindo ao Workflow Vector, plataforma de lançamentos de JOBS.</p>
  </div>

  <section class="card login">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <h2 style="margin:0 0 12px 0">Entrar</h2>
          <p class="muted">Use seu e-mail e senha para acessar.</p>
        </div>
        <button class="btn" id="btnCfg">⚙ Configurar GitHub</button>
      </div>

      <div class="field"><label for="email">E-mail</label><input id="email" type="email" placeholder="voce@empresa.com.br" /></div>
      <div class="field"><label for="senha">Senha</label><input id="senha" type="password" placeholder="••••••••" /></div>

      <div class="row" style="margin-top:10px">
        <button class="btn ghost" id="btnCadastrar">Cadastrar</button>
        <button class="btn primary" id="btnLogin">Login</button>
        <button class="btn ghost" id="btnEsqueci">Esqueci minha senha/e-mail!</button>
      </div>

      <p class="warning" style="margin-top:8px">Versão: 1.1.0 <strong>-WKF job</strong> Vector TI.</p>
    </div>
    <aside class="side">
      <div class="brand">
        <div class="logo">WV</div>
        <div class="muted" style="margin-top:6px">
          <span class="chip" style="padding:6px 10px;border:1px solid rgba(255,255,255,.14);border-radius:999px">V0.1 - Job manager Vector</span>
        </div>
      </div>
    </aside>
  </section>

  <!-- MODAL: Config GitHub -->
  <dialog id="modalCfg">
    <form method="dialog" class="modal" id="formCfg">
      <h3>Definir Token do GitHub</h3>
      <div class="field">
        <label>TOKEN (GitHub Personal Access Token)</label>
        <input id="cfgToken" type="password" placeholder="ghp_xxx..." />
        <div class="muted">Gere um token com acesso a <strong>Contents: read &amp; write</strong> no repositório configurado.</div>
      </div>
      <div class="row" style="align-items:center">
        <label style="display:flex;gap:8px;align-items:center">
          <input id="cfgRemember" type="checkbox" checked />
          Lembrar token neste navegador
        </label>
      </div>
      <div class="actions">
        <button class="btn" type="button" data-close="modalCfg">Cancelar</button>
        <button class="btn primary" type="button" id="btnCfgSalvar">Salvar</button>
      </div>
    </form>
  </dialog>

  <!-- MODAL: Cadastro -->
  <dialog id="modalCadastro">
    <form method="dialog" class="modal" id="formCadastro">
      <h3>Novo cadastro</h3>
      <div class="field"><label for="cadNome">Nome completo</label><input id="cadNome" type="text" placeholder="Seu nome completo" /></div>
      <div class="field"><label for="cadEmail">E-mail</label><input id="cadEmail" type="email" placeholder="voce@empresa.com.br" /></div>
      <div class="field"><label for="cadSenha">Senha</label><input id="cadSenha" type="password" placeholder="Crie uma senha" /></div>

      <div class="row" style="gap:16px;flex-wrap:wrap">
        <div class="field" style="min-width:220px">
          <label for="cadCargoP">Cargo (PRINCIPAL)</label>
          <select id="cadCargoP">
            <option value="">— selecione —</option>
            <option>Administrador</option><option>Diretor</option><option>Gerente</option>
            <option>Trafego</option><option>Layout</option><option>Diagramador</option>
            <option>Digitador</option><option>Revisor</option><option>Site</option>
            <option>Encerramento</option>
          </select>
        </div>
        <div class="field" style="min-width:220px">
          <label for="cadCargoS">Cargo (SECUNDÁRIA) — opcional</label>
          <select id="cadCargoS">
            <option value="">— nenhuma —</option>
            <option>Administrador</option><option>Diretor</option><option>Gerente</option>
            <option>Trafego</option><option>Layout</option><option>Diagramador</option>
            <option>Digitador</option><option>Revisor</option><option>Site</option>
            <option>Encerramento</option>
          </select>
        </div>
      </div>

      <div class="field">
        <label for="cadGate">Senha de liberação do cadastro</label>
        <input id="cadGate" type="password" placeholder="Informe a senha para autorizar o cadastro" />
        <div class="muted">Inserir senha ADM para cadastro ou entre em contato com adm_ti@vectorpropaganda.com.br.</div>
      </div>

      <div class="actions">
        <button class="btn" type="button" id="btnLimparCadastro">Limpar</button>
        <button class="btn" type="button" data-close="modalCadastro">Cancelar</button>
        <button class="btn primary" type="button" id="btnDoCadastrar">Cadastrar</button>
      </div>
    </form>
  </dialog>

  <!-- MODAL: Reset senha -->
  <dialog id="modalReset">
    <form method="dialog" class="modal" id="formReset">
      <h3>Atualizar senha</h3>
      <div class="field"><label for="resetNome">Nome</label><input id="resetNome" type="text" placeholder="Seu nome completo" /></div>
      <div class="field"><label for="resetEmail">E-mail</label><input id="resetEmail" type="email" placeholder="voce@empresa.com.br" /></div>
      <div class="field">
        <label for="resetCargo">Cargo</label>
        <select id="resetCargo">
          <option value="">— selecione —</option>
          <option>Administrador</option><option>Diretor</option><option>Gerente</option>
          <option>Trafego</option><option>Layout</option><option>Diagramador</option>
          <option>Digitador</option><option>Revisor</option><option>Site</option>
          <option>Encerramento</option>
        </select>
      </div>
      <div id="resetNovaSenhaWrap" class="field" style="display:none">
        <label for="resetNovaSenha">Nova senha</label>
        <input id="resetNovaSenha" type="password" placeholder="Digite a nova senha" />
      </div>
      <div class="actions">
        <button class="btn" type="button" id="btnResetLimpar">Limpar</button>
        <button class="btn" type="button" data-close="modalReset">Cancelar</button>
        <button class="btn" type="button" id="btnResetValidar">Validar</button>
        <button class="btn primary" type="button" id="btnResetAtualizar" style="display:none">Atualizar</button>
      </div>
    </form>
  </dialog>
</div>

<!-- ===== VIEW APP (Jobs) ===== -->
<div id="jobsApp" class="hide" aria-hidden="true">
  <header class="topbar" aria-label="Barra de ações e usuário">
    <div class="left" id="actions">
      <button class="btn primary" id="btnNovo">Novo</button>
      <button class="btn" id="btnExcluir">Excluir</button>
      <button class="btn" id="btnDuplicar">Duplicar</button>
      <button class="btn" id="btnEditar">Editar</button>
      <button class="btn" id="btnFiltrar">Filtrar</button>
      <button class="btn" id="btnEncerrar">Encerrar</button>
      <button class="btn" id="btnFinalizar">Finalizar</button>
      <button class="btn" id="btnVerFinalizados">Visualizar Finalizados</button>
      <button class="btn" id="btnDash">Dashboard</button>
    </div>
    <div class="right" id="userArea">
      <div class="muted">Usuário:</div>
      <div class="userName" id="userName">—</div>
      <span id="cargo1" class="role-chip role-prata" style="display:none"></span>
      <span id="cargo2" class="role-chip role-roxo" style="display:none"></span>
      <button class="btn small" id="btnSair">Sair</button>
    </div>
  </header>

  <main class="content">
    <section class="box" id="mainBox" aria-label="Área principal">
      <div class="tableWrap" style="border:1px solid rgba(255,255,255,.12); border-radius:10px">
        <table aria-label="Cabeçalhos de JOBs">
          <thead>
            <tr>
              <th style="text-align:left;padding:10px 12px;">OT (Ordem de Tabloide)</th>
              <th style="text-align:left;padding:10px 12px;">REGIONAL</th>
              <th style="text-align:left;padding:10px 12px;">TIPO DA LOJA</th>
              <th style="text-align:left;padding:10px 12px;">TIPO DO JOB</th>
              <th style="text-align:left;padding:10px 12px;">NOME TABLOIDE</th>
              <th style="text-align:left;padding:10px 12px;">COMPLEMENTO</th>
              <th style="text-align:left;padding:10px 12px;">ESTADO</th>
              <th style="text-align:left;padding:10px 12px;">FILIAL (S)</th>
              <th style="text-align:left;padding:10px 12px;">VALIDADE INÍCIO</th>
              <th style="text-align:left;padding:10px 12px;">VALIDADE TÉRMINO</th>
              <th style="text-align:left;padding:10px 12px;">PÁGINA (TAMANHO)</th>
              <th style="text-align:left;padding:10px 12px;">PÁGINA (QUANTIDADE)</th>
              <th style="text-align:left;padding:10px 12px;">STATUS</th>
              <th style="text-align:left;padding:10px 12px;">ETAPAS PRODUÇÃO</th>
            </tr>
          </thead>
          <tbody id="jobsBody">
            <tr class="sep-row"><td colspan="14">REGIONAL BA - SE</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL DF - GO - TO</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL MG</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL MS</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL MT - RO - AC</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL NORDESTE 1</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL NORDESTE 2</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL NORTE</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL PR</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL RJ - ES</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL RS</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL SP</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL SC</td></tr>
            <tr class="sep-row"><td colspan="14">ESPECIAL NACIONAL</td></tr>
          </tbody>
        </table>
      </div>
    </section>
  </main>
</div>

<!-- ===== MODAL: Novo ===== -->
<dialog id="modalNovo"><form method="dialog" class="modal" id="formNovo">
  <h3>Novo tabloide</h3>
  <div class="grid">
    <div class="col-6"><label>Regional</label>
      <select id="novoRegional">
        <option value="">— selecione —</option>
        <option>REGIONAL BA - SE</option>
        <option>REGIONAL DF - GO - TO</option>
        <option>REGIONAL MG</option>
        <option>REGIONAL MS</option>
        <option>REGIONAL MT - RO - AC</option>
        <option>REGIONAL NORDESTE 1</option>
        <option>REGIONAL NORDESTE 2</option>
        <option>REGIONAL NORTE</option>
        <option>REGIONAL PR</option>
        <option>REGIONAL RJ - ES</option>
        <option>REGIONAL RS</option>
        <option>REGIONAL SP</option>
        <option>REGIONAL SC</option>
      </select>
    </div>
    <div class="col-3"><label>Tipo da loja</label>
      <select id="novoTipoLoja"><option value="">— selecione —</option><option>AS</option><option>AT</option></select>
    </div>
    <div class="col-3"><label>Tipo do JOB</label>
      <select id="novoTipoJob"><option value="">— selecione —</option><option>Tabloide Digital</option><option>Tabloide Impresso</option></select>
    </div>

    <div class="col-6"><label>Nome do tabloide</label>
      <div style="display:flex; gap:8px; align-items:center">
        <select id="novoNomeSel" style="flex:1 1 auto; min-width:240px">
          <option value="">— selecione —</option>
        </select>
        <button class="btn small" type="button" id="btnNomeNovo">Novo nome</button>
      </div>
      <!-- opcional: espelho (caso backend use #novoNome) -->
      <input id="novoNome" type="hidden" />
    </div>

    <div class="col-6"><label>Complemento</label><input id="novoCompl" type="text" placeholder="Opcional" /></div>

    <div class="col-3"><label>Estado</label><select id="novoEstado"></select></div>
    <div class="col-3"><label>Filial(s)</label><input id="novoFilial" type="text" placeholder="001, 002" /></div>
    <div class="col-3"><label>Validade início</label><input id="novoIni" type="date" /></div>
    <div class="col-3"><label>Validade término</label><input id="novoFim" type="date" /></div>
    <div class="col-3"><label>Página (tamanho)</label>
      <select id="novoTam"><option value="">— selecione —</option><option>A3</option><option>A4</option></select>
    </div>
    <div class="col-3"><label>Página (quantidade)</label><input id="novoQtd" type="number" min="1" step="1" /></div>

    <div class="col-3">
      <label>Ação nacional</label>
      <div class="frow" role="group" aria-label="Ação nacional">
        <label><input type="radio" name="novoAcaoNac" id="novoAcaoNao" value="nao" checked> Não</label>
        <label><input type="radio" name="novoAcaoNac" id="novoAcaoSim" value="sim"> Sim</label>
      </div>
    </div>
    <div class="col-6">
      <label>Ação (quando nacional)</label>
      <div style="display:flex; gap:8px; align-items:center">
        <input id="novoAcaoNome" type="text" placeholder="Escolha/crie uma ação" readonly />
        <button class="btn small" type="button" id="btnEscolherAcao" disabled>Definir ação…</button>
      </div>
      <div class="muted">Se marcar “Sim”, escolha uma ação existente ou crie uma nova (usada em “Especial nacional”).</div>
    </div>

    <div class="col-6">
      <label>Link pasta</label>
      <input id="novoLink" type="url" placeholder="https://... (Google Drive, rede, etc.)" />
    </div>
  </div>
  <div class="actions">
    <button class="btn" type="button" id="btnNovoCancelar">Cancelar</button>
    <button class="btn primary" type="button" id="btnNovoSalvar">Salvar</button>
  </div>
</form></dialog>
<!-- ===== MODAL: Novo ===== FIM -->

<!-- ===== MODAL: Novo nome (nome_tabloide.csv) ===== -->
<dialog id="modalNomeTab">
  <form method="dialog" class="modal" id="formNomeTab">
    <h3>Novo nome de tabloide</h3>
    <div class="field">
      <label>Nome</label>
      <input id="nomeTabTexto" type="text" placeholder="Ex.: Festival Vinhos, Queijos e Massas" />
      <div class="muted">Será gravado em <strong>nome_tabloide.csv</strong>.</div>
    </div>
    <div class="actions">
      <button class="btn" type="button" id="nomeTabCancelar">Cancelar</button>
      <button class="btn primary" type="button" id="nomeTabSalvar">Salvar</button>
    </div>
  </form>
</dialog>
<!-- ===== MODAL: Novo nome FIM ===== -->

<!-- ===== MODAL: Editar ===== -->
<dialog id="modalEdit"><form method="dialog" class="modal" id="formEdit">
  <h3>Editar tabloide — <span id="editOT"></span></h3>
  <div class="grid">
    <div class="col-6"><label>Regional</label><select id="editRegional"></select></div>
    <div class="col-3"><label>Tipo da loja</label>
      <select id="editTipoLoja"><option value="">— selecione —</option><option>AS</option><option>AT</option></select>
    </div>
    <div class="col-3"><label>Tipo do JOB</label>
      <select id="editTipoJob"><option value="">— selecione —</option><option>Tabloide Digital</option><option>Tabloide Impresso</option></select>
    </div>
    <div class="col-6"><label>Nome do tabloide</label><input id="editNome" type="text" /></div>
    <div class="col-6"><label>Complemento</label><input id="editCompl" type="text" /></div>
    <div class="col-3"><label>Estado</label><select id="editEstado"></select></div>
    <div class="col-3"><label>Filial(s)</label><input id="editFilial" type="text" /></div>
    <div class="col-3"><label>Validade início</label><input id="editIni" type="date" /></div>
    <div class="col-3"><label>Validade término</label><input id="editFim" type="date" /></div>
    <div class="col-3"><label>Página (tamanho)</label>
      <select id="editTam"><option value="">— selecione —</option><option>A3</option><option>A4</option></select>
    </div>
    <div class="col-3"><label>Página (quantidade)</label><input id="editQtd" type="number" min="1" step="1" /></div>
    <div class="col-12">
      <h4 style="margin:8px 0 6px 0">Etapas de produção</h4>
      <div id="editEtapasList" class="etapasGrid"></div>
    </div>
  </div>
  <div class="actions">
    <button class="btn" type="button" id="btnEditCancelar">Cancelar</button>
    <button class="btn primary" type="button" id="btnEditSalvar">Salvar</button>
  </div>
</form></dialog>

<!-- ===== MODAL: Editar ===== FIM -->

<!-- MODAL: Célula -->
<dialog id="modalCell"><div class="modal">
  <h3 id="cellTitle">Detalhes</h3>
  <div id="cellBody" class="mono"></div>
  <div class="actions"><button class="btn" type="button" id="btnCellFechar">Fechar</button></div>
</div></dialog>

<!-- MODAL: Etapas (lista) -->
<dialog id="modalEtapas"><div class="modal">
  <h3>Etapas de produção — <span id="etapasTitleOT"></span></h3>
  <div id="etapasHead" class="muted" style="margin-bottom:8px"></div>
  <div id="etapasList" class="etapasGrid"></div>
  <div class="actions"><button class="btn" type="button" id="btnEtapasFechar">Fechar</button></div>
</div></dialog>

<!-- MODAL: Adicionar Evento (data/hora automáticas) -->
<dialog id="modalAddEvt"><form method="dialog" class="modal" id="formAddEvt">
  <h3 id="addEvtTitle">Adicionar evento</h3>
  <div id="addEvtFields">
    <div class="field"><label>Responsável</label><input id="addNome" type="text" placeholder="Seu nome" /></div>
    <div class="muted">A data e a hora serão registradas automaticamente ao salvar.</div>
  </div>
  <div class="actions">
    <button class="btn" type="button" id="btnAddEvtCancelar">Cancelar</button>
    <button class="btn primary" type="button" id="btnAddEvtOk">OK</button>
  </div>
</form></dialog>

<!-- MODAL: Ação nacional -->
<dialog id="modalAcao"><form method="dialog" class="modal" id="formAcao">
  <h3>Definir Ação nacional</h3>
  <div class="grid">
    <div class="col-12">
      <label>Ações existentes</label>
      <div id="acaoLista" class="mono" style="max-height:220px; overflow:auto; padding:10px;"></div>
    </div>
    <div class="col-12">
      <label>Criar nova ação</label>
      <input id="acaoNova" type="text" placeholder="Ex.: Primavera Nacional, Semana do Cliente..." />
    </div>
  </div>
  <div class="actions">
    <button class="btn" type="button" id="acaoCancelar">Cancelar</button>
    <button class="btn primary" type="button" id="acaoOk">Pronto</button>
  </div>
</form></dialog>

<!-- MODAL: Encerrar (Aprovados -> Encerrando) -->
<dialog id="modalEncerrar"><div class="modal">
  <h3>Encerrar jobs — Aprovados</h3>
  <div class="grid" style="margin-bottom:10px">
    <div class="col-3">
      <label>Status</label>
      <select id="encStatus" disabled>
        <option value="Aprovado" selected>Aprovado</option>
      </select>
      <div class="muted">Lista inicia com todos em “Aprovado”.</div>
    </div>

<//!editado inicia aqui>

    <div class="col-6">
  <label>Nome do tabloide</label>
  <select id="encNomeSel">
    <option>(todos)</option>
  </select>
  <div class="muted">Carregado de <strong>nome_tabloide.csv</strong> (acentos preservados).</div>
</div>

<//!editado até aqui>

    <div class="col-3">
      <label>Link pasta mãe</label>
      <input id="encLinkFiltro" type="text" placeholder="contém… (opcional)" />
    </div>
  </div>

  <div class="frow" style="justify-content:flex-end">
    <button class="btn" id="encFiltrar" type="button">Filtrar</button>
    <button class="btn" id="encSelTodos" type="button">Selecionar todos</button>
    <button class="btn primary" id="encExecutar" type="button">Encerrar</button>
  </div>

  <div class="list">
    <table>
      <thead>
        <tr>
          <th></th><th>OT</th><th>REGIONAL</th><th>TIPO DA LOJA</th><th>TIPO DO JOB</th>
          <th>NOME TABLOIDE</th><th>COMPLEMENTO</th><th>ESTADO</th><th>FILIAL (S)</th>
          <th>VALIDADE INÍCIO</th><th>VALIDADE TÉRMINO</th><th>PÁGINA (TAMANHO)</th>
          <th>PÁGINA (QUANTIDADE)</th><th>STATUS</th>
        </tr>
      </thead>
      <tbody id="encList"><tr><td colspan="14" class="hint">Carregando aprovados…</td></tr></tbody>
    </table>
  </div>

  <div class="actions"><button class="btn" id="encCancelar" type="button">Fechar</button></div>
</div></dialog>

<!-- MODAL: Filtrar (lista plana) -->
<dialog id="modalFiltro"><div class="modal">
  <h3>Filtrar jobs</h3>
  <div class="grid">
    <div class="col-4"><label>Regional</label><select id="fltRegional"><option>(todas)</option></select></div>
    <div class="col-4"><label>Nome do tabloide</label><input id="fltNome" type="text" placeholder="contém…" /></div>
    <div class="col-2"><label>Validade início</label><input id="fltIni" type="date" /></div>
    <div class="col-2"><label>Validade término</label><input id="fltFim" type="date" /></div>
    <div class="col-3"><label>Status</label>
      <select id="fltStatus">
        <option>(todos)</option><option>Novo</option><option>Lista recebida</option><option>Criando layout</option>
        <option>Digitando</option><option>Diagramando</option><option>Revisando</option>
        <option>Aprovado</option><option>Encerrando</option><option>Site</option><option>Cancelado</option>
      </select>
    </div>
    <div class="col-3"><label>Ação nacional</label>
      <select id="fltNac"><option>(ambos)</option><option>Sim</option><option>Não</option></select>
    </div>
    <div class="col-6">
      <label>Selecionar Ação (quando nacional)</label>
      <select id="fltAcao"><option>(todas)</option></select>
      <div class="muted">Lista com as ações criadas em “Especial nacional”.</div>
    </div>
  </div>

  <div class="frow" style="justify-content:flex-end">
    <button class="btn" id="fltLimpar" type="button">Limpar</button>
    <button class="btn primary" id="fltAplicar" type="button">Aplicar</button>
  </div>

  <div class="list" style="margin-top:10px">
    <table>
      <thead>
        <tr>
          <th>OT</th><th>REGIONAL</th><th>TIPO DA LOJA</th><th>TIPO DO JOB</th>
          <th>NOME TABLOIDE</th><th>COMPLEMENTO</th><th>ESTADO</th><th>FILIAL (S)</th>
          <th>VALIDADE INÍCIO</th><th>VALIDADE TÉRMINO</th><th>PÁGINA (TAMANHO)</th>
          <th>PÁGINA (QUANTIDADE)</th><th>STATUS</th>
        </tr>
      </thead>
      <tbody id="fltList"><tr><td colspan="13" class="hint">Defina os filtros e clique em “Aplicar”.</td></tr></tbody>
    </table>
  </div>

  <div class="actions"><button class="btn" id="fltFechar" type="button">Fechar</button></div>
</div></dialog>

<!-- MODAIS: Duplicar -->
<dialog id="modalDup1"><div class="modal">
  <h3>Duplicar jobs — Seleção</h3>
  <div class="frow">
    <div style="flex:1 1 220px"><label>Regional</label><select id="dupReg"></select></div>
    <div style="flex:2 1 260px"><label>Nome do tabloide (contém)</label><input id="dupNome" type="text" placeholder="Digite parte do nome" /></div>
    <div style="align-self:flex-end"><button class="btn" id="dupFiltrar" type="button">Filtrar</button></div>
    <div style="align-self:flex-end"><button class="btn" id="dupSelTodos" type="button">Selecionar todos</button></div>
    <div style="align-self:flex-end"><button class="btn" id="dupSelNenhum" type="button">Limpar seleção</button></div>
  </div>
  <div class="list">
    <table>
      <thead><tr><th></th><th>OT</th><th>Regional</th><th>Nome</th><th>Status</th></tr></thead>
      <tbody id="dupList"><tr><td colspan="5" class="hint">Sem resultados. Use os filtros acima.</td></tr></tbody>
    </table>
  </div>
  <div class="actions">
    <button class="btn" id="dup1Cancelar" type="button">Cancelar</button>
    <button class="btn primary" id="dup1Avancar" type="button">Avançar</button>
  </div>
</div></dialog>

<dialog id="modalDup2"><form method="dialog" class="modal" id="formDup2">
  <h3>Duplicar jobs — Parâmetros</h3>
  <div class="grid">
    <div class="col-3"><label>Tipo do JOB</label>
      <select id="dupTipoJob"><option value="">— selecione —</option><option>Tabloide Digital</option><option>Tabloide Impresso</option></select>
    </div>
    <div class="col-12 dup-nome-col"><label>Nome do tabloide</label>
      <input id="dupNomeNovo" type="text" placeholder="Novo nome comum para os duplicados" />
    </div>
    <div class="col-3"><label>Validade início</label><input id="dupIni" type="date" /></div>
    <div class="col-3"><label>Validade término</label><input id="dupFim" type="date" /></div>
    <div class="col-3"><label>Página (tamanho)</label>
      <select id="dupTam"><option value="">— selecione —</option><option>A3</option><option>A4</option></select>
    </div>
    <div class="col-3"><label>Página (quantidade)</label><input id="dupQtd" type="number" min="1" step="1" /></div>

    <div class="col-3">
      <label>Ação nacional</label>
      <div class="frow" role="group">
        <label><input type="radio" name="dupAcaoNac" id="dupAcaoNao" value="nao" checked> Não</label>
        <label><input type="radio" name="dupAcaoNac" id="dupAcaoSim" value="sim"> Sim</label>
      </div>
    </div>
    <div class="col-9">
      <label>Ação (quando nacional)</label>
      <div style="display:flex; gap:8px; align-items:center">
        <input id="dupAcaoNome" type="text" placeholder="Escolha/crie uma ação" readonly />
        <button class="btn small" type="button" id="btnDupEscolherAcao" disabled>Definir ação…</button>
      </div>
    </div>

    <div class="col-12" id="dupResumo" class="muted"></div>
  </div>
  <div class="actions">
    <button class="btn" type="button" id="dup2Voltar">Cancelar</button>
    <button class="btn" type="button" id="dup2Limpar">Limpar</button>
    <button class="btn primary" type="button" id="dup2Lancar">Lançar</button>
  </div>
</form></dialog>

<!-- MODAL: Finalizar -->
<dialog id="modalFinalizar"><div class="modal">
  <h3>Finalizar jobs — Site e Cancelados</h3>
  <div class="list" style="margin-top:8px">
    <table>
      <thead><tr><th></th><th>OT</th><th>Nome</th><th>Regional</th><th>Status atual</th></tr></thead>
      <tbody id="finList"><tr><td colspan="5" class="hint">Nenhum job em Site ou Cancelado.</td></tr></tbody>
    </table>
  </div>
  <div class="actions">
    <button class="btn" id="finCancelar" type="button">Cancelar</button>
    <button class="btn" id="finTodos" type="button">Finalizar todos</button>
    <button class="btn primary" id="finSalvar" type="button">Finalizar selecionados</button>
  </div>
</div></dialog>

<!-- MODAL: Visualizar Finalizados -->
<dialog id="modalFinalizados"><div class="modal">
  <h3>Jobs finalizados</h3>
  <div class="frow" id="finzToolbar" style="justify-content:flex-end">
    <button class="btn" id="finzSelTodos" type="button">Selecionar todos</button>
    <button class="btn" id="finzSelNenhum" type="button">Limpar</button>
    <button class="btn primary" id="finzDuplicar" type="button">Duplicar selecionados</button>
  </div>
  <div class="list">
    <table>
      <thead>
        <tr>
          <th></th><th>OT</th><th>REGIONAL</th><th>TIPO DO JOB</th>
          <th>NOME TABLOIDE</th><th>COMPLEMENTO</th><th>UF</th><th>FILIAL(S)</th>
          <th>INI</th><th>FIM</th><th>TAM</th><th>QTD</th>
        </tr>
      </thead>
      <tbody id="finzList"><tr><td colspan="12" class="hint">Carregando finalizados…</td></tr></tbody>
    </table>
  </div>
  <div class="actions"><button class="btn" id="finzFechar" type="button">Fechar</button></div>
</div></dialog>

<!-- MODAL: Dashboard -->
<dialog id="modalDash"><div class="modal">
  <h3>Dashboard — Produtividade por setor</h3>
  <div class="grid">
    <div class="col-3"><label>Período — início</label><input id="dashIni" type="date" /></div>
    <div class="col-3"><label>Período — término</label><input id="dashFim" type="date" /></div>
    <div class="col-3"><label>Status (opcional)</label>
      <select id="dashStatus">
        <option>(todos)</option><option>Novo</option><option>Lista recebida</option><option>Criando layout</option>
        <option>Digitando</option><option>Diagramando</option><option>Revisando</option>
        <option>Aprovado</option><option>Encerrando</option><option>Site</option><option>Cancelado</option><option>Finalizado</option>
      </select>
    </div>
    <div class="col-3" style="display:flex;align-items:flex-end"><button class="btn primary" id="dashAplicar" type="button">Aplicar</button></div>
  </div>

  <div id="dashOut" class="list" style="margin-top:10px;max-height:55vh;overflow:auto">
    <table>
      <thead><tr><th>Setor</th><th>Pessoa</th><th>Eventos no período</th></tr></thead>
      <tbody id="dashBody"><tr><td colspan="3" class="hint">Defina o período e clique em “Aplicar”.</td></tr></tbody>
    </table>
  </div>

  <div class="actions"><button class="btn" id="dashFechar" type="button">Fechar</button></div>
</div></dialog>

<div id="busy"><div class="box">Sincronizando…</div></div>
<div id="toast"></div>

<!//--------------------------------------------------------------------------BOTÕES-----------------------------------------------------------------------//>

<//INICIO BOTÃO CONFGI GITHUB/>
<!-- // BOTÃO CONFIGURAR GITHUB -->
<script>
  (function () {
    const btn = document.getElementById('btnCfg');
    const modal = document.getElementById('modalCfg');
    if (btn && modal) {
      btn.addEventListener('click', () => modal.showModal());
    }
  })();
</script>

<!-- // BOTÕES CONFIG GITHUB — CANCELAR + SALVAR -->
<script>
  (function () {
    const dlg         = document.getElementById('modalCfg');
    const btnCancel   = document.querySelector('#modalCfg [data-close="modalCfg"]');
    const btnSave     = document.getElementById('btnCfgSalvar');
    const inputToken  = document.getElementById('cfgToken');
    const chkRemember = document.getElementById('cfgRemember');

    // Cancelar: fecha o modal
    if (btnCancel && dlg) {
      btnCancel.addEventListener('click', () => dlg.close());
    }

    // Salvar: lê token, (opcional) salva no localStorage e fecha o modal
    if (btnSave && dlg && inputToken) {
      btnSave.addEventListener('click', () => {
        const token = (inputToken.value || '').trim();
        const remember = !!(chkRemember && chkRemember.checked);

        // deixa disponível em memória (caso você use depois)
        window.gh = window.gh || {};
        window.gh.token = token;

        // persistência opcional
        try {
          if (remember) {
            localStorage.setItem('wv_gh_cfg', JSON.stringify({ token }));
          } else {
            localStorage.removeItem('wv_gh_cfg');
          }
        } catch (e) { /* ignore */ }

        dlg.close();
      });
    }
  })();
</script>

<!-- // BOTÃO CADASTRAR -->
<script>
  (function () {
    const btn  = document.getElementById('btnCadastrar');
    const dlg  = document.getElementById('modalCadastro');
    const form = document.getElementById('formCadastro');

    if (btn && dlg) {
      btn.addEventListener('click', () => {
        if (form) form.reset(); // abre o modal com o formulário limpo
        dlg.showModal();
      });
    }
  })();
</script>

<!-- // CADASTRO: LIMPAR • CANCELAR • CADASTRAR (grava em users.csv no GitHub) -->
<script>
(function () {
  /* ====== AJUSTE AQUI SE PRECISAR ====== */
  const GH = {
    owner:  'JPVectorsitem',       // <- dono da conta/org no GitHub
    repo:   'LINKS-img',           // <- repositório
    branch: 'main',                // <- branch
    usersPath: 'users.csv'         // <- caminho do arquivo de usuários
  };
  const CAD_GATE = 'WKflvec104tp1408'; // senha de liberação do cadastro

  /* ====== ELEMENTOS ====== */
  const dlg   = document.getElementById('modalCadastro');
  const form  = document.getElementById('formCadastro');
  const btnL  = document.getElementById('btnLimparCadastro');
  const btnC  = document.querySelector('#modalCadastro [data-close="modalCadastro"]');
  const btnOK = document.getElementById('btnDoCadastrar');

  /* ====== UTILS ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { alert(msg); return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if (msg) o.querySelector('.box').textContent = msg;
  }
  function nowISO(){ return new Date().toISOString(); }

  // Pega token salvo pelo modal "Configurar GitHub"
  function getToken(){
    try {
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg') || '{}');
      // prioridade para token em memória se você tiver definido window.gh.token
      return (window.gh && window.gh.token) || saved.token || '';
    } catch { return (window.gh && window.gh.token) || ''; }
  }

  // CSV helpers (simples e seguro p/ vírgulas e quebras)
  const csvEsc = v => {
    v = v == null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  const toCsvLine = arr => arr.map(csvEsc).join(',');

  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){ cur+='"'; i++; } else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjects(t){
    const rows=parseCsv(t); if(!rows.length) return [];
    const H=rows[0]; const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return out;
  }
  function objectsToCsv(H, objs){
    const head = H.join(',')+'\n';
    const body = objs.map(o=> toCsvLine(H.map(h=> o[h] ?? '')) ).join('\n');
    return head + body + (body ? '\n' : '');
  }

  // GitHub helpers
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }

  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token){ throw new Error('Token GitHub não configurado.'); }
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler arquivo no GitHub ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToUtf8(j.content) : '';
    return { text: content, sha: j.sha || null };
  }

  async function ghPutFile(path, newText, message){
    const token = getToken();
    if(!token){ throw new Error('Token GitHub não configurado.'); }
    // Primeiro descobre se existe para pegar o SHA
    let sha = null;
    try {
      const cur = await ghGetFile(path, GH.branch);
      sha = cur.sha;
    } catch (e) {
      // se der 404 acima, seguimos com sha = null para criar
    }
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: message || `chore(csv): update ${path}`,
      content: utf8ToB64(newText),
      branch: GH.branch,
      ...(sha ? { sha } : {})
    };
    const r = await fetch(url, {
      method: 'PUT',
      headers: { ...ghHeaders(token), 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!r.ok) {
      const txt = await r.text();
      throw new Error('Falha ao salvar no GitHub ('+r.status+'): '+txt);
    }
    return true;
  }

  async function appendUserRow(user){
    // Lê users.csv (ou cria com cabeçalho)
    const HEAD = ['nome','email','senha','cargo_principal','cargo_secundaria','criado_em'];
    const { text } = await ghGetFile(GH.usersPath, GH.branch);
    let list = [];
    if (!text) {
      list = [];
    } else {
      list = csvToObjects(text);
    }

    // checa duplicidade por e-mail (case-insensitive)
    const emailEq = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();
    if (list.some(u => emailEq(u.email, user.email))) {
      throw new Error('E-mail já cadastrado.');
    }

    list.push(user);
    const csv = objectsToCsv(HEAD, list);
    await ghPutFile(GH.usersPath, csv, `chore(csv): add user ${user.email}`);
  }

  /* ====== HANDLERS ====== */
  // LIMPAR
  if (btnL && form) {
    btnL.addEventListener('click', () => form.reset());
  }

  // CANCELAR
  if (btnC && dlg) {
    btnC.addEventListener('click', () => dlg.close());
  }

  // CADASTRAR (grava no users.csv)
  if (btnOK && form && dlg) {
    btnOK.addEventListener('click', async () => {
      const nome   = (document.getElementById('cadNome')?.value || '').trim();
      const email  = (document.getElementById('cadEmail')?.value || '').trim();
      const senha  = (document.getElementById('cadSenha')?.value || '').trim();
      const cargoP = (document.getElementById('cadCargoP')?.value || '').trim();
      const cargoS = (document.getElementById('cadCargoS')?.value || '').trim();
      const gate   = (document.getElementById('cadGate')?.value || '').trim();

      // validações básicas
      if (!nome || !email || !senha || !cargoP) {
        toast('Preencha Nome, E-mail, Senha e Cargo PRINCIPAL.');
        return;
      }
      if (!/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email)) {
        toast('E-mail inválido.');
        return;
      }
      if (!gate) {
        toast('Informe a senha de liberação.');
        return;
      }
      if (gate !== CAD_GATE) {
        toast('Senha de liberação inválida.');
        return;
      }
      if (!getToken()) {
        toast('Configurar GitHub primeiro (⚙).');
        return;
      }

      // grava
      setBusy(true, 'Salvando cadastro…');
      try {
        await appendUserRow({
          nome,
          email,
          senha,
          cargo_principal: cargoP,
          cargo_secundaria: cargoS,
          criado_em: nowISO()
        });
        toast('Cadastro salvo.');
        form.reset();
        dlg.close();
      } catch (e) {
        console.error(e);
        toast(e.message || 'Erro ao cadastrar.');
      } finally {
        setBusy(false);
      }
    });
  }
})();
</script>

<!-- // CADASTRO: LIMPAR • CANCELAR • CADASTRAR (grava em users.csv no GitHub) - FIM -->

<!-- // ESQUECI A SENHA: abrir modal + LIMPAR • CANCELAR • VALIDAR • ATUALIZAR -->
<script>
(function () {
  /* ====== CONFIG GITHUB (ajuste se precisar) ====== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    usersPath: 'users.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnOpen   = document.getElementById('btnEsqueci');
  const dlg       = document.getElementById('modalReset');
  const form      = document.getElementById('formReset');
  const btnLimpar = document.getElementById('btnResetLimpar');
  const btnCancel = document.querySelector('#modalReset [data-close="modalReset"]');
  const btnValid  = document.getElementById('btnResetValidar');
  const btnAtual  = document.getElementById('btnResetAtualizar');
  const wrapNova  = document.getElementById('resetNovaSenhaWrap');

  /* ====== CAMPOS ====== */
  const inpNome   = document.getElementById('resetNome');
  const inpEmail  = document.getElementById('resetEmail');
  const selCargo  = document.getElementById('resetCargo');
  const inpNova   = document.getElementById('resetNovaSenha');

  /* ====== STATE ====== */
  let _users = [];
  let _idx   = -1;

  /* ====== UTILS ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { alert(msg); return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if (msg) o.querySelector('.box').textContent = msg;
  }
  function getToken(){
    try {
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg') || '{}');
      return (window.gh && window.gh.token) || saved.token || '';
    } catch { return (window.gh && window.gh.token) || ''; }
  }
  const eqi = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();

  // CSV helpers
  const csvEsc = v => {
    v = v == null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  const toCsvLine = arr => arr.map(csvEsc).join(',');
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){ cur+='"'; i++; } else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjects(t){
    const rows=parseCsv(t); if(!rows.length) return [];
    const H=rows[0]; const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return out;
  }
  function objectsToCsv(H, objs){
    const head = H.join(',')+'\n';
    const body = objs.map(o=> toCsvLine(H.map(h=> o[h] ?? '')) ).join('\n');
    return head + body + (body ? '\n' : '');
  }

  // GitHub helpers
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token) throw new Error('Token GitHub não configurado.');
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToUtf8(j.content) : '';
    return { text: content, sha: j.sha || null };
  }
  async function ghPutFile(path, newText, message){
    const token = getToken();
    if(!token) throw new Error('Token GitHub não configurado.');
    // pega SHA atual (se existir)
    let sha = null;
    try { const cur = await ghGetFile(path, GH.branch); sha = cur.sha; } catch {}
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: message || `chore(csv): update ${path}`,
      content: utf8ToB64(newText),
      branch: GH.branch,
      ...(sha ? { sha } : {})
    };
    const r = await fetch(url, {
      method: 'PUT',
      headers: { ...ghHeaders(token), 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!r.ok) throw new Error('Falha ao salvar ('+r.status+')');
    return true;
  }

  async function loadUsers(){
    const { text } = await ghGetFile(GH.usersPath, GH.branch);
    return csvToObjects(text);
  }
  async function saveUsers(list){
    const HEAD = ['nome','email','senha','cargo_principal','cargo_secundaria','criado_em'];
    const csv = objectsToCsv(HEAD, list);
    await ghPutFile(GH.usersPath, csv, `chore(csv): update ${GH.usersPath}`);
  }

  function hideUpdateUI(){
    if (wrapNova) wrapNova.style.display = 'none';
    if (btnAtual) btnAtual.style.display = 'none';
    if (inpNova) inpNova.value = '';
    _idx = -1;
  }
  function showUpdateUI(){
    if (wrapNova) wrapNova.style.display = 'block';
    if (btnAtual) btnAtual.style.display = 'inline-block';
  }

  /* ====== ABRIR MODAL (Esqueci minha senha/e-mail!) ====== */
  if (btnOpen && dlg) {
    btnOpen.addEventListener('click', () => {
      if (form) form.reset();
      hideUpdateUI();
      dlg.showModal();
    });
  }

  /* ====== LIMPAR ====== */
  if (btnLimpar && form) {
    btnLimpar.addEventListener('click', () => {
      form.reset();
      hideUpdateUI();
    });
  }

  /* ====== CANCELAR ====== */
  if (btnCancel && dlg) {
    btnCancel.addEventListener('click', () => {
      hideUpdateUI();
      dlg.close();
    });
  }

  /* ====== VALIDAR (confere Nome + E-mail + Cargo) ====== */
  if (btnValid) {
    btnValid.addEventListener('click', async () => {
      const nome  = (inpNome?.value  || '').trim();
      const email = (inpEmail?.value || '').trim();
      const cargo = (selCargo?.value || '').trim();

      if (!nome || !email || !cargo) {
        toast('Preencha Nome, E-mail e Cargo.');
        hideUpdateUI();
        return;
      }
      if (!getToken()) {
        toast('Configurar GitHub primeiro (⚙).');
        hideUpdateUI();
        return;
      }

      setBusy(true,'Validando…');
      try {
        _users = await loadUsers();

        // procura por Nome+Email+Cargo (aceita cargo_principal, cargo_secundaria ou cargo)
        _idx = _users.findIndex(u =>
          eqi(u.nome, nome) &&
          eqi(u.email, email) &&
          ( eqi(u.cargo_principal, cargo) || eqi(u.cargo_secundaria, cargo) || eqi(u.cargo, cargo) )
        );

        if (_idx === -1) {
          toast('Nome/E-mail/Cargo não correspondente.');
          hideUpdateUI();
        } else {
          showUpdateUI();
        }
      } catch (e) {
        console.error(e);
        toast('Erro ao validar.');
        hideUpdateUI();
      } finally {
        setBusy(false);
      }
    });
  }

  /* ====== ATUALIZAR (salva nova senha no users.csv) ====== */
  if (btnAtual) {
    btnAtual.addEventListener('click', async () => {
      if (_idx < 0 || !_users.length) {
        toast('Valide seus dados primeiro.');
        return;
      }
      const nova = (inpNova?.value || '').trim();
      if (!nova) {
        toast('Digite a nova senha.');
        return;
      }
      _users[_idx].senha = nova;

      setBusy(true,'Salvando…');
      try {
        await saveUsers(_users);
        toast('Senha atualizada!');
        if (form) form.reset();
        hideUpdateUI();
        dlg?.close();
      } catch (e) {
        console.error(e);
        toast('Erro ao salvar.');
      } finally {
        setBusy(false);
      }
    });
  }
})();
</script>

<!-- // ESQUECI A SENHA: abrir modal + LIMPAR • CANCELAR • VALIDAR • ATUALIZAR - FIM-->

<!-- BOTÃO LOGIN — lê users.csv no GitHub, valida e abre a área de trabalho (jobs) [versão TURBO] -->
<script>
(function () {
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    usersPath: 'users.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnLogin  = document.getElementById('btnLogin');
  const inpEmail  = document.getElementById('email');
  const inpSenha  = document.getElementById('senha');

  const loginView = document.getElementById('loginView');
  const jobsApp   = document.getElementById('jobsApp');

  const elUserName = document.getElementById('userName');
  const chip1 = document.getElementById('cargo1');
  const chip2 = document.getElementById('cargo2');

  /* ====== UTILS ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { alert(msg); return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if (msg) o.querySelector('.box').textContent = msg;
  }
  function getToken(){
    try {
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg') || '{}');
      return (window.gh && window.gh.token) || saved.token || '';
    } catch { return (window.gh && window.gh.token) || ''; }
  }
  const eqi = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();

  // CSV helpers
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){ cur+='"'; i++; } else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){ }
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjects(t){
    const rows=parseCsv(t); if(!rows.length) return [];
    const H=rows[0]; const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return out;
  }

  // GitHub helpers
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token){ throw new Error('Token GitHub não configurado.'); }
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler arquivo no GitHub ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToUtf8(j.content) : '';
    return { text: content, sha: j.sha || null };
  }

  // UI helpers
  function roleKey(c){
    const k=(c||'').trim().toLowerCase();
    if(['administrador','administrator','diretor','gerente'].includes(k)) return 'prata';
    if(k==='trafego') return 'verde';
    if(k==='layout') return 'roxo';
    if(k==='digitador') return 'azul';
    if(k==='diagramador') return 'laranja';
    if(k==='revisor') return 'rosa';
    if(k==='encerramento') return 'amarelo';
    if(k==='site') return 'roxoclaro';
    return 'prata';
  }
  function showJobsApp(user){
    if (elUserName) elUserName.textContent = user?.nome || '—';
    if (chip1) {
      const c1 = user?.cargo_principal || user?.cargo || '';
      if (c1) {
        chip1.textContent = c1;
        chip1.className = 'role-chip role-' + roleKey(c1);
        chip1.style.display = 'inline-block';
      } else chip1.style.display = 'none';
    }
    if (chip2) {
      const c2 = user?.cargo_secundaria || '';
      if (c2) {
        chip2.textContent = c2;
        chip2.className = 'role-chip role-' + roleKey(c2);
        chip2.style.display = 'inline-block';
      } else chip2.style.display = 'none';
    }
    if (loginView) { loginView.classList.add('hide'); loginView.setAttribute('aria-hidden','true'); }
    if (jobsApp)   { jobsApp.classList.remove('hide'); jobsApp.setAttribute('aria-hidden','false'); }
    if (typeof window.applyPermissions === 'function') window.applyPermissions();
  }

  async function handleLogin(){
    const email = (inpEmail?.value || '').trim();
    const senha = (inpSenha?.value || '').trim();

    if (!email || !senha) { toast('Informe e-mail e senha.'); return; }
    if (!getToken())      { toast('Configurar GitHub primeiro (⚙).'); return; }

    setBusy(true, 'Lendo usuários…');
    try {
      const { text } = await ghGetFile(GH.usersPath, GH.branch);
      const list = csvToObjects(text); // cabeçalho: nome,email,senha,cargo_principal,cargo_secundaria,criado_em

      const user = list.find(u => eqi(u.email, email) && (u.senha === senha));
      if (!user) { toast('Credenciais inválidas.'); return; }

      window.currentUser = {
        nome: user.nome || email.split('@')[0],
        cargo_principal: user.cargo_principal || user.cargo || '',
        cargo_secundaria: user.cargo_secundaria || ''
      };

      toast(`Login OK. Bem-vindo, ${window.currentUser.nome}!`);
      showJobsApp(user);

      // === TURBO LOAD do jobs.csv ===
      if (window.TurboJobs && typeof window.TurboJobs.mount === 'function') {
        await window.TurboJobs.mount();
      } else if (typeof window.loadJobsCsv === 'function' && typeof window.insertJobRow === 'function') {
        // fallback antigo
        setBusy(true,'Carregando jobs…');
        await window.loadJobsCsv();
        document.querySelectorAll('#jobsBody tr[data-ot]').forEach(tr=>tr.remove());
        [...window.JOBS.values()]
          .sort((a,b)=> a.ot.localeCompare(b.ot, undefined, {numeric:true, sensitivity:'base'}))
          .forEach(window.insertJobRow);
      }
    } catch (e) {
      console.error(e);
      toast('Falha ao carregar usuários.');
    } finally {
      setBusy(false);
    }
  }

  if (btnLogin) btnLogin.addEventListener('click', handleLogin);
  // Enter na tela de login
  document.addEventListener('keydown', (e)=>{
    if (e.key !== 'Enter') return;
    const visibleLogin = loginView && !loginView.classList.contains('hide');
    if (visibleLogin) handleLogin();
  });
})();
</script>
<!-- // BOTÃO LOGIN — FIM -->


<!//---------------------------------------------------------FIM DOS BOTÕES TELA LOGIN--------------------------------------------------------------//>

<!//--------------------------------------------------------____INICIO BOTÕES JOBS____--------------------------------------------------------------//>

<!-- // BOTÃO SAIR (segunda tela / jobs) -->
<script>
(function () {
  const btnSair   = document.getElementById('btnSair');
  const loginView = document.getElementById('loginView');
  const jobsApp   = document.getElementById('jobsApp');

  const elUserName = document.getElementById('userName');
  const chip1 = document.getElementById('cargo1');
  const chip2 = document.getElementById('cargo2');

  const inpEmail = document.getElementById('email');
  const inpSenha = document.getElementById('senha');

  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 1800);
  }

  function showLogin(){
    if (jobsApp) {
      jobsApp.classList.add('hide');
      jobsApp.setAttribute('aria-hidden','true');
    }
    if (loginView) {
      loginView.classList.remove('hide');
      loginView.setAttribute('aria-hidden','false');
    }
  }

  if (btnSair) {
    btnSair.addEventListener('click', () => {
      // limpa estado em memória (se estiver usando)
      window.currentUser = null;

      // reseta cabeçalho do usuário
      if (elUserName) elUserName.textContent = '—';
      if (chip1) { chip1.style.display = 'none'; chip1.textContent = ''; }
      if (chip2) { chip2.style.display = 'none'; chip2.textContent = ''; }

      // volta para a tela de login
      showLogin();

      // opcional: limpa campos de login e foca no e-mail
      if (inpSenha) inpSenha.value = '';
      if (inpEmail) { inpEmail.focus(); }

      toast('Sessão encerrada.');
    });
  }
})();
</script>

<!-- // BOTÃO SAIR (segunda tela / jobs) FIM-->

<!-- // CARREGAR JOBS DE jobs.csv E POPULAR A TABELA DA ÁREA DE TRABALHO -->
<script>
(function () {
  /* ====== CONFIG GITHUB (ajuste se precisar) ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv'
  };

  /* ====== ELEMENTOS ====== */
  const jobsApp  = document.getElementById('jobsApp');
  const tbody    = document.getElementById('jobsBody');

  /* ====== UX helpers ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if (msg) o.querySelector('.box').textContent = msg;
  }
  function getToken(){
    try {
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg') || '{}');
      return (window.gh && window.gh.token) || saved.token || '';
    } catch { return (window.gh && window.gh.token) || ''; }
  }

  /* ====== CSV helpers ====== */
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){ cur+='"'; i++; } else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjects(t){
    const rows=parseCsv(t); if(!rows.length) return [];
    const H=rows[0]; const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return out;
  }

  /* ====== GitHub helpers ====== */
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token){ throw new Error('Token GitHub não configurado.'); }
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler arquivo no GitHub ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToUtf8(j.content) : '';
    return { text: content, sha: j.sha || null };
  }

  /* ====== Render helpers ====== */
  const eqi = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();
  function parseBool(v){ return ['1','true','sim','yes'].includes(String(v||'').trim().toLowerCase()); }
  function statusToClass(status){
    const s=(status||'').toLowerCase();
    if(s==='novo') return 'st-novo';
    if(s==='lista recebida') return 'st-lista';
    if(s==='criando layout') return 'st-layout';
    if(s==='digitando') return 'st-digitando';
    if(s==='diagramando') return 'st-diagramando';
    if(s==='revisando') return 'st-revisando';
    if(s==='aprovado') return 'st-aprovado';
    if(s==='encerrando') return 'st-encerrando';
    if(s==='site') return 'st-site';
    if(s==='cancelado') return 'st-cancelado';
    if(s==='finalizado') return 'st-finalizado';
    return '';
  }

  // acha o header de uma regional (tr.sep-row) pelo texto
  function findRegionalHeader(name){
    const rows = tbody ? tbody.querySelectorAll('tr.sep-row') : null;
    if (!rows) return null;
    name = (name||'').trim();
    for (const r of rows) {
      if ((r.textContent || '').trim() === name) return r;
    }
    return null;
  }

  // garante a sub-row "AÇÃO — X" dentro de ESPECIAL NACIONAL
  function ensureActionSubRow(actionName){
    if (!tbody) return null;
    const name = (actionName || '').trim();
    if (!name) return null;
    let sub = tbody.querySelector(`tr.sub-row[data-sub="${CSS.escape(name)}"]`);
    if (sub) return sub;

    sub = document.createElement('tr');
    sub.className = 'sub-row';
    sub.setAttribute('data-sub', name);
    const td = document.createElement('td');
    td.colSpan = 14;
    td.textContent = `AÇÃO — ${name}`;
    sub.appendChild(td);

    const header = findRegionalHeader('ESPECIAL NACIONAL');
    if (header) header.after(sub);
    else tbody.appendChild(sub);

    return sub;
  }

  // insere tr após o último item dentro do mesmo grupo (regional ou sub-ação)
  function insertAfterGroup(anchorRow, tr, matchAttr){
    // percorre a frente até outro "sep-row" (novo grupo) ou sub-row diferente
    let cursor = anchorRow;
    let last = anchorRow;
    while (cursor && (cursor = cursor.nextElementSibling)) {
      if (cursor.classList.contains('sep-row')) break;
      if (cursor.classList.contains('sub-row') && matchAttr === 'data-sub') {
        // parou quando mudou a ação
        if (cursor.getAttribute('data-sub') !== anchorRow.getAttribute('data-sub')) break;
      }
      // se for linha comum, mas pertencer a outro sub-grupo, para
      if (!cursor.classList.contains('sep-row') && !cursor.classList.contains('sub-row')) {
        if (matchAttr) {
          const a = (cursor.getAttribute(matchAttr) || '');
          const b = (anchorRow.getAttribute(matchAttr) || '');
          if (a !== b) break;
        }
      }
      last = cursor;
    }
    last.after(tr);
  }

  function insertUnderRegional(headerRow, tr){
    if (!headerRow) { tbody.appendChild(tr); return; }
    insertAfterGroup(headerRow, tr); // usa o header como âncora
  }

  function insertUnderActionSubRow(subRow, tr){
    if (!subRow) { tbody.appendChild(tr); return; }
    tr.setAttribute('data-sub', subRow.getAttribute('data-sub') || '');
    insertAfterGroup(subRow, tr, 'data-sub');
  }

  function fmt(v){ return v ? v : '—'; }

  function makeJobRow(j){
    const tr = document.createElement('tr');
    tr.setAttribute('data-ot', j.ot || '');
    tr.className = statusToClass(j.status) || 'st-novo';

    tr.innerHTML = `
      <td>${fmt(j.ot)}</td>
      <td>${fmt(j.regional)}</td>
      <td>${fmt(j.tipoLoja)}</td>
      <td>${fmt(j.tipoJob)}</td>
      <td>${fmt(j.nome)}</td>
      <td>${fmt(j.compl)}</td>
      <td>${fmt(j.uf)}</td>
      <td>${fmt(j.filial)}</td>
      <td>${fmt(j.ini)}</td>
      <td>${fmt(j.fim)}</td>
      <td>${fmt(j.tam)}</td>
      <td>${fmt(j.qtd)}</td>
      <td>${fmt(j.status)}</td>
      <td>—</td>
    `;
    return tr;
  }

  function clearOldJobRows(){
    if (!tbody) return;
    // mantém apenas os separadores de regionais e possíveis sub-rows já existentes
    [...tbody.querySelectorAll('tr')].forEach(tr=>{
      if (tr.classList.contains('sep-row') || tr.classList.contains('sub-row')) return;
      tr.remove();
    });
    // remove sub-rows de ações (serão refeitas conforme necessário)
    [...tbody.querySelectorAll('tr.sub-row')].forEach(tr=> tr.remove());
  }

  function sortByOT(a,b){
    // tenta extrair número do "OT- 01" etc.
    const na = (String(a.ot||'').match(/(\d+)/)||[])[1];
    const nb = (String(b.ot||'').match(/(\d+)/)||[])[1];
    const ia = na ? parseInt(na,10) : Number.MAX_SAFE_INTEGER;
    const ib = nb ? parseInt(nb,10) : Number.MAX_SAFE_INTEGER;
    if (ia !== ib) return ia - ib;
    return String(a.ot||'').localeCompare(String(b.ot||''), undefined, {numeric:true});
  }

  async function loadAndRenderJobs(){
    if (!tbody) return;
    setBusy(true, 'Carregando jobs…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const rows = csvToObjects(text);

      // mapeia campos esperados
      const jobs = rows.map(r => ({
        ot: r.ot,
        regional: r.regional || r.regionalGrupo || '',
        tipoLoja: r.tipoLoja,
        tipoJob:  r.tipoJob,
        nome:     r.nome,
        compl:    r.compl,
        uf:       r.uf,
        filial:   r.filial,
        ini:      r.ini,
        fim:      r.fim,
        tam:      r.tam,
        qtd:      r.qtd,
        isNacional: parseBool(r.isNacional),
        acaoNome:  r.acaoNome || '',
        status:    r.status || 'Novo'
      })).sort(sortByOT);

      clearOldJobRows();

      if (!jobs.length){
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 14;
        td.className = 'hint';
        td.textContent = 'Sem jobs cadastrados.';
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }

      // insere cada job no seu grupo
      for (const j of jobs){
        const tr = makeJobRow(j);
        if (j.isNacional) {
          const sub = ensureActionSubRow(j.acaoNome || '—');
          insertUnderActionSubRow(sub, tr);
        } else {
          const header = findRegionalHeader(j.regional || 'REGIONAL SP'); // fallback
          insertUnderRegional(header, tr);
        }
      }
    } catch (e){
      console.error(e);
      toast('Falha ao carregar jobs.');
    } finally {
      setBusy(false);
    }
  }

  /* ====== Dispara quando a tela de jobs abrir ======
     (observa mudança de visibilidade e carrega uma única vez) */
  let loadedOnce = false;
  function maybeLoad(){
    if (loadedOnce) return;
    const isVisible = jobsApp && !jobsApp.classList.contains('hide') && jobsApp.getAttribute('aria-hidden') !== 'true';
    if (isVisible) {
      loadedOnce = true;
      loadAndRenderJobs();
    }
  }

  if (jobsApp) {
    // tenta já carregar se estiver visível
    maybeLoad();

    // observa mudanças (ex.: após login)
    const mo = new MutationObserver(maybeLoad);
    mo.observe(jobsApp, { attributes: true, attributeFilter: ['class','aria-hidden'] });
  }

  // também expõe manualmente se quiser chamar após o login:
  window.loadJobsFromGitHub = loadAndRenderJobs;
})();
</script>

<!-- // CARREGAR JOBS DE jobs.csv E POPULAR A TABELA DA ÁREA DE TRABALHO - FIM -->

<!-- // FILIAIS: mostrar "…" na tabela e abrir modal com a lista completa ao clicar -->
<script>
(function () {
  const tbody = document.getElementById('jobsBody');
  const dlg   = document.getElementById('modalCell');
  const title = document.getElementById('cellTitle');
  const body  = document.getElementById('cellBody');
  const btnClose = document.getElementById('btnCellFechar');

  // Converte a célula de Filiais em "…" clicável com o valor completo em data-full
  function decorateFiliaisRow(tr){
    if (!tr || !tr.matches('tr[data-ot]')) return;
    const td = tr.children && tr.children[7]; // coluna "FILIAL (S)" (8ª coluna)
    if (!td || td.querySelector('.clip')) return;

    const full = (td.textContent || '').trim();
    // se vazio, deixa como está (não vira link)
    if (!full || full === '—') return;

    const span = document.createElement('span');
    span.className = 'clip';
    span.textContent = '…';       // mostra apenas "…"
    span.setAttribute('data-full', full);
    span.setAttribute('title', 'Clique para ver todas as filiais');

    td.textContent = '';
    td.appendChild(span);
  }

  // Decora todas as linhas atuais
  function decorateAll(){
    if (!tbody) return;
    tbody.querySelectorAll('tr[data-ot]').forEach(decorateFiliaisRow);
  }

  // Observa novas linhas inseridas (ex.: após carregar CSV)
  if (tbody) {
    const mo = new MutationObserver(muts=>{
      muts.forEach(m=>{
        m.addedNodes.forEach(n=>{
          if (n.nodeType === 1 && n.matches('tr[data-ot]')) decorateFiliaisRow(n);
        });
      });
    });
    mo.observe(tbody, { childList: true });
    decorateAll();
  }

  // Clique no "…" abre o modal com a lista completa
  if (tbody) {
    tbody.addEventListener('click', (e)=>{
      const el = e.target.closest('.clip[data-full]');
      if (!el) return;

      const full = el.getAttribute('data-full') || '';
      const items = full.split(',').map(s=>s.trim()).filter(Boolean);

      if (title) title.textContent = 'Filial(s)';
      if (body) {
        body.style.whiteSpace = 'pre-wrap';
        body.textContent = items.length ? items.join('\n') : full || '—';
      }
      dlg && dlg.showModal();
    });
  }

  // Fechar modal
  if (btnClose && dlg) {
    btnClose.addEventListener('click', ()=> dlg.close());
  }
})();
</script>

<!-- // FILIAIS: mostrar "…" na tabela e abrir modal com a lista completa ao clicar - FIM -->

<!-- // SELEÇÃO DE LINHAS NA TABELA DE JOBS (single-select) -->
<script>
(function () {
  const tbody = document.getElementById('jobsBody');

  // estado global (opcional, para outros scripts usarem)
  window.selectedOT = null;

  function clearSelection() {
    if (!tbody) return;
    tbody.querySelectorAll('tr.sel').forEach(tr => {
      tr.classList.remove('sel');
      tr.removeAttribute('aria-selected');
    });
    window.selectedOT = null;
  }

  function selectRow(tr) {
    if (!tr || !tr.hasAttribute('data-ot')) return;
    // ignora cabeçalhos/separadores
    if (tr.classList.contains('sep-row') || tr.classList.contains('sub-row')) return;

    clearSelection();
    tr.classList.add('sel');
    tr.setAttribute('aria-selected', 'true');
    window.selectedOT = tr.getAttribute('data-ot') || null;
  }

  // evita selecionar quando o clique é em elementos interativos (links, botões, "…", inputs etc.)
  function isInteractive(target) {
    return !!(
      target.closest('a,button,input,select,textarea,[contenteditable="true"]') ||
      target.closest('.clip') // o "…" das filiais
    );
  }

  function rowFromEventTarget(target) {
    const tr = target.closest('tr');
    if (!tr || !tr.hasAttribute('data-ot')) return null;
    if (isInteractive(target)) return null;
    return tr;
  }

  if (tbody) {
    // clique para selecionar (single-select)
    tbody.addEventListener('click', (e) => {
      const tr = rowFromEventTarget(e.target);
      if (tr) selectRow(tr);
    });

    // mantém a seleção após recarregar/repintar linhas
    const mo = new MutationObserver(() => {
      if (!window.selectedOT) return;
      const esc = (window.CSS && CSS.escape) ? CSS.escape : (s)=> String(s).replace(/"/g, '\\"');
      const tr = tbody.querySelector(`tr[data-ot="${esc(window.selectedOT)}"]`);
      if (!tr) {
        // linha sumiu, limpa seleção
        clearSelection();
      } else {
        // garante a classe/atributo se perderem
        tbody.querySelectorAll('tr.sel').forEach(r => {
          if (r !== tr) { r.classList.remove('sel'); r.removeAttribute('aria-selected'); }
        });
        tr.classList.add('sel');
        tr.setAttribute('aria-selected','true');
      }
    });
    mo.observe(tbody, { childList: true });
  }

  // helpers públicos (caso queira usar em outros scripts)
  window.getSelectedOT  = () => window.selectedOT || null;
  window.getSelectedRow = () => (tbody && tbody.querySelector('tr.sel')) || null;
  window.clearJobSelection = clearSelection;
})();
</script>

<!-- // SELEÇÃO DE LINHAS NA TABELA DE JOBS (single-select) - FIM -->

<!-- // FIX: topbar sólida e fixa + cabeçalho e separadores grudados -->
<style>
  /* Topbar: fixa e com fundo sólido */
  #jobsApp .topbar{
    position: fixed;          /* fixa no topo */
    top: 0; left: 0; right: 0;
    height: var(--topbar-h);
    z-index: 2000;
    background: #0f182b;      /* sólido (sem transparência/gradiente) */
    border-bottom: 1px solid rgba(255,255,255,.14);
    box-shadow: 0 8px 28px rgba(0,0,0,.35);
  }
  /* empurra o conteúdo para não ficar sob a topbar */
  #jobsApp main.content{ 
    padding-top: calc(var(--topbar-h) + 12px);
  }

  /* Área rolável da tabela ocupa o viewport restante */
  #mainBox .tableWrap{
    position: relative;
    overflow: auto;
    /* tenta ocupar o que sobra da tela abaixo da topbar */
    max-height: calc(100vh - var(--topbar-h) - 32px);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 10px;
    background: rgba(0,0,0,.18);
  }

  /* Cabeçalho grudado, acima de tudo dentro da área rolável */
  #mainBox thead th{
    position: sticky;
    top: 0;                   /* topo da área rolável */
    z-index: 10;
    background: #0f182b;      /* sólido para não vazar o fundo */
    box-shadow: 0 2px 0 rgba(255,255,255,.08);
  }

  /* Linhas de separação (REGIONAL …) grudam logo abaixo do cabeçalho */
  #mainBox tbody tr.sep-row td{
    position: sticky;
    top: var(--thead-h, 40px); /* preenchido via JS com a altura real do thead */
    z-index: 8;
    background: #0d1628;       /* sólido */
    border-top: 1px solid rgba(255,255,255,.14) !important;
    border-bottom: 1px solid rgba(255,255,255,.14) !important;
  }

  /* Sub-separadores (AÇÕES do Especial Nacional) grudam abaixo das separações */
  #mainBox tbody tr.sub-row td{
    position: sticky;
    top: calc(var(--thead-h, 40px) + var(--sep-h, 34px));
    z-index: 7;
    background: #0b1426;       /* sólido */
    border-top: 1px dashed rgba(255,255,255,.16) !important;
    border-bottom: 1px dashed rgba(255,255,255,.16) !important;
  }

  /* Realça o cabeçalho quando a lista rola */
  #mainBox .tableWrap.stuck-head thead th{
    box-shadow: 0 6px 14px rgba(0,0,0,.35);
  }
</style>

<script>
(function(){
  const wrap = document.querySelector('#mainBox .tableWrap');
  const thead = document.querySelector('#mainBox thead');

  // 1) mede a altura REAL do thead e salva numa var CSS,
  //    para posicionar as linhas de separação exatamente abaixo dele.
  function setHeadVars(){
    if (!wrap || !thead) return;
    const h = thead.offsetHeight || 40;             // altura do cabeçalho
    const sepRow = document.querySelector('#mainBox tbody tr.sep-row td');
    const sepH = sepRow ? sepRow.offsetHeight : 34; // altura típica da separação
    wrap.style.setProperty('--thead-h', h + 'px');
    wrap.style.setProperty('--sep-h', sepH + 'px');
  }
  setHeadVars();
  // recalcula quando a janela redimensiona (responsivo)
  window.addEventListener('resize', setHeadVars, { passive:true });

  // 2) adiciona sombra no cabeçalho quando a lista está rolando
  if (wrap){
    const onScroll = () => wrap.classList.toggle('stuck-head', wrap.scrollTop > 0);
    onScroll();
    wrap.addEventListener('scroll', onScroll, { passive:true });
  }

  // 3) garante que a área de jobs ocupe a tela e a rolagem principal fique dentro da tableWrap
  //    (opcional, mas ajuda a evitar que a topbar "pareça descer")
  const jobsApp = document.getElementById('jobsApp');
  if (jobsApp && !jobsApp.classList.contains('ready-fixed')){
    jobsApp.classList.add('ready-fixed');
    document.documentElement.style.height = '100%';
    document.body.style.height = '100%';
    // mantém o body sem rolagem vertical exagerada; rola só a lista
    document.body.style.overscrollBehavior = 'none';
  }

  // 4) se o conteúdo do thead mudar dinamicamente, observe e recalcule
  if (thead){
    const mo = new MutationObserver(setHeadVars);
    mo.observe(thead, { childList:true, subtree:true });
  }
})();
</script>

<!-- // FIX: topbar sólida e fixa + cabeçalho e separadores grudados FIM -->

<!-- // DASHBOARD v3: boxes com rolagem horizontal + modal mais largo -->
<style>
  /* Modal maior (override da regra global de dialog) */
  #modalDash {
    width: min(98vw, 1600px);
    max-width: 1600px;
  }

  #dashChartsGrid{
    margin-top:12px;
    display:grid;
    grid-template-columns: repeat(auto-fill, minmax(420px, 1fr)); /* boxes mais largos por padrão */
    gap:12px;
  }
  .chartBox{
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    background:#0b1420; /* sólido e mais escuro pra contraste */
    padding:10px 12px;
  }
  .chartBox h4{
    margin:0 0 6px 0;
    font-size:1rem;
    display:flex; align-items:center; justify-content:space-between;
    color:var(--text);
  }
  .chartBox .sub{ color:var(--muted); font-size:.85rem }

  /* SCROLLER: onde o SVG entra; cria barra horizontal se precisar */
  .chartBox .scroller{
    overflow:auto;             /* H e V se necessário */
    padding-bottom:4px;        /* espaço pra barra de rolagem */
    border-radius:8px;
    background:rgba(255,255,255,.03);
  }

  .chartBox svg{ display:block; height:320px } /* altura maior pro rótulo rotacionado */
  .axis{ stroke: rgba(255,255,255,.2); stroke-width:1 }
  .label{ font-size:11px; fill:#cfd6e6 }
  .bar:hover{ opacity:.9 }
  .empty{ color:var(--muted); font-size:.95rem; padding:8px 0 }
</style>

<script>
(function(){
  /* ===== Config GitHub ===== */
  const GH = { owner:'JPVectorsitem', repo:'LINKS-img', branch:'main', encPath:'jobs_encerrados.csv' };

  /* ===== Elementos ===== */
  const btnDash  = document.getElementById('btnDash');
  const dlg      = document.getElementById('modalDash');
  const btnClose = document.getElementById('dashFechar');
  const btnApply = document.getElementById('dashAplicar');
  const inpIni   = document.getElementById('dashIni');
  const inpFim   = document.getElementById('dashFim');
  const dashOut  = document.getElementById('dashOut');

  /* ===== Helpers ===== */
  function toast(msg){ const el=document.getElementById('toast'); if(!el) return; el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const saved=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||saved.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ===== CSV + GitHub ===== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;}else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';} else if(c=='\r'){}
      else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){row.push(cur);r.push(row);} return r;
  }
  function csvToObjects(t){ const rows=parseCsv(t); if(!rows.length) return []; const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){ const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue; const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; out.push(o); }
    return out;
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(token)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER,...(token?{'Authorization':`Bearer ${token}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path,branch){ const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)}); if(r.status===404) return {text:'',sha:null}; if(!r.ok) throw new Error('Falha ao ler ('+r.status+')'); const j=await r.json();
    return { text: j && j.content ? b64ToUtf8(j.content) : '', sha: j.sha||null };
  }

  /* ===== Lógica ===== */
  const STEP_LABEL = { layout:'Layout', digitacao:'Digitação', diagramacao:'Diagramação', revisao:'Revisão', encerramento:'Encerramento', site:'Site' };
  const SECTORS = Object.keys(STEP_LABEL);
  const parseBool = v => ['1','true','sim','yes'].includes(String(v||'').trim().toLowerCase());
  function jobRegionalGroup(row){ return parseBool(row.isNacional) ? 'ESPECIAL NACIONAL' : (row.regional || row.regionalGrupo || ''); }
  function parseLogs(raw){ try{ const j=JSON.parse(raw||'{}'); for(const k of SECTORS){ if(!Array.isArray(j[k])) j[k]=[]; } return j; }catch{ const e={}; for(const k of SECTORS) e[k]=[]; return e; } }
  function normalizeDateRange(){ const i=(inpIni?.value||'').trim(), f=(inpFim?.value||'').trim(); let dI=i?new Date(i+'T00:00:00'):null, dF=f?new Date(f+'T23:59:59'):null; if(dI&&dF&&dF<dI){const t=dI;dI=dF;dF=t;} return {dI,dF}; }
  function inRange(ts,dI,dF){ if(!ts) return false; const d=new Date(ts); if(isNaN(+d)) return false; if(dI&&d<dI) return false; if(dF&&d>dF) return false; return true; }
  function paletteFor(index){ const hue=(index*47)%360; return `hsl(${hue} 70% 60%)`; }

  /* ===== UI dinâmico: Regional + Grid ===== */
  let selRegional=null, chartsGrid=null;

  function ensureRegionalFilter(options){
    if(!selRegional){
      const grid = dlg?.querySelector('.grid');
      if(!grid) return;
      const wrap=document.createElement('div');
      wrap.className='col-3';
      wrap.innerHTML = `<label>Regional</label><select id="dashRegional"></select>`;
      grid.appendChild(wrap);
      selRegional = wrap.querySelector('#dashRegional');
    }
    const cur = selRegional.value || '(todas)';
    const opts = ['(todas)', ...options];
    selRegional.innerHTML = opts.map(o=>`<option${o===cur?' selected':''}>${o}</option>`).join('');
  }
  function ensureChartsGrid(){
    if(!chartsGrid){
      chartsGrid = document.createElement('div');
      chartsGrid.id = 'dashChartsGrid';
      dashOut?.insertAdjacentElement('afterend', chartsGrid);
    }
  }
  function clearCharts(){ if(chartsGrid) chartsGrid.innerHTML=''; }

  /* ===== Render: uma box por setor com SCROLLER ===== */
  function renderSectorBox(sectorLabel, data){
    // cria box e encaixa já no grid para conseguir medir larguras
    const box = document.createElement('div');
    box.className='chartBox';
    const total = data.reduce((s,x)=>s+x.count,0);
    box.innerHTML = `<h4>${sectorLabel} <span class="sub">Total eventos: ${total}</span></h4>`;
    const scroller = document.createElement('div');
    scroller.className = 'scroller';
    box.appendChild(scroller);
    chartsGrid.appendChild(box);

    if(!data.length){
      scroller.innerHTML = '<div class="empty">Sem dados neste período/filtragem.</div>';
      return;
    }

    // Agora que o box está no DOM, dá pra medir a largura disponível
    const availW = scroller.clientWidth || 600;

    // Geometria
    const H = 320, padL=46, padR=20, padT=12, padB=84;
    const n = data.length;
    const max = Math.max(1, ...data.map(d=>d.count));

    // Tamanho mínimo por barra para manter legibilidade
    const BAR_MIN = 22;      // largura mínima por barra
    const GAP = 8;           // gap entre barras
    const minW = padL + padR + n*BAR_MIN + (n-1)*GAP; // largura mínima total p/ caber as barras
    const W = Math.max(minW, availW);                 // se maior que área, surgirá rolagem

    const plotW = W - padL - padR;
    const barW = Math.max(BAR_MIN, (plotW - (n-1)*GAP) / n);
    const x = i => padL + i*(barW+GAP);
    const y = v => padT + (H - padT - padB) * (1 - (v/max));

    // SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', W);
    svg.setAttribute('height', H);
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    // eixo X
    const axisX=document.createElementNS(svg.namespaceURI,'line');
    axisX.setAttribute('x1',padL); axisX.setAttribute('x2',W-padR);
    axisX.setAttribute('y1',H-padB); axisX.setAttribute('y2',H-padB);
    axisX.setAttribute('class','axis');
    svg.appendChild(axisX);

    // grid Y
    for(let k=0;k<=4;k++){
      const val=Math.round(max*k/4), yy=y(val);
      const gl=document.createElementNS(svg.namespaceURI,'line');
      gl.setAttribute('x1',padL); gl.setAttribute('x2',W-padR);
      gl.setAttribute('y1',yy); gl.setAttribute('y2',yy);
      gl.setAttribute('class','axis'); gl.setAttribute('opacity','0.4');
      svg.appendChild(gl);

      const txt=document.createElementNS(svg.namespaceURI,'text');
      txt.setAttribute('x',padL-8); txt.setAttribute('y',yy+4);
      txt.setAttribute('text-anchor','end'); txt.setAttribute('class','label');
      txt.textContent=String(val);
      svg.appendChild(txt);
    }

    // barras + rótulos
    data.forEach((d,i)=>{
      const hh=(H-padT-padB)*(d.count/max);

      const rect=document.createElementNS(svg.namespaceURI,'rect');
      rect.setAttribute('x',x(i)); rect.setAttribute('y',H-padB-hh);
      rect.setAttribute('width',barW); rect.setAttribute('height',hh);
      rect.setAttribute('rx','6'); rect.setAttribute('class','bar');
      rect.setAttribute('fill', paletteFor(i));
      rect.setAttribute('title', `${d.person}: ${d.count}`);
      svg.appendChild(rect);

      const v=document.createElementNS(svg.namespaceURI,'text');
      v.setAttribute('x',x(i)+barW/2); v.setAttribute('y',H-padB-hh-6);
      v.setAttribute('text-anchor','middle'); v.setAttribute('class','label');
      v.textContent=d.count; svg.appendChild(v);

      const px=x(i)+barW/2, py=H-padB+40;
      const name=document.createElementNS(svg.namespaceURI,'text');
      name.setAttribute('x',px); name.setAttribute('y',py);
      name.setAttribute('text-anchor','end'); name.setAttribute('class','label');
      name.setAttribute('transform',`rotate(-45 ${px} ${py})`);
      name.textContent=d.person; svg.appendChild(name);
    });

    scroller.appendChild(svg);
  }

  /* ===== Aplicar ===== */
  const MAX_PESSOAS_SETOR = 50; // deixa generoso; scroll cuida do excesso

  async function applyDashboard(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    ensureChartsGrid();
    clearCharts();

    const regFiltro = (selRegional?.value || '(todas)').trim();
    const { dI, dF } = normalizeDateRange();

    setBusy(true,'Lendo finalizados…');
    try{
      const { text } = await ghGetFile(GH.encPath, GH.branch);
      const rows = csvToObjects(text);

      // regionais
      const regs = [...new Set(rows.map(jobRegionalGroup))].filter(Boolean).sort((a,b)=>a.localeCompare(b,'pt-BR'));
      ensureRegionalFilter(regs);

      // contagem setor -> pessoa
      const perSector = new Map(); // labelSetor -> Map(pessoa -> qt)
      for(const key of Object.values(STEP_LABEL)) perSector.set(key, new Map());

      for(const r of rows){
        const grp = jobRegionalGroup(r);
        if (regFiltro !== '(todas)' && grp !== regFiltro) continue;

        const logs = parseLogs(r.logs);
        for(const k of SECTORS){
          const label = STEP_LABEL[k];
          const evs = logs[k] || [];
          for(const ev of evs){
            if(!inRange(ev.ts, dI, dF)) continue;
            const pessoa = (ev.nome||'—').trim();
            const m = perSector.get(label);
            m.set(pessoa, (m.get(pessoa)||0)+1);
          }
        }
      }

      // render boxes
      for(const k of SECTORS){
        const label = STEP_LABEL[k];
        const m = perSector.get(label) || new Map();
        const arr = [...m.entries()].map(([person,count])=>({person,count}))
                    .sort((a,b)=> b.count - a.count || a.person.localeCompare(b.person,'pt-BR'))
                    .slice(0, MAX_PESSOAS_SETOR);
        renderSectorBox(label, arr);
      }

      if(![...perSector.values()].some(m => m.size)){
        const info=document.createElement('div');
        info.className='empty';
        info.textContent='Sem eventos para o período/filtragem.';
        chartsGrid.appendChild(info);
      }
    }catch(e){
      console.error(e);
      toast('Falha ao gerar dashboard.');
      clearCharts();
      const info=document.createElement('div'); info.className='empty'; info.textContent='Erro ao carregar dados.'; chartsGrid.appendChild(info);
    }finally{
      setBusy(false);
    }
  }

  /* ===== Binds ===== */
  if(btnDash && dlg){
    btnDash.addEventListener('click', async ()=>{
      ensureChartsGrid();
      clearCharts();
      chartsGrid.innerHTML = '<div class="empty">Defina o período e/ou a regional e clique em “Aplicar”.</div>';
      dlg.showModal();

      // carrega regionais na abertura
      try{
        const { text } = await ghGetFile(GH.encPath, GH.branch);
        const rows = csvToObjects(text);
        const regs = [...new Set(rows.map(jobRegionalGroup))].filter(Boolean).sort((a,b)=>a.localeCompare(b,'pt-BR'));
        ensureRegionalFilter(regs);
      }catch{}
    });
  }
  if(btnClose && dlg) btnClose.addEventListener('click',()=> dlg.close());
  if(btnApply) btnApply.addEventListener('click', applyDashboard);

  // re-render ao redimensionar (se o modal estiver aberto)
  window.addEventListener('resize', ()=>{ if(dlg && dlg.open) applyDashboard(); }, { passive:true });

})();
</script>


<!-- // DASHBOARD v3: boxes com rolagem horizontal + modal mais largo FIM -->

<!-- REMOVER FILTRO STATUS DO DASHBOARD -->
<style>
  /* fallback: se o bloco ainda existir, some com ele sem quebrar o grid */
  #dashStatus { display:none !important; }
  #dashStatus { visibility:hidden !important; }
</style>
<script>
(function(){
  // Remove o select e o "col-3" que o envolve, se existir
  function killDashStatus(){
    const sel = document.getElementById('dashStatus');
    if (!sel) return;
    const wrap = sel.closest('.col-3') || sel.parentElement;
    if (wrap && wrap.parentElement) wrap.parentElement.removeChild(wrap);
  }
  // tenta já na carga…
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', killDashStatus);
  } else {
    killDashStatus();
  }
  // …e também quando o modal abrir (caso o HTML seja injetado antes)
  const btnDash = document.getElementById('btnDash');
  const dlg     = document.getElementById('modalDash');
  if (btnDash && dlg){
    btnDash.addEventListener('click', killDashStatus);
  }
})();
</script>

<!-- REMOVER FILTRO STATUS DO DASHBOARD FIM -->

<!-- BOTÃO: Visualizar finalizados (carrega jobs_encerrados.csv e exibe no modal) -->
<script>
(function(){
  /* ====== Config GitHub ====== */
  const GH = { owner:'JPVectorsitem', repo:'LINKS-img', branch:'main', encPath:'jobs_encerrados.csv' };

  /* ====== Elements ====== */
  const btnOpen  = document.getElementById('btnVerFinalizados');
  const dlg      = document.getElementById('modalFinalizados');
  const tbody    = document.getElementById('finzList');
  const btnClose = document.getElementById('finzFechar');
  const btnAll   = document.getElementById('finzSelTodos');
  const btnNone  = document.getElementById('finzSelNenhum');
  // (Se você for usar duplicar depois, o botão já está no HTML: #finzDuplicar)

  /* ====== UX helpers ====== */
  function toast(m){ const d=document.getElementById('toast'); if(!d) return; d.textContent=m; d.style.display='block'; setTimeout(()=>d.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const saved=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||saved.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ====== CSV + GitHub ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;}else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';} else if(c=='\r'){}
      else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){row.push(cur);r.push(row);} return r;
  }
  function csvToObjects(t){ const rows=parseCsv(t); if(!rows.length) return []; const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){ const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue; const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; out.push(o); }
    return out;
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(token)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER,...(token?{'Authorization':`Bearer ${token}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path,branch){ const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)}); if(r.status===404) return {text:'',sha:null};
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); return { text: j && j.content ? b64ToUtf8(j.content) : '', sha: j.sha||null };
  }

  /* ====== Render ====== */
  function renderRows(rows){
    // só status Finalizado
    const onlyFinal = rows.filter(r => (r.status||'').toLowerCase()==='finalizado');
    if(!onlyFinal.length){
      tbody.innerHTML = `<tr><td colspan="12" class="hint">Nada finalizado.</td></tr>`;
      return;
    }
    onlyFinal.sort((a,b)=> (a.ot||'').localeCompare(b.ot, undefined, {numeric:true, sensitivity:'base'}));

    const frag=document.createDocumentFragment();
    onlyFinal.forEach(r=>{
      const tr=document.createElement('tr');
      const id='fz_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
      const filialTxt=(r.filial||'').trim()||'—';
      const filialShort = filialTxt.length>18 ? filialTxt.slice(0,18)+'…' : filialTxt;
      tr.innerHTML = `
        <td><input type="checkbox" data-ot="${r.ot||''}" id="${id}"></td>
        <td>${r.ot||'—'}</td>
        <td>${r.regional||'—'}</td>
        <td>${r.tipoJob||'—'}</td>
        <td>${r.nome||'—'}</td>
        <td>${r.compl||'—'}</td>
        <td>${r.uf||'—'}</td>
        <td><span class="clip" data-field="Filial(s)" data-full="${filialTxt}">${filialShort}</span></td>
        <td>${r.ini||'—'}</td>
        <td>${r.fim||'—'}</td>
        <td>${r.tam||'—'}</td>
        <td>${r.qtd||'—'}</td>`;
      frag.appendChild(tr);
    });
    tbody.innerHTML=''; tbody.appendChild(frag);
  }

  /* ====== Open ====== */
  async function openFinalizados(){
    setBusy(true,'Carregando finalizados…');
    try{
      const { text } = await ghGetFile(GH.encPath, GH.branch);
      renderRows(csvToObjects(text));
      dlg.showModal();
    }catch(e){
      console.error(e);
      tbody.innerHTML = `<tr><td colspan="12" class="hint">Erro ao carregar jobs_encerrados.csv</td></tr>`;
      dlg.showModal();
      toast('Falha ao carregar finalizados.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== Binds ====== */
  if(btnOpen)  btnOpen.addEventListener('click', openFinalizados);
  if(btnClose) btnClose.addEventListener('click', ()=> dlg.close());
  if(btnAll)   btnAll.addEventListener('click', ()=> tbody.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));
  if(btnNone)  btnNone.addEventListener('click', ()=> tbody.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=false));

  // Clique no "..." de Filial(s) abre modal de detalhe (reaproveita #modalCell)
  const cellDlg   = document.getElementById('modalCell');
  const cellTitle = document.getElementById('cellTitle');
  const cellBody  = document.getElementById('cellBody');
  if(tbody){
    tbody.addEventListener('click',(e)=>{
      const clip = e.target.closest('.clip');
      if(clip && cellDlg){
        cellTitle.textContent = clip.getAttribute('data-field') || 'Detalhes';
        cellBody.textContent  = clip.getAttribute('data-full') || '';
        cellDlg.showModal();
      }
    });
  }
})();
</script>

<!-- BOTÃO: Visualizar finalizados (carrega jobs_encerrados.csv e exibe no modal) FIM -->


<!-- // BOTÃO FINALIZAR — mover Site/Cancelado -> jobs_encerrados.csv (status Finalizado) -->
<script>
(function(){
  /* ===== CONFIG ===== */
  const GH = {
    owner: 'JPVectorsitem',
    repo:  'LINKS-img',
    branch:'main',
    jobsPath:'jobs.csv',
    encPath: 'jobs_encerrados.csv'
  };

  /* ===== Helpers UX ===== */
  const toast=(m)=>{ const el=document.getElementById('toast'); if(!el){ alert(m); return; }
    el.textContent=m; el.style.display='block'; setTimeout(()=>el.style.display='none',2200); };
  const setBusy=(v,msg)=>{ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; };
  const getToken=()=>{ try{ const saved=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||saved.token||''; }catch{ return (window.gh&&window.gh.token)||''; } };
  const nowISO=()=> new Date().toISOString();

  /* ===== CSV utils ===== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';} else if(c=='\r'){}
      else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){row.push(cur);r.push(row);} return r;
  }
  function csvToObjsAndHeader(t){
    const rows=parseCsv(t); if(!rows.length) return {header:[], rows:[]};
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return {header:H, rows:out};
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  const toCsvLine=a=>a.map(csvEsc).join(',');

  /* ===== GitHub helpers (com fallback RAW) ===== */
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok, extra={})=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{}) , ...extra});
  const b64ToUtf8=b64=>{ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); };
  const utf8ToB64=str=>{ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); };

  const _mem = new Map(); // path -> { text, sha, etag }
  const cacheGet  = (path)=> _mem.get(path)||null;
  const cachePut  = (path,entry)=>{ _mem.set(path, entry); try{ localStorage.setItem('sha:'+path, entry.sha||''); localStorage.setItem('etag:'+path, entry.etag||''); }catch{} };

  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');

    const cached = cacheGet(path);
    if (cached && typeof cached.text === 'string' && cached.text.length) return cached;

    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });

    if (r.status === 404){
      const res = { text:'', sha:null, etag:r.headers.get('ETag')||null }; cachePut(path, res); return res;
    }
    if (!r.ok){ const t=await r.text(); throw new Error('GET '+path+' '+r.status+': '+t); }

    const etag = r.headers.get('ETag') || null;
    const j = await r.json();
    let text = '';

    if (j && typeof j.content === 'string' && j.encoding === 'base64'){
      text = b64ToUtf8(j.content);
    } else if (j && j.download_url){
      const rRaw = await fetch(j.download_url);
      if (!rRaw.ok) throw new Error('RAW download falhou: '+rRaw.status);
      text = await rRaw.text();
    }

    const entry = { text, sha:j?.sha||null, etag };
    cachePut(path, entry);
    return entry;
  }

  async function ghPutFile(path, nextText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const tryPut = async (sha)=> {
      const body = { message: message || ('update: '+path), content: utf8ToB64(nextText), branch: GH.branch, ...(sha?{sha}:{}) };
      const r = await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
      const t = await r.text();
      if(!r.ok) throw new Error('PUT '+path+' '+r.status+': '+t);
      let newSha=null; let etag=null; try{ const j=JSON.parse(t); newSha=j?.content?.sha||null; }catch{}
      try{ etag=r.headers.get('ETag')||null; }catch{}
      cachePut(path, { text: nextText, sha: newSha, etag });
      return newSha;
    };
    try{
      const fresh = await ghGetFile(path, GH.branch);
      return await tryPut(fresh.sha);
    }catch(e){
      if(String(e).includes('409')){
        const fresh=await ghGetFile(path, GH.branch);
        return await tryPut(fresh.sha);
      }
      throw e;
    }
  }

  /* ===== UI refs ===== */
  const btnFinalizar   = document.getElementById('btnFinalizar');
  const dlgFinalizar   = document.getElementById('modalFinalizar');
  const finList        = document.getElementById('finList');
  const btnFinCancelar = document.getElementById('finCancelar');
  const btnFinTodos    = document.getElementById('finTodos');
  const btnFinSalvar   = document.getElementById('finSalvar');

  /* ===== Render da lista (Site/Cancelado) ===== */
  async function renderFinList(){
    setBusy(true,'Lendo jobs…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { header:H, rows } = csvToObjsAndHeader(text);
      // guarda em cache local pro salvar usar sem reler
      renderFinList._H = H;
      renderFinList._rows = rows;

      const arr = rows.filter(r => (r.status||'').toLowerCase()==='site' || (r.status||'').toLowerCase()==='cancelado');
      if(!arr.length){
        finList.innerHTML = `<tr><td colspan="5" class="hint">Nenhum job em Site ou Cancelado.</td></tr>`;
        return;
      }
      arr.sort((a,b)=> (a.ot||'').localeCompare(b.ot||'', undefined, { numeric:true, sensitivity:'base' }));

      const frag = document.createDocumentFragment();
      arr.forEach(r=>{
        const tr=document.createElement('tr');
        const id='fin_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
        tr.innerHTML = `<td><input type="checkbox" data-ot="${r.ot}" id="${id}"></td>
                        <td>${r.ot}</td><td>${r.nome||'—'}</td><td>${r.regional||'—'}</td><td>${r.status||'—'}</td>`;
        frag.appendChild(tr);
      });
      finList.innerHTML=''; finList.appendChild(frag);
    }catch(e){
      console.error(e);
      finList.innerHTML = `<tr><td colspan="5" class="hint">Erro ao carregar jobs.</td></tr>`;
    }finally{ setBusy(false); }
  }

  /* ===== Ação: Abrir modal ===== */
  if (btnFinalizar){
    btnFinalizar.addEventListener('click', async ()=>{
      await renderFinList();
      dlgFinalizar?.showModal();
    });
  }
  if (btnFinCancelar) btnFinCancelar.addEventListener('click', ()=> dlgFinalizar?.close());
  if (btnFinTodos)    btnFinTodos.addEventListener('click', ()=> finList?.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));

  /* ===== Ação: Finalizar (mover p/ jobs_encerrados.csv) ===== */
  if (btnFinSalvar){
    btnFinSalvar.addEventListener('click', async ()=>{
      const sel=[...finList.querySelectorAll('input[type="checkbox"][data-ot]:checked')].map(b=>b.getAttribute('data-ot'));
      if(!sel.length){ toast('Selecione ao menos 1 job.'); return; }
      if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

      const H = renderFinList._H || [];
      const rows = (renderFinList._rows || []).slice();

      // selecionados -> objetos + atualizar campos para Finalizado
      const mapByOT = new Map(rows.map(r=>[r.ot,r]));
      const moving = [];
      sel.forEach(ot=>{
        const r = mapByOT.get(ot);
        if(!r) return;
        const obj = {...r};
        obj.status = 'Finalizado';
        obj.statusStep = 'finalizado';
        obj.atualizado_em = nowISO();
        moving.push(obj);
      });
      if(!moving.length){ toast('Nada para finalizar.'); return; }

      // 1) montar enc.csv atualizado (append em 1 PUT)
      setBusy(true,'Gravando finalizados…');
      try{
        const enc = await ghGetFile(GH.encPath, GH.branch);
        let encText = enc.text || '';
        let encH = [];
        if (!encText.trim()){
          // cria cabeçalho
          encH = H.slice();
          encText = H.join(',') + '\n';
        }else{
          encH = csvToObjsAndHeader(encText).header;
          if (!encH || !encH.length) encH = H.slice();
        }
        const appended = moving.map(o => toCsvLine(encH.map(k => (o[k] ?? '')))).join('\n') + '\n';
        const newEncText = encText.trimEnd() + '\n' + appended;

        await ghPutFile(GH.encPath, newEncText, `chore(csv): finalize -> ${moving.length} job(s)`);

        // 2) montar jobs.csv sem os finalizados (1 PUT)
        const remain = rows.filter(r => !sel.includes(r.ot));
        const newJobsText = H.join(',')+'\n' + remain.map(o=> toCsvLine(H.map(k => (o[k] ?? '')))).join('\n') + '\n';
        await ghPutFile(GH.jobsPath, newJobsText, `chore(csv): remove finalized (${moving.length})`);

        // 3) Atualizar UI principal sem recarregar página
        sel.forEach(ot=>{
          const tr = document.querySelector(`tr[data-ot="${CSS.escape(ot)}"]`);
          if (tr){
            const sub = tr.getAttribute('data-sub');
            tr.remove();
            if (typeof window.cleanupActionIfEmpty === 'function' && sub){
              window.cleanupActionIfEmpty(sub);
            }
          }
          if (window.JOBS instanceof Map) window.JOBS.delete(ot);
        });

        // 4) feedback e fechar modal
        toast(`${moving.length} job(s) finalizados e movidos.`);
        dlgFinalizar?.close();
      }catch(e){
        console.error(e);
        toast('Erro ao finalizar. Tente novamente.');
      }finally{
        setBusy(false);
      }
    });
  }
})();
</script>
<!-- // BOTÃO FINALIZAR — FIM -->

<!-- PLUS na coluna ETAPAS + cores por etapa no modal -->
<style>
  /* garante centralização do botão da última coluna */
  #mainBox tbody td:last-child{ text-align:center }
  #mainBox .etapasBtn{ min-width:34px }

  /* ====== ETAPAS (modal) – layout e cores por etapa ====== */
  .etapasGrid{
    display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:12px;
  }
  .etapaCard{
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px; background:#0d1628;
    overflow:hidden;
  }
  .etapaHead{
    display:flex; align-items:center; justify-content:space-between;
    padding:8px 10px; font-weight:700;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .etapaLogs{ padding:8px 10px; max-height:220px; overflow:auto }
  .etapaLogs .ev{ display:flex; align-items:center; justify-content:space-between;
    padding:6px 0; border-top:1px dashed rgba(255,255,255,.12) }
  .etapaLogs .ev:first-child{ border-top:none }

  /* BARRA colorida por etapa (usa classe k-*) */
  .etapaCard .etapaHead{ border-left:6px solid transparent }
  .etapaCard.k-lista        .etapaHead{ border-left-color:#9cc9ff }  /* Lista */
  .etapaCard.k-layout       .etapaHead{ border-left-color:#9b87f5 }  /* Layout */
  .etapaCard.k-digitacao    .etapaHead{ border-left-color:#7aa7ff }  /* Digitação */
  .etapaCard.k-diagramacao  .etapaHead{ border-left-color:#f59e0b }  /* Diagramação */
  .etapaCard.k-revisao      .etapaHead{ border-left-color:#fbcfe8 }  /* Revisão */
  .etapaCard.k-aprovacao    .etapaHead{ border-left-color:#bbf7d0 }  /* Aprovação */
  .etapaCard.k-encerramento .etapaHead{ border-left-color:#fde68a }  /* Encerramento */
  .etapaCard.k-site         .etapaHead{ border-left-color:#d8b4fe }  /* Site */
  .etapaCard.k-cancelado    .etapaHead{ border-left-color:#ef4444 }  /* Cancelado */
</style>

<script>
(function(){
  /* ============== 1) Garante o botão “+” na coluna de ETAPAS ============== */
  function makeEtapasBtn(ot){
    const b=document.createElement('button');
    b.type='button'; b.className='btn small etapasBtn';
    b.textContent='+'; b.setAttribute('data-etapas', ot);
    b.title='Etapas de produção';
    return b;
  }
  function ensureBtnForRow(tr){
    if(!tr) return;
    const ot=tr.getAttribute('data-ot'); if(!ot) return;
    const td=tr.querySelector('td:last-child'); if(!td) return;
    if(td.querySelector('[data-etapas]')) return; // já tem
    td.textContent=''; td.appendChild(makeEtapasBtn(ot));
  }

  // aplica nas linhas já renderizadas
  document.querySelectorAll('#jobsBody tr[data-ot]').forEach(ensureBtnForRow);

  // hooka inserções futuras (se sua insertJobRow já cria o botão, nada muda)
  if (typeof window.insertJobRow === 'function'){
    const _orig = window.insertJobRow;
    window.insertJobRow = function(d){
      _orig.call(this, d);
      const tr=document.querySelector(`tr[data-ot="${CSS.escape(d.ot)}"]`);
      ensureBtnForRow(tr);
    };
  }

  // delega clique do “+” para abrir o modal de etapas
  document.getElementById('jobsBody')?.addEventListener('click',(e)=>{
    const btn=e.target.closest('[data-etapas]'); if(!btn) return;
    e.preventDefault(); e.stopPropagation();
    const ot=btn.getAttribute('data-etapas');
    if(typeof window.openEtapasModal==='function') window.openEtapasModal(ot);
  });

  /* ============== 2) Cores por etapa dentro do modal de Etapas ============== */
  // Depois que sua função renderEtapas desenhar os cards, colocamos a classe k-<step>
  function colorizeEtapas(containerId){
    const box=document.getElementById(containerId); if(!box) return;
    box.querySelectorAll('.etapaCard').forEach(card=>{
      const btn=card.querySelector('[data-add-step]');
      if(btn){ const step=btn.getAttribute('data-add-step'); card.classList.add('k-'+step); }
    });
  }

  // Se existir renderEtapas, envolvemos pra aplicar as cores sem mexer no seu core
  if (typeof window.renderEtapas === 'function'){
    const _origRender = window.renderEtapas;
    window.renderEtapas = function(containerId, job){
      _origRender(containerId, job);
      colorizeEtapas(containerId);
    };
  } else {
    // caso o render seja chamado depois de definir, expõe um util
    window._colorizeEtapas = colorizeEtapas;
  }

  /* ============== 3) (Já feito por você) salvar evento => muda status e cor ============== */
  // Observação: seu handler de “Adicionar evento” já faz:
  // - push em job.logs[step]
  // - job.status = STEP_META[step].status
  // - updateRowStatus(ot, job.status)  => troca a classe da linha (cor)
  // Não alteramos nada disso aqui.

})();
</script>

<!-- PLUS na coluna ETAPAS + cores por etapa no modal FIM -->

<!-- // BOTÃO NOVO + LISTA "NOME DO TABLOIDE" (carrega/salva em nome_tabloide.csv) -->
<script>
(function(){
  /* ====== CONFIG GH ====== */
  const GH = {
    owner: 'JPVectorsitem',
    repo:  'LINKS-img',
    branch:'main',
    nomesPath: 'nome_tabloide.csv' // <<< nome correto do arquivo
  };

  /* ====== ELEMENTOS ====== */
  const btnNovo      = document.getElementById('btnNovo');
  const dlgNovo      = document.getElementById('modalNovo');
  const selNome      = document.getElementById('novoNomeSel');
  const inputNomeEsp = document.getElementById('novoNome'); // hidden espelho
  const btnNomeNovo  = document.getElementById('btnNomeNovo');

  const dlgNome      = document.getElementById('modalNomeTab');
  const inpNomeNovo  = document.getElementById('nomeTabTexto');
  const btnNomeSave  = document.getElementById('nomeTabSalvar');
  const btnNomeCancel= document.getElementById('nomeTabCancelar');

  /* ====== UX HELPERS (reusando seus padrões) ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if(!el){ alert(msg); return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if(msg) o.querySelector('.box').textContent = msg;
  }
  function getToken(){
    try{
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}');
      return (window.gh && window.gh.token) || saved.token || '';
    }catch{ return (window.gh && window.gh.token) || ''; }
  }

  /* ====== CSV & ENCODING (robusto p/ acentos) ====== */
  const csvEsc = v => {
    v = v == null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  function parseCsv(text){
    if(!text) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<text.length;i++){
      const c=text[i];
      if(q){
        if(c=='"'){ if(text[i+1]=='"'){cur+='"'; i++;} else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){ /* ignore */ }
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function b64ToSmartText(b64){
    // bytes
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);

    // tenta UTF-8
    let utf8 = new TextDecoder('utf-8', {fatal:false}).decode(bytes);
    const looksBad = /Ã.|�/.test(utf8);
    if(!looksBad) return utf8;

    // fallback latin1 (windows-1252)
    try {
      const lat = new TextDecoder('windows-1252', {fatal:false}).decode(bytes);
      // heurística simples: escolhe quem tem mais acentos legíveis e menos "Ã"
      const score = s => (s.match(/[çáéíóúâêôãõÇÁÉÍÓÚÂÊÔÃÕ]/g)||[]).length - (s.match(/Ã.|�/g)||[]).length;
      return score(lat) > score(utf8) ? lat : utf8;
    } catch {
      return utf8;
    }
  }

  /* ====== GitHub API helpers ====== */
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token) throw new Error('Token GitHub não configurado.');
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToSmartText(j.content) : '';
    return { text: content, sha: j.sha || null };
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  async function ghPutFile(path, newText, message){
    const token = getToken();
    if(!token) throw new Error('Token GitHub não configurado.');
    // obtém SHA atual (se existir)
    let sha = null;
    try {
      const cur = await ghGetFile(path, GH.branch);
      sha = cur.sha;
    } catch {}
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: message || `chore(csv): update ${path}`,
      content: utf8ToB64(newText),
      branch: GH.branch,
      ...(sha ? { sha } : {})
    };
    const r = await fetch(url, { method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body: JSON.stringify(body) });
    if(!r.ok){
      const t = await r.text();
      throw new Error('Falha ao salvar ('+r.status+'): '+t);
    }
    return true;
  }

  /* ====== NOMES: carregar + salvar ====== */
  function normalizeCmp(s){
    return String(s||'').trim().replace(/\s+/g,' ')
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g,''); // remove acentos p/ comparação
  }
  function parseNomes(text){
    if(!text.trim()) return { header:'nome', list:[] };
    // remove BOM se houver
    text = text.replace(/^\uFEFF/,'');
    const rows = parseCsv(text);
    if(!rows.length) return { header:'nome', list:[] };

    const H = rows[0].map(h=> String(h||'').trim());
    let idx = H.findIndex(h => h.toLowerCase() === 'nome');
    let start = 1;
    // Caso não tenha cabeçalho "nome", considera arquivo 1 coluna sem cabeçalho
    if(idx === -1){
      idx = 0;
      start = 0;
    }
    const list = [];
    for(let i=start;i<rows.length;i++){
      const rr = rows[i];
      if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const val = rr[idx] ?? '';
      const v = String(val||'').trim();
      if(!v) continue;
      list.push(v);
    }
    // dedup respeitando acentos na saída, mas ignorando na comparação
    const seen = new Set();
    const out = [];
    for(const n of list){
      const k = normalizeCmp(n);
      if(seen.has(k)) continue;
      seen.add(k);
      out.push(n);
    }
    return { header: (idx===-1?'nome':H[idx]||'nome'), list: out };
  }
  function buildNomesCsv(header, names){
    const H = [ header || 'nome' ];
    const lines = names.map(n => csvEsc(n));
    return H.join(',')+'\n'+ lines.join('\n') + (lines.length?'\n':'');
  }

  async function loadNomesIntoSelect(){
    if(!selNome) return;
    setBusy(true, 'Carregando nomes…');
    try{
      const { text } = await ghGetFile(GH.nomesPath, GH.branch);
      const { list } = parseNomes(text);
      // ordena pt-BR ignorando acentos/case
      list.sort((a,b)=> a.localeCompare(b,'pt-BR',{sensitivity:'base'}));
      // monta options (mantém "— selecione —")
      const cur = selNome.value || '';
      selNome.innerHTML = '<option value="">— selecione —</option>' +
        list.map(n => `<option>${n.replace(/</g,'&lt;')}</option>`).join('');
      // restaura seleção se ainda existir
      if(cur){
        const opt = [...selNome.options].find(o => normalizeCmp(o.value) === normalizeCmp(cur));
        if(opt) opt.selected = true;
      }
      // espelha no hidden
      if(inputNomeEsp) inputNomeEsp.value = selNome.value || '';
    }catch(e){
      console.error(e);
      toast('Não foi possível carregar a lista de nomes.');
    }finally{
      setBusy(false);
    }
  }

  async function saveNovoNome(){
    const nome = (inpNomeNovo?.value || '').trim().replace(/\s+/g,' ');
    if(!nome){ toast('Digite um nome.'); return; }
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    setBusy(true, 'Salvando nome…');
    try{
      const { text } = await ghGetFile(GH.nomesPath, GH.branch);
      const parsed = parseNomes(text);
      // dedup
      const exists = parsed.list.some(n => normalizeCmp(n) === normalizeCmp(nome));
      if(!exists) parsed.list.push(nome);

      // ordena antes de gravar (opcional, fica organizado)
      parsed.list.sort((a,b)=> a.localeCompare(b,'pt-BR',{sensitivity:'base'}));

      const nextCsv = buildNomesCsv(parsed.header, parsed.list);
      await ghPutFile(GH.nomesPath, nextCsv, `chore(csv): add nome_tabloide "${nome}"`);

      // atualiza select no modal principal e seleciona o novo
      await loadNomesIntoSelect();
      if(selNome){
        const opt = [...selNome.options].find(o => normalizeCmp(o.value) === normalizeCmp(nome));
        if(opt) opt.selected = true;
      }
      if(inputNomeEsp) inputNomeEsp.value = nome;

      // fecha modal e limpa campo
      if(dlgNome) dlgNome.close();
      if(inpNomeNovo) inpNomeNovo.value = '';
      toast('Nome adicionado.');
    }catch(e){
      console.error(e);
      toast('Falha ao salvar o nome.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== BINDS ====== */
  // Abre MODAL NOVO e carrega nomes do CSV
  if(btnNovo && dlgNovo){
    btnNovo.addEventListener('click', async ()=>{
      await loadNomesIntoSelect();
      dlgNovo.showModal();
    });
  }
  // Espelha select -> input hidden (se você usar #novoNome no backend)
  if(selNome && inputNomeEsp){
    selNome.addEventListener('change', ()=> inputNomeEsp.value = selNome.value || '');
  }

  // Sub-modal "Novo nome"
  if(btnNomeNovo && dlgNome){
    btnNomeNovo.addEventListener('click', ()=>{
      if(inpNomeNovo) inpNomeNovo.value = '';
      dlgNome.showModal();
    });
  }
  if(btnNomeCancel && dlgNome){
    btnNomeCancel.addEventListener('click', ()=> dlgNome.close());
  }
  if(btnNomeSave){
    btnNomeSave.addEventListener('click', saveNovoNome);
  }
})();
</script>
<!-- // BOTÃO NOVO + LISTA "NOME DO TABLOIDE" - FIM -->

<!-- // NOVO — CANCELAR (fecha modal e reseta campos) -->
<script>
(function(){
  const dlg   = document.getElementById('modalNovo');
  const form  = document.getElementById('formNovo');
  const btn   = document.getElementById('btnNovoCancelar');

  if (btn && dlg) {
    btn.addEventListener('click', () => {
      // reseta o form
      if (form) form.reset();

      // garante que "Ação nacional" volte para "Não" e botão fique desabilitado
      const acaoNao = document.getElementById('novoAcaoNao');
      const acaoNome = document.getElementById('novoAcaoNome');
      const btnAcao = document.getElementById('btnEscolherAcao');
      if (acaoNao) acaoNao.checked = true;
      if (acaoNome) acaoNome.value = '';
      if (btnAcao) btnAcao.disabled = true;

      // limpa UF
      const uf = document.getElementById('novoEstado');
      if (uf) {
        uf.innerHTML = '<option value="">— selecione —</option>';
      }

      // fecha modal
      dlg.close();
    });
  }
})();
</script>

<!-- // NOVO — CANCELAR (fecha modal e reseta campos) FIM -->

<!-- // UF POR REGIONAL — mapeia e preenche #novoEstado (e #editEstado) -->
<script>
(function(){
  // mapeamento informado
  const UF_MAP = {
    'REGIONAL BA - SE':         ['BA','SE'],
    'REGIONAL DF - GO - TO':    ['DF','GO','TO'],
    'REGIONAL MG':              ['MG'],
    'REGIONAL MS':              ['MS'],
    'REGIONAL MT - RO - AC':    ['MT','RO','AC'],
    'REGIONAL NORDESTE 1':      ['AL','PB','PE','RN'],
    'REGIONAL NORDESTE 2':      ['CE','PI','MA'],
    'REGIONAL NORTE':           ['AM','AP','PA','RR'],
    'REGIONAL PR':              ['PR'],
    'REGIONAL RJ - ES':         ['RJ','ES'],
    'REGIONAL RS':              ['RS'],
    'REGIONAL SP':              ['SP'],
    'REGIONAL SC':              ['SC']
  };

  // helpers
  function fillUfOptions(selectEl, ufs, keepValue){
    if (!selectEl) return;
    const prev = keepValue ?? selectEl.value;
    const opts = ['<option value="">— selecione —</option>']
      .concat((ufs||[]).map(uf => `<option value="${uf}">${uf}</option>`));
    selectEl.innerHTML = opts.join('');
    // restaura seleção se continuar válida
    if (prev && (ufs||[]).includes(prev)) {
      selectEl.value = prev;
    }
  }

  function bindRegionalToUf(regionalSelId, ufSelId){
    const reg = document.getElementById(regionalSelId);
    const uf  = document.getElementById(ufSelId);
    if (!reg || !uf) return;

    // inicializa vazio
    fillUfOptions(uf, []);

    // quando trocar regional, atualiza UF
    reg.addEventListener('change', () => {
      const label = (reg.value || '').trim();
      fillUfOptions(uf, UF_MAP[label] || []);
    });
  }

  // Novo
  bindRegionalToUf('novoRegional', 'novoEstado');

  // Editar (se for usar no modal de edição também)
  bindRegionalToUf('editRegional', 'editEstado');

  // ao abrir o modal "Novo", se já houver regional selecionado, aplica o filtro de UF
  const btnNovo  = document.getElementById('btnNovo');
  const dlgNovo  = document.getElementById('modalNovo');
  const regNovo  = document.getElementById('novoRegional');
  const ufNovo   = document.getElementById('novoEstado');

  if (btnNovo && dlgNovo && regNovo && ufNovo) {
    btnNovo.addEventListener('click', () => {
      const label = (regNovo.value || '').trim();
      fillUfOptions(ufNovo, UF_MAP[label] || [], ufNovo.value);
    });
  }
})();
</script>

<!-- // UF POR REGIONAL — mapeia e preenche #novoEstado (e #editEstado) FIM -->

<!-- // NOVO — SALVAR (grava em jobs.csv) + AÇÃO NACIONAL (selecionar/criar) -->
<script>
(function(){
  /* ====== CONFIG GH ====== */
  const GH = { owner:'JPVectorsitem', repo:'LINKS-img', branch:'main', jobsPath:'jobs.csv' };

  /* ====== ELEMENTOS (Novo) ====== */
  const dlgNovo     = document.getElementById('modalNovo');
  const formNovo    = document.getElementById('formNovo');
  const btnSalvar   = document.getElementById('btnNovoSalvar');

  const selRegional = document.getElementById('novoRegional');
  const selTipoLoja = document.getElementById('novoTipoLoja');
  const selTipoJob  = document.getElementById('novoTipoJob');
  const selNome     = document.getElementById('novoNomeSel');
  const inpNomeEsp  = document.getElementById('novoNome'); // hidden (espelho)
  const inpCompl    = document.getElementById('novoCompl');
  const selUF       = document.getElementById('novoEstado');
  const inpFilial   = document.getElementById('novoFilial');
  const inpIni      = document.getElementById('novoIni');
  const inpFim      = document.getElementById('novoFim');
  const selTam      = document.getElementById('novoTam');
  const inpQtd      = document.getElementById('novoQtd');
  const inpLink     = document.getElementById('novoLink');

  const rAcNao      = document.getElementById('novoAcaoNao');
  const rAcSim      = document.getElementById('novoAcaoSim');
  const inpAcaoNome = document.getElementById('novoAcaoNome');
  const btnAcao     = document.getElementById('btnEscolherAcao');

  /* ====== ELEMENTOS (Modal Ação nacional) ====== */
  const dlgAcao   = document.getElementById('modalAcao');
  const boxLista  = document.getElementById('acaoLista');
  const inpAcNova = document.getElementById('acaoNova');
  const btnAcCan  = document.getElementById('acaoCancelar');
  const btnAcOK   = document.getElementById('acaoOk');

  /* ====== UX helpers ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ====== CSV ====== */
  function parseCsv(text){
    if(!text) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<text.length;i++){
      const c=text[i];
      if(q){
        if(c=='"'){ if(text[i+1]=='"'){cur+='"'; i++;} else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){ }
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc = v => { v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, objs){
    const head = H.join(',')+'\n';
    const body = objs.map(o => H.map(k => csvEsc(o[k] ?? '')).join(',')).join('\n');
    return head + body + (objs.length?'\n':'');
  }

  /* ====== GitHub ====== */
  const GH_API_VER='2022-11-28';
  const ghHeaders = (tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)}); if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text = j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message: message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== Helpers ====== */
  function nowISO(){ return new Date().toISOString(); }
  function normalizeCmp(s){
    return String(s||'').trim().replace(/\s+/g,' ')
      .toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
  }
  function nextOT(rows){
    let max=0, maxLen=3;
    for(const r of rows){
      const m=String(r.ot||'').match(/(\d+)/);
      if(m){ const num=parseInt(m[1],10); if(!isNaN(num)) { max=Math.max(max,num); maxLen=Math.max(maxLen, m[1].length); } }
    }
    const n = (max+1).toString().padStart(Math.max(3,maxLen),'0');
    return `OT- ${n}`;
  }

  /* ====== AÇÃO NACIONAL: ligar/desligar, listar, escolher/criar ====== */
  function toggleAcaoUI(){
    const sim = rAcSim && rAcSim.checked;
    if(btnAcao) btnAcao.disabled = !sim;
    if(!sim && inpAcaoNome) inpAcaoNome.value = '';
  }
  if(rAcNao) rAcNao.addEventListener('change', toggleAcaoUI);
  if(rAcSim) rAcSim.addEventListener('change', toggleAcaoUI);
  toggleAcaoUI();

  async function loadAcoesLista(){
    boxLista.innerHTML = 'Carregando ações…';
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { rows } = csvToObjsAndHeader(text);
      const acoes = [];
      const seen = new Set();
      rows.forEach(r=>{
        const on = String(r.isNacional||'').trim().toLowerCase();
        const nome = (r.acaoNome||'').trim();
        if(['1','true','yes','sim'].includes(on) && nome){
          const k = normalizeCmp(nome);
          if(!seen.has(k)){ seen.add(k); acoes.push(nome); }
        }
      });
      acoes.sort((a,b)=> a.localeCompare(b,'pt-BR',{sensitivity:'base'}));

      if(!acoes.length){
        boxLista.innerHTML = '<div class="hint">Nenhuma ação existente. Crie uma no campo abaixo.</div>';
        return;
      }
      // desenha radios
      const frag = document.createDocumentFragment();
      acoes.forEach((nome,i)=>{
        const id='acao_'+i;
        const wrap=document.createElement('div');
        wrap.style.padding='6px 0';
        wrap.innerHTML = `<label style="display:flex;gap:8px;align-items:center;cursor:pointer">
            <input type="radio" name="acaoPick" value="${nome.replace(/"/g,'&quot;')}" id="${id}">
            <span>${nome.replace(/</g,'&lt;')}</span>
          </label>`;
        frag.appendChild(wrap);
      });
      boxLista.innerHTML = '';
      boxLista.appendChild(frag);
    }catch(e){
      console.error(e);
      boxLista.innerHTML = '<div class="hint">Erro ao carregar ações.</div>';
    }
  }

  if(btnAcao && dlgAcao){
    btnAcao.addEventListener('click', ()=>{ if(!rAcSim || !rAcSim.checked){ return; } inpAcNova.value=''; loadAcoesLista(); dlgAcao.showModal(); });
  }
  if(btnAcCan && dlgAcao){ btnAcCan.addEventListener('click', ()=> dlgAcao.close()); }
  if(btnAcOK && dlgAcao){
    btnAcOK.addEventListener('click', ()=>{
      const radios = dlgAcao.querySelectorAll('input[name="acaoPick"]');
      let picked = '';
      radios.forEach(r=>{ if(r.checked) picked = r.value; });
      const novo = (inpAcNova.value||'').trim().replace(/\s+/g,' ');
      const final = novo || picked;
      if(!final){ toast('Selecione uma ação ou digite uma nova.'); return; }
      inpAcaoNome.value = final;
      dlgAcao.close();
    });
  }

  /* ====== VALIDAR CAMPOS ====== */
  function getNomeTabloide(){
    const fromSel = (selNome && selNome.value) ? selNome.value.trim() : '';
    const fromHidden = (inpNomeEsp && inpNomeEsp.value) ? inpNomeEsp.value.trim() : '';
    return fromSel || fromHidden || '';
  }
  function validate(){
    const errs = [];
    if(!getToken()) errs.push('Configurar GitHub primeiro (⚙).');
    if(!selRegional || !selRegional.value) errs.push('Selecione a Regional.');
    if(!selTipoLoja || !selTipoLoja.value) errs.push('Selecione o Tipo da loja.');
    if(!selTipoJob  || !selTipoJob.value)  errs.push('Selecione o Tipo do JOB.');
    if(!getNomeTabloide()) errs.push('Defina o Nome do tabloide.');
    if(!selUF || !selUF.value) errs.push('Selecione a UF.');
    if(!inpIni || !inpIni.value) errs.push('Defina a Validade início.');
    if(!inpFim || !inpFim.value) errs.push('Defina a Validade término.');
    if(!selTam || !selTam.value) errs.push('Selecione o Tamanho da página.');
    if(!inpQtd || !inpQtd.value) errs.push('Informe a Quantidade de páginas.');

    const isNac = rAcSim && rAcSim.checked;
    if(isNac && (!inpAcaoNome || !inpAcaoNome.value.trim())){
      errs.push('Defina o nome da Ação nacional.');
    }
    return errs;
  }

  /* ====== SALVAR ====== */
  async function salvarNovo(){
    const errs = validate();
    if(errs.length){ toast(errs[0]); return; }

    setBusy(true,'Salvando job…');
    try{
      // lê jobs atuais
      const read = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed = csvToObjsAndHeader(read.text);
      const rows = parsed.rows || [];
      const Hcur = parsed.header || [];

      // gera OT
      const ot = nextOT(rows);

      // dados
      const isNac = rAcSim && rAcSim.checked;
      const acao  = isNac ? (inpAcaoNome.value||'').trim() : '';

      const novo = {
        ot,
        regional:   selRegional.value || '',
        tipoLoja:   selTipoLoja.value || '',
        tipoJob:    selTipoJob.value || '',
        nome:       getNomeTabloide(),
        compl:      inpCompl.value || '',
        uf:         selUF.value || '',
        filial:     (inpFilial.value||'').trim(),
        ini:        inpIni.value || '',
        fim:        inpFim.value || '',
        tam:        selTam.value || '',
        qtd:        inpQtd.value || '',
        isNacional: isNac ? 'sim' : '',
        acaoNome:   acao,
        status:     'Novo',
        statusStep: 'novo',
        logs:       '{}',
        link:       (inpLink && inpLink.value) ? inpLink.value.trim() : '',
        criado_em:  nowISO(),
        atualizado_em: nowISO()
      };

      // header desejado (garante colunas importantes)
      const DESIRED = ['ot','regional','tipoLoja','tipoJob','nome','compl','uf','filial','ini','fim','tam','qtd','isNacional','acaoNome','status','statusStep','logs','link','criado_em','atualizado_em'];
      const H = Hcur.slice();
      DESIRED.forEach(k=>{ if(!H.includes(k)) H.push(k); });

      // monta lista final (append)
      const all = rows.concat([novo]);

      // grava
      const nextCsv = toCsv(H, all);
      await ghPutFile(GH.jobsPath, nextCsv, `chore(csv): add job ${ot}`);

      // feedback + atualizar UI
      toast('Job salvo.');
      if(formNovo) formNovo.reset();
      if(inpAcaoNome) inpAcaoNome.value = '';
      toggleAcaoUI();
      if(dlgNovo) dlgNovo.close();

      if (typeof window.loadJobsFromGitHub === 'function'){
        setBusy(true,'Atualizando lista…');
        await window.loadJobsFromGitHub();
      }
    }catch(e){
      console.error(e);
      toast('Falha ao salvar job.');
    }finally{
      setBusy(false);
    }
  }

  if(btnSalvar) btnSalvar.addEventListener('click', salvarNovo);
})();
</script>

<!-- // NOVO — SALVAR (grava em jobs.csv) + AÇÃO NACIONAL (selecionar/criar) FIM -->

<!-- // FIX: garantir botão "+" na coluna ETAPAS PRODUÇÃO para todas as linhas -->
<script>
(function(){
  const tbody = document.getElementById('jobsBody');

  function makeEtapasBtn(ot){
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'btn small etapasBtn';
    b.textContent = '+';
    b.title = 'Etapas de produção';
    b.setAttribute('data-etapas', ot);
    return b;
  }

  function ensureBtnForRow(tr){
    if (!tr || !tr.hasAttribute('data-ot')) return;
    if (tr.classList.contains('sep-row') || tr.classList.contains('sub-row')) return;

    const td = tr.querySelector('td:last-child');
    if (!td) return;
    // já tem botão?
    if (td.querySelector('[data-etapas]')) return;

    const ot = tr.getAttribute('data-ot') || '';
    td.textContent = '';
    td.appendChild(makeEtapasBtn(ot));
  }

  function ensureAll(){
    if (!tbody) return;
    tbody.querySelectorAll('tr[data-ot]').forEach(ensureBtnForRow);
  }

  // 1) passa nas linhas já existentes
  ensureAll();

  // 2) observa novas linhas adicionadas (ex.: recarregar jobs.csv, TurboJobs, salvar novo)
  if (tbody){
    const mo = new MutationObserver((muts)=>{
      muts.forEach(m=>{
        m.addedNodes.forEach(n=>{
          if (n.nodeType === 1 && n.matches('tr[data-ot]')) ensureBtnForRow(n);
        });
      });
    });
    mo.observe(tbody, { childList: true });
  }

  // 3) wrapper pós-carregamento: se existir loadJobsFromGitHub, reforça
  if (typeof window.loadJobsFromGitHub === 'function'){
    const _origLoad = window.loadJobsFromGitHub;
    window.loadJobsFromGitHub = async function(){
      const r = await _origLoad.apply(this, arguments);
      // dá um microtempo pra linhas entrarem e garante os botões
      setTimeout(ensureAll, 0);
      return r;
    };
  }

  // 4) se existir insertJobRow (fallback antigo), reforça também
  if (typeof window.insertJobRow === 'function'){
    const _origInsert = window.insertJobRow;
    window.insertJobRow = function(d){
      _origInsert.call(this, d);
      const tr = tbody && d && d.ot ? tbody.querySelector(`tr[data-ot="${CSS.escape(d.ot)}"]`) : null;
      ensureBtnForRow(tr);
    };
  }

  // 5) clique delegado do "+"
  if (tbody){
    tbody.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-etapas]');
      if (!btn) return;
      const ot = btn.getAttribute('data-etapas');
      if (typeof window.openEtapasModal === 'function'){
        window.openEtapasModal(ot);
      }
    });
  }
})();
</script>
<!-- // FIX: garantir botão "+" na coluna ETAPAS PRODUÇÃO para todas as linhas FIM -->

<!-- ============ ETAPAS (botão "+"): abrir modal, registrar evento e SALVAR no jobs.csv ============ -->
<script>
(function(){
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:     'JPVectorsitem',
    repo:      'LINKS-img',
    branch:    'main',
    jobsPath:  'jobs.csv',
    usersPath: 'users.csv'
  };

  /* ====== ELEMENTOS (modais já existentes no seu HTML) ====== */
  const dlgEtapas        = document.getElementById('modalEtapas');
  const etapasTitleOT    = document.getElementById('etapasTitleOT');
  const etapasHead       = document.getElementById('etapasHead');
  const etapasList       = document.getElementById('etapasList');
  const btnEtapasFechar  = document.getElementById('btnEtapasFechar');

  const dlgAdd           = document.getElementById('modalAddEvt');
  const addTitle         = document.getElementById('addEvtTitle');
  const addFields        = document.getElementById('addEvtFields');
  const btnAddCancelar   = document.getElementById('btnAddEvtCancelar');
  const btnAddOK         = document.getElementById('btnAddEvtOk');

  /* ====== HELPERS UX ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  function nowISO(){ return new Date().toISOString(); }
  function fmtTS(ts){ const d=new Date(ts); return isNaN(+d)? ts : d.toLocaleString('pt-BR'); }
  const eqi=(a,b)=> String(a||'').trim().toLowerCase()===String(b||'').trim().toLowerCase();
  const normalize = s => String(s||'').trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');

  /* ====== CSV & GITHUB ====== */
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){cur+='"'; i++;} else q=false; } else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }

  const GH_API_VER='2022-11-28';
  const ghHeaders = (tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== MAPA DE ETAPAS ====== */
  const STEP_META = {
    lista:        { label:'Lista',        status:'Lista recebida', input:'text' },
    layout:       { label:'Layout',       status:'Criando layout', input:'role', roles:['Layout'] },
    digitacao:    { label:'Digitação',    status:'Digitando',      input:'role', roles:['Digitador'] },
    diagramacao:  { label:'Diagramação',  status:'Diagramando',    input:'role', roles:['Diagramador'] },
    revisao:      { label:'Revisão',      status:'Revisando',      input:'role', roles:['Revisor'] },
    aprovacao:    { label:'Aprovação',    status:'Aprovado',       input:'text' },
    encerramento: { label:'Encerramento', status:'Encerrando',     input:'role', roles:['Encerramento'] },
    site:         { label:'Site',         status:'Site',           input:'role', roles:['Site'] },
    cancelado:    { label:'Cancelado',    status:'Cancelado',      input:'text' }
  };
  const STEP_ORDER = ['lista','layout','digitacao','diagramacao','revisao','aprovacao','encerramento','site','cancelado'];

  /* ====== ESTADO LOCAL ====== */
  let curOT   = null;
  let curJob  = null;
  let curStep = null;

  /* ====== STATUS -> CLASSE DE LINHA ====== */
  function statusToClass(status){
    const s=normalize(status);
    if(s==='novo') return 'st-novo';
    if(s==='lista recebida') return 'st-lista';
    if(s==='criando layout') return 'st-layout';
    if(s==='digitando') return 'st-digitando';
    if(s==='diagramando') return 'st-diagramando';
    if(s==='revisando') return 'st-revisando';
    if(s==='aprovado') return 'st-aprovado';
    if(s==='encerrando') return 'st-encerrando';
    if(s==='site') return 'st-site';
    if(s==='cancelado') return 'st-cancelado';
    if(s==='finalizado') return 'st-finalizado';
    return '';
  }
  function updateRowStatus(ot, statusText){
    const tr = document.querySelector(`#jobsBody tr[data-ot="${CSS.escape(ot)}"]`);
    if(!tr) return;
    tr.className = tr.className.replace(/\bst-\w+\b/g,'').trim();
    const cls = statusToClass(statusText);
    if(cls) tr.classList.add(cls);
    const tdStatus = tr.children && tr.children[12]; // 13ª coluna é STATUS
    if(tdStatus) tdStatus.textContent = statusText || '—';
  }

  /* ====== LOGS ====== */
  function parseLogs(raw){
    try{
      const j = JSON.parse(raw||'{}');
      Object.keys(STEP_META).forEach(k=>{ if(!Array.isArray(j[k])) j[k]=[]; });
      return j;
    }catch{
      const e={}; Object.keys(STEP_META).forEach(k=> e[k]=[]);
      return e;
    }
  }

  /* ====== GARANTE COLUNAS NO HEADER ====== */
  function ensureHeaderColumns(H, rows, needed){
    const head = H.slice();
    const have = new Set(head.map(h=>String(h)));
    let changed=false;
    needed.forEach(col=>{
      if(!have.has(col)){ head.push(col); changed=true; }
    });
    if(changed){
      rows.forEach(r=>{
        needed.forEach(col=>{ if(r[col]===undefined) r[col]=''; });
      });
    }
    return { head, rows };
  }

  /* ====== USERS POR CARGO ====== */
  async function loadUsersByRoles(roles){
    const normRoles = (roles||[]).map(normalize);
    try{
      const { text } = await ghGetFile(GH.usersPath, GH.branch);
      const { rows } = csvToObjsAndHeader(text);
      const names=new Set();
      rows.forEach(u=>{
        const p=normalize(u.cargo_principal || u.cargo || '');
        const s=normalize(u.cargo_secundaria || '');
        if(normRoles.includes(p) || normRoles.includes(s)){
          const nome=(u.nome||'').trim();
          if(nome) names.add(nome);
        }
      });
      return [...names].sort((a,b)=> a.localeCompare(b,'pt-BR'));
    }catch(e){
      console.error(e);
      return [];
    }
  }

  /* ====== RENDER DO MODAL DE ETAPAS ====== */
  function renderEtapas(containerId, job){
    const box=document.getElementById(containerId);
    if(!box) return;
    box.innerHTML='';

    const logs=parseLogs(job.logs);

    STEP_ORDER.forEach(step=>{
      const meta=STEP_META[step];
      const card=document.createElement('div');
      card.className='etapaCard k-'+step;
      card.innerHTML=`
        <div class="etapaHead">
          <div>${meta.label}</div>
          <div><button class="btn small" type="button" data-add-step="${step}">Adicionar</button></div>
        </div>
        <div class="etapaLogs" data-step="${step}">
          ${
            (logs[step] && logs[step].length)
            ? logs[step].map(ev=>`
                <div class="ev">
                  <span>${(ev.nome||'—').replace(/</g,'&lt;')}</span>
                  <span class="muted">${fmtTS(ev.ts||'')}</span>
                </div>`).join('')
            : '<div class="muted">Sem eventos.</div>'
          }
        </div>
      `;
      box.appendChild(card);
    });

    // Se você tiver um colorizer global, aplica:
    if (typeof window._colorizeEtapas === 'function'){
      window._colorizeEtapas(containerId);
    }
  }

  /* ====== ABRIR MODAL ETAPAS (exposto para o click do "+") ====== */
  async function openEtapasModal(ot){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    setBusy(true,'Carregando etapas…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      const job = parsed.rows.find(r => eqi(r.ot, ot));
      if(!job){ toast('Job não encontrado.'); return; }
      curOT=ot;
      curJob=job;

      if (etapasTitleOT) etapasTitleOT.textContent = ot || '';
      if (etapasHead){
        etapasHead.innerHTML = `
          <div><strong>${(job.nome||'—').replace(/</g,'&lt;')}</strong></div>
          <div class="muted">Regional: ${job.regional||'—'} • UF: ${job.uf||'—'} • Status: ${job.status||'—'}</div>
        `;
      }

      renderEtapas('etapasList', job);
      dlgEtapas && dlgEtapas.showModal();
    }catch(e){
      console.error(e);
      toast('Erro ao abrir etapas.');
    }finally{
      setBusy(false);
    }
  }
  window.openEtapasModal = openEtapasModal;

  if (btnEtapasFechar && dlgEtapas){
    btnEtapasFechar.addEventListener('click', ()=> dlgEtapas.close());
  }

  /* ====== CLIQUE EM "ADICIONAR" EM CADA CARD ====== */
  if (etapasList){
    etapasList.addEventListener('click', async (e)=>{
      const btn=e.target.closest('[data-add-step]');
      if(!btn) return;
      const step=btn.getAttribute('data-add-step');
      if(!STEP_META[step]) return;
      curStep=step;
      const meta=STEP_META[step];

      addTitle && (addTitle.textContent = `Adicionar evento — ${meta.label} (${curOT||''})`);

      if(meta.input==='text'){
        addFields.innerHTML = `
          <div class="field">
            <label>Responsável</label>
            <input id="addNomeTxt" type="text" placeholder="Seu nome" />
          </div>
          <div class="muted">A data e a hora serão registradas automaticamente ao salvar.</div>
        `;
      }else{
        addFields.innerHTML = `
          <div class="field">
            <label>Responsável</label>
            <select id="addNomeSel"><option value="">(carregando…)</option></select>
          </div>
          <div class="muted">A data e a hora serão registradas automaticamente ao salvar.</div>
        `;
        const sel = addFields.querySelector('#addNomeSel');
        const nomes = await loadUsersByRoles(meta.roles||[]);
        sel.innerHTML = `<option value="">— selecione —</option>` + nomes.map(n=>`<option>${n.replace(/</g,'&lt;')}</option>`).join('');
      }

      dlgAdd && dlgAdd.showModal();
    });
  }

  if (btnAddCancelar && dlgAdd){
    btnAddCancelar.addEventListener('click', ()=> dlgAdd.close());
  }

  /* ====== SALVAR EVENTO (GRAVA jobs.csv) ====== */
  async function saveEvent(){
    if(!curOT || !curJob || !curStep || !STEP_META[curStep]){ toast('Seleção inválida.'); return; }
    const meta=STEP_META[curStep];

    let nome='';
    if(meta.input==='text'){
      nome = (document.getElementById('addNomeTxt')?.value || '').trim();
      if(!nome){ toast('Informe o nome do responsável.'); return; }
    }else{
      nome = (document.getElementById('addNomeSel')?.value || '').trim();
      if(!nome){ toast('Selecione o responsável.'); return; }
    }

    setBusy(true,'Gravando evento…');
    const ts = nowISO();

    try{
      // 1) lê jobs.csv
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      let H   = parsed.header || [];
      let rows= parsed.rows   || [];

      // 2) garante colunas: logs/statusStep/atualizado_em/status
      const ensured = ensureHeaderColumns(H, rows, ['logs','statusStep','atualizado_em','status']);
      H    = ensured.head;
      rows = ensured.rows;

      // 3) localiza job
      const idx = rows.findIndex(r => eqi(r.ot, curOT));
      if(idx===-1){ toast('Job não encontrado.'); setBusy(false); return; }

      // 4) atualiza logs + status
      const job=rows[idx];
      let logsObj;
      try{ logsObj = job.logs ? JSON.parse(job.logs) : {}; }catch{ logsObj = {}; }
      Object.keys(STEP_META).forEach(k=>{ if(!Array.isArray(logsObj[k])) logsObj[k]=[]; });

      logsObj[curStep].push({ nome, ts });

      job.logs          = JSON.stringify(logsObj);
      job.status        = meta.status;
      job.statusStep    = curStep;
      job.atualizado_em = ts;

      rows[idx]=job;

      // 5) escreve CSV
      const csv = toCsv(H, rows);
      await ghPutFile(GH.jobsPath, csv, `chore(csv): add ${meta.label} (${curOT})`);

      // 6) atualiza UI
      updateRowStatus(curOT, meta.status);

      const listEl = etapasList.querySelector(`.etapaLogs[data-step="${curStep}"]`);
      if(listEl){
        const ev=document.createElement('div');
        ev.className='ev';
        ev.innerHTML = `<span>${nome.replace(/</g,'&lt;')}</span><span class="muted">${fmtTS(ts)}</span>`;
        const empty=listEl.querySelector('.muted');
        if(empty) empty.remove();
        listEl.appendChild(ev);
      }

      dlgAdd && dlgAdd.close();
      toast('Evento registrado e salvo no jobs.csv.');
    }catch(e){
      console.error(e);
      toast('Erro ao salvar no jobs.csv.');
    }finally{
      setBusy(false);
    }
  }
  if (btnAddOK){
    btnAddOK.addEventListener('click', saveEvent);
  }

  /* ====== (Opcional) Delegado de clique do "+" caso não tenha sido adicionado antes ====== */
  (function ensurePlusClickBindingOnce(){
    const tbody = document.getElementById('jobsBody');
    if(!tbody) return;
    if(tbody._etapasPlusBound) return;
    tbody._etapasPlusBound = true;
    tbody.addEventListener('click',(e)=>{
      const btn=e.target.closest('[data-etapas]');
      if(!btn) return;
      const ot=btn.getAttribute('data-etapas');
      if(ot) openEtapasModal(ot);
    });
  })();

})();
</script>

<!-- ============ ETAPAS (botão "+"): abrir modal, registrar evento e SALVAR no jobs.csv ============ FIM -->

<!-- ============ BOTÃO EXCLUIR: remove o job selecionado do jobs.csv e da tabela ============ -->
<script>
(function(){
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnExcluir = document.getElementById('btnExcluir');
  const tbody      = document.getElementById('jobsBody');

  /* ====== HELPERS UX ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  const eqi=(a,b)=> String(a||'').trim().toLowerCase()===String(b||'').trim().toLowerCase();

  /* ====== CSV ====== */
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){cur+='"'; i++;} else q=false; } else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }

  /* ====== GitHub ====== */
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== Limpador de sub-ação em “ESPECIAL NACIONAL” quando fica vazia ====== */
  function cleanupActionIfEmpty(actionName){
    if(!actionName) return;
    const esc = (window.CSS && CSS.escape) ? CSS.escape : (s)=> String(s).replace(/"/g,'\\"');
    const stillExists = tbody && tbody.querySelector(`tr[data-sub="${esc(actionName)}"][data-ot]`);
    if(!stillExists){
      const sub = tbody && tbody.querySelector(`tr.sub-row[data-sub="${esc(actionName)}"]`);
      if(sub) sub.remove();
    }
  }
  // expõe pra outros trechos que já referenciam
  window.cleanupActionIfEmpty = window.cleanupActionIfEmpty || cleanupActionIfEmpty;

  /* ====== Ação do botão EXCLUIR ====== */
  async function handleExcluir(){
    // selecionado (usa helper já existente no seu código)
    const ot = (typeof window.getSelectedOT === 'function' ? window.getSelectedOT() : (window.selectedOT || null));
    if(!ot){ toast('Selecione um job para excluir.'); return; }
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    // pega info da UI pra confirmar
    const tr = tbody && tbody.querySelector(`tr[data-ot="${CSS.escape(ot)}"]`);
    const nome = tr ? (tr.children[4]?.textContent || '').trim() : '';
    const regional = tr ? (tr.children[1]?.textContent || '').trim() : '';
    const msg = `Excluir o job?\n\nOT: ${ot}\nNome: ${nome || '—'}\nRegional: ${regional || '—'}\n\nEsta ação não pode ser desfeita.`;
    if(!confirm(msg)) return;

    setBusy(true,'Excluindo job…');
    try{
      // 1) lê jobs.csv
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { header:H, rows } = csvToObjsAndHeader(text);

      // 2) encontra & remove
      const exists = rows.some(r => eqi(r.ot, ot));
      if(!exists){ toast('Job não encontrado no arquivo.'); setBusy(false); return; }

      const remain = rows.filter(r => !eqi(r.ot, ot));
      const newCsv = toCsv(H, remain);
      await ghPutFile(GH.jobsPath, newCsv, `chore(csv): delete job ${ot}`);

      // 3) atualiza UI: remove linha + limpa sub-ação se precisar
      if(tr){
        const sub = tr.getAttribute('data-sub') || null;
        tr.remove();
        if(sub) cleanupActionIfEmpty(sub);
      }
      if (window.JOBS instanceof Map) window.JOBS.delete(ot);
      if (typeof window.clearJobSelection === 'function') window.clearJobSelection();

      toast(`Job ${ot} excluído.`);
    }catch(e){
      console.error(e);
      toast('Erro ao excluir. Tente novamente.');
    }finally{
      setBusy(false);
    }
  }

  if (btnExcluir){
    btnExcluir.addEventListener('click', handleExcluir);
  }
})();
</script>
<//!-- ============ BOTÃO EXCLUIR: remove o job selecionado do jobs.csv e da tabela ============ FIM -->

<//!-- ============ BOTÃO ENCERRAR ============ -->

<script>
(function(){
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv',
    nomesPath:'nome_tabloide.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnEncerrar  = document.getElementById('btnEncerrar');
  const dlg          = document.getElementById('modalEncerrar');

  const selStatus    = document.getElementById('encStatus');      // "Aprovado" (desabilitado)
  const selNome      = document.getElementById('encNomeSel');     // SELECT de nomes (novo)
  const inpLink      = document.getElementById('encLinkFiltro');  // contém no link (opcional)

  const btnFiltrar   = document.getElementById('encFiltrar');
  const btnSelTodos  = document.getElementById('encSelTodos');
  const btnExecutar  = document.getElementById('encExecutar');
  const btnCancelar  = document.getElementById('encCancelar');
  const listBody     = document.getElementById('encList');
  const jobsBody     = document.getElementById('jobsBody'); // tabela principal

  /* ====== HELPERS UX ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  const eqi=(a,b)=> String(a||'').trim().toLowerCase()===String(b||'').trim().toLowerCase();
  const escHtml = (s)=> String(s||'').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));

  /* ====== CSV ====== */
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){cur+='"'; i++;} else q=false; } else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }

  /* ====== GitHub ====== */
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== STATUS UI ====== */
  function statusToClass(status){
    const s=String(status||'').trim().toLowerCase();
    if(s==='novo') return 'st-novo';
    if(s==='lista recebida') return 'st-lista';
    if(s==='criando layout') return 'st-layout';
    if(s==='digitando') return 'st-digitando';
    if(s==='diagramando') return 'st-diagramando';
    if(s==='revisando') return 'st-revisando';
    if(s==='aprovado') return 'st-aprovado';
    if(s==='encerrando') return 'st-encerrando';
    if(s==='site') return 'st-site';
    if(s==='cancelado') return 'st-cancelado';
    if(s==='finalizado') return 'st-finalizado';
    return '';
  }
  function updateMainRowStatus(ot, statusText){
    const tr = jobsBody && jobsBody.querySelector(`tr[data-ot="${CSS.escape(ot)}"]`);
    if(!tr) return;
    tr.className = tr.className.replace(/\bst-\w+\b/g,'').trim();
    const cls = statusToClass(statusText);
    if(cls) tr.classList.add(cls);
    const tdStatus = tr.children && tr.children[12];
    if(tdStatus) tdStatus.textContent = statusText || '—';
  }

  /* ====== ESTADO ====== */
  let _csvHead = [];
  let _rowsAll = [];
  let _allRows = [];      // só os aprovados (para render)
  let _nomeTabCache = null;

  /* ====== NOMES DO TABLOIDE (popular SELECT) ====== */
  async function loadNomeTabOptions(){
    if(!selNome) return;
    if(_nomeTabCache){ fillNomeSelect(_nomeTabCache); return; }
    try{
      const { text } = await ghGetFile(GH.nomesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      const col = header.find(h => eqi(h,'nome')) || header[0] || 'nome';
      const names = [...new Set(rows.map(r => (r[col]||'').trim()).filter(Boolean))]
        .sort((a,b)=> a.localeCompare(b,'pt-BR'));
      _nomeTabCache = names;
      fillNomeSelect(names);
    }catch(e){
      console.error('Falha ao carregar nome_tabloide.csv', e);
      selNome.innerHTML = `<option>(todos)</option>`;
    }
  }
  function fillNomeSelect(names){
    const cur = selNome.value || '(todos)';
    const opts = ['(todos)', ...names];
    selNome.innerHTML = opts.map(o => `<option${o===cur?' selected':''}>${escHtml(o)}</option>`).join('');
  }

  /* ====== RENDER LISTA ====== */
  function renderList(rows){
    if(!rows.length){
      listBody.innerHTML = `<tr><td colspan="14" class="hint">Nenhum job “Aprovado” com esses filtros.</td></tr>`;
      return;
    }
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      const id='enc_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
      tr.innerHTML = `
        <td><input type="checkbox" data-ot="${escHtml(r.ot||'')}" id="${id}"></td>
        <td>${escHtml(r.ot||'—')}</td>
        <td>${escHtml(r.regional||'—')}</td>
        <td>${escHtml(r.tipoLoja||'—')}</td>
        <td>${escHtml(r.tipoJob||'—')}</td>
        <td>${escHtml(r.nome||'—')}</td>
        <td>${escHtml(r.compl||'—')}</td>
        <td>${escHtml(r.uf||'—')}</td>
        <td><span class="clip" data-full="${escHtml((r.filial||'').trim() || '—')}">…</span></td>
        <td>${escHtml(r.ini||'—')}</td>
        <td>${escHtml(r.fim||'—')}</td>
        <td>${escHtml(r.tam||'—')}</td>
        <td>${escHtml(r.qtd||'—')}</td>
        <td>${escHtml(r.status||'—')}</td>
      `;
      frag.appendChild(tr);
    });
    listBody.innerHTML=''; listBody.appendChild(frag);
  }

  function applyFilters(){
    const nameSel = (selNome?.value || '(todos)').trim();
    const qLink   = (inpLink?.value || '').trim().toLowerCase();

    const out = _allRows.filter(r=>{
      const okNome = nameSel === '(todos)' ? true : eqi(r.nome, nameSel);
      const linkVal = (r.link || r.linkMae || '');
      const okLink = !qLink || String(linkVal).toLowerCase().includes(qLink);
      return okNome && okLink;
    });
    renderList(out);
  }

  /* ====== ABRIR MODAL ====== */
  async function openEncerrar(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    setBusy(true,'Carregando aprovados…');
    try{
      await loadNomeTabOptions();

      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed   = csvToObjsAndHeader(text);
      _csvHead       = parsed.header || [];
      _rowsAll       = parsed.rows   || [];

      // só “Aprovado” para a lista
      _allRows = _rowsAll
        .filter(r => String(r.status||'').trim().toLowerCase() === 'aprovado')
        .map(r => (Object.assign({}, r, { regional: r.regional||r.regionalGrupo||'' })))
        .sort((a,b)=> (a.ot||'').localeCompare(b.ot||'', undefined, {numeric:true, sensitivity:'base'}));

      applyFilters();
      dlg && dlg.showModal();
    }catch(e){
      console.error(e);
      listBody.innerHTML = `<tr><td colspan="14" class="hint">Erro ao carregar jobs.</td></tr>`;
      dlg && dlg.showModal();
      toast('Falha ao carregar.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== EXECUTAR ENCERRAR (sem alterações) ====== */
  async function doEncerrar(){
    const sel = [...listBody.querySelectorAll('input[type="checkbox"][data-ot]:checked')].map(b=> b.getAttribute('data-ot'));
    if(!sel.length){ toast('Selecione ao menos 1 job.'); return; }
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    const resp = (window.currentUser && window.currentUser.nome) ? String(window.currentUser.nome) : '—';
    setBusy(true,'Atualizando status…');
    const ts = new Date().toISOString();

    try{
      const mapSel = new Set(sel);
      for(let i=0;i<_rowsAll.length;i++){
        const r=_rowsAll[i];
        if(mapSel.has(String(r.ot))){
          let logsObj;
          try{ logsObj = r.logs ? JSON.parse(r.logs) : {}; }catch{ logsObj = {}; }
          if(!Array.isArray(logsObj.encerramento)) logsObj.encerramento = [];
          logsObj.encerramento.push({ nome: resp, ts });

          r.logs          = JSON.stringify(logsObj);
          r.status        = 'Encerrando';
          r.statusStep    = 'encerramento';
          r.atualizado_em = ts;
          _rowsAll[i]     = r;
        }
      }
      const csv = toCsv(_csvHead, _rowsAll);
      await ghPutFile(GH.jobsPath, csv, `chore(csv): encerrar ${sel.length} job(s)`);

      sel.forEach(ot=>{
        updateMainRowStatus(ot, 'Encerrando');
        const row = listBody.querySelector(`input[type="checkbox"][data-ot="${CSS.escape(ot)}"]`)?.closest('tr');
        if(row) row.remove();
      });

      if(!listBody.querySelector('tr')) {
        listBody.innerHTML = `<tr><td colspan="14" class="hint">Nenhum job “Aprovado”.</td></tr>`;
      }

      toast(`${sel.length} job(s) movidos para Encerrando.`);
      dlg && dlg.close();
    }catch(e){
      console.error(e);
      toast('Erro ao encerrar. Tente novamente.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== Binds ====== */
  if(btnEncerrar) btnEncerrar.addEventListener('click', openEncerrar);
  if(btnFiltrar)  btnFiltrar.addEventListener('click', applyFilters);
  if(btnSelTodos) btnSelTodos.addEventListener('click', ()=> listBody.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));
  if(btnExecutar) btnExecutar.addEventListener('click', doEncerrar);
  if(btnCancelar) btnCancelar.addEventListener('click', ()=> dlg && dlg.close());
})();
</script>

<//!-- ============ BOTÃO ENCERRAR ============ FIM -->

<!-- ============ BOTÃO EDITAR — configuração completa (com Nome como SELECT + “…” em Filial) ============ -->
<script>
(function(){
  /* ====== CONFIG ====== */
  const GH = {
    owner:     'JPVectorsitem',
    repo:      'LINKS-img',
    branch:    'main',
    jobsPath:  'jobs.csv',
    namesPath: 'nome_tabloide.csv'
  };

  /* ====== MAPEAMENTO UF por REGIONAL ====== */
  const UF_MAP = {
    'REGIONAL BA - SE':        ['BA','SE'],
    'REGIONAL DF - GO - TO':   ['DF','GO','TO'],
    'REGIONAL MG':             ['MG'],
    'REGIONAL MS':             ['MS'],
    'REGIONAL MT - RO - AC':   ['MT','RO','AC'],
    'REGIONAL NORDESTE 1':     ['AL','PB','PE','RN'],
    'REGIONAL NORDESTE 2':     ['CE','PI','MA'],
    'REGIONAL NORTE':          ['AM','AP','PA','RR'],
    'REGIONAL PR':             ['PR'],
    'REGIONAL RJ - ES':        ['RJ','ES'],
    'REGIONAL RS':             ['RS'],
    'REGIONAL SP':             ['SP'],
    'REGIONAL SC':             ['SC']
  };

  const REGIONAIS = Object.keys(UF_MAP);

  /* ====== ELEMENTOS ====== */
  const btnEditar    = document.getElementById('btnEditar');
  const dlg          = document.getElementById('modalEdit');
  const form         = document.getElementById('formEdit');

  const lblOT        = document.getElementById('editOT');
  const selRegional  = document.getElementById('editRegional');
  const selTipoLoja  = document.getElementById('editTipoLoja');
  const selTipoJob   = document.getElementById('editTipoJob');
  const inpNome      = document.getElementById('editNome');     // será trocado por <select>
  const inpCompl     = document.getElementById('editCompl');
  const selUF        = document.getElementById('editEstado');
  const inpFilial    = document.getElementById('editFilial');
  const inpIni       = document.getElementById('editIni');
  const inpFim       = document.getElementById('editFim');
  const selTam       = document.getElementById('editTam');
  const inpQtd       = document.getElementById('editQtd');
  const btnCancel    = document.getElementById('btnEditCancelar');
  const btnSave      = document.getElementById('btnEditSalvar');

  let selNomeBox     = null; // select (substitui #editNome input)

  /* ====== UX helpers ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  const eqi = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();

  /* ====== CSV/GitHub helpers ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== UI helpers ====== */
  function fillSelect(sel, options, current){
    if (!sel) return;
    sel.innerHTML = options.map(o=> `<option${String(o)===String(current)?' selected':''}>${o}</option>`).join('');
  }
  function ensureNomeSelect(){
    if (selNomeBox && selNomeBox.tagName==='SELECT') return selNomeBox;
    const sel = document.createElement('select');
    sel.id = 'editNomeSel';
    sel.style.minWidth = '240px';
    if (inpNome) inpNome.replaceWith(sel);
    selNomeBox = sel;
    return sel;
  }
  async function loadNomeTabloideOptions(selectEl, currentValue){
    if(!selectEl) return;
    selectEl.innerHTML = `<option value="">Carregando…</option>`;
    try{
      const { text } = await ghGetFile(GH.namesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      let names=[];
      if (header.length){
        const idx = header.findIndex(h => String(h||'').trim().toLowerCase()==='nome');
        if (idx>=0) names = rows.map(r=> r[header[idx]]).filter(Boolean);
        else {
          const raw=parseCsv(text);
          for(let i=1;i<raw.length;i++){ const v=raw[i][0]; if(v) names.push(v); }
        }
      }
      names = [...new Set(names.map(s=>String(s).trim()))].filter(Boolean)
               .sort((a,b)=> a.localeCompare(b,'pt-BR'));
      // se o atual não estiver na lista, injeta no topo para não sumir
      if (currentValue && !names.includes(currentValue)) names.unshift(currentValue);
      selectEl.innerHTML = '';
      const ph = document.createElement('option'); ph.value=''; ph.textContent='— selecione —'; selectEl.appendChild(ph);
      const frag=document.createDocumentFragment();
      names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; if (n===currentValue) o.selected=true; frag.appendChild(o); });
      selectEl.appendChild(frag);
    }catch(e){
      console.error(e);
      selectEl.innerHTML = `<option value="">— selecione —</option>`;
      toast('Falha ao carregar nome_tabloide.csv');
    }
  }
  function populateRegionais(current){
    fillSelect(selRegional, REGIONAIS, current);
  }
  function populateUFsForRegional(regional, currentUF){
    const list = UF_MAP[regional] || [];
    selUF.innerHTML = list.map(uf => `<option${uf===currentUF?' selected':''}>${uf}</option>`).join('');
  }
  function getSelectedOT(){
    if (typeof window.getSelectedOT === 'function') return window.getSelectedOT();
    const tr = document.querySelector('#jobsBody tr.sel[data-ot]');
    return tr ? tr.getAttribute('data-ot') : null;
  }
  function readRowFromDOMByOT(ot){
    const tr = document.querySelector(`#jobsBody tr[data-ot="${CSS.escape(ot)}"]`);
    if (!tr) return null;
    const td = i => (tr.children[i]?.textContent||'').trim();
    return {
      ot: td(0), regional: td(1), tipoLoja: td(2), tipoJob: td(3), nome: td(4),
      compl: td(5), uf: td(6), filial: (tr.children[7]?.querySelector('.clip')?.getAttribute('data-full') || td(7) || '').trim(),
      ini: td(8), fim: td(9), tam: td(10), qtd: td(11)
    };
  }

  /* ====== ABRIR EDITAR ====== */
  async function openEditar(){
    const ot = getSelectedOT();
    if (!ot){ toast('Selecione um job para editar.'); return; }

    // lê valores atuais da linha (DOM)
    const cur = readRowFromDOMByOT(ot);
    if (!cur){ toast('Não consegui ler os dados do job.'); return; }

    // Preenche cabeçalho OT
    lblOT.textContent = cur.ot || '—';

    // Regionais e UF
    populateRegionais(cur.regional || '');
    populateUFsForRegional(cur.regional || '', cur.uf || '');
    selRegional.onchange = ()=> populateUFsForRegional(selRegional.value, selUF.value);

    // Demais campos
    selTipoLoja.value = cur.tipoLoja || '';
    selTipoJob.value  = cur.tipoJob || '';
    inpCompl.value    = cur.compl    || '';
    inpFilial.value   = cur.filial   || '';
    inpIni.value      = cur.ini      || '';
    inpFim.value      = cur.fim      || '';
    selTam.value      = cur.tam      || '';
    inpQtd.value      = cur.qtd      || '';

    // Nome (select com nomes do CSV)
    const sel = ensureNomeSelect();
    await loadNomeTabloideOptions(sel, cur.nome || '');

    dlg.showModal();
  }

  /* ====== SALVAR EDITAR ====== */
  async function saveEditar(){
    const ot = (lblOT.textContent||'').trim();
    if (!ot){ toast('OT inválida.'); return; }
    if (!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    const regional = selRegional.value || '';
    const tipoLoja = selTipoLoja.value || '';
    const tipoJob  = selTipoJob.value  || '';
    const nome     = (selNomeBox && selNomeBox.value) || '';
    const compl    = inpCompl.value || '';
    const uf       = selUF.value || '';
    const filial   = inpFilial.value || '';
    const ini      = inpIni.value || '';
    const fim      = inpFim.value || '';
    const tam      = selTam.value || '';
    const qtd      = (inpQtd.value||'').trim();

    // validações básicas
    if (!regional || !tipoLoja || !tipoJob || !nome || !uf || !ini || !fim || !tam || !qtd){
      toast('Preencha Regional, Tipo da loja, Tipo do JOB, Nome, UF, Período, Tamanho e Quantidade.');
      return;
    }
    const qn = parseInt(qtd,10);
    if (isNaN(qn) || qn<=0){ toast('Quantidade inválida.'); return; }

    // valida UF compatível com regional
    const allowedUFs = UF_MAP[regional] || [];
    if (allowedUFs.length && !allowedUFs.includes(uf)){
      toast('UF não é permitida para a regional selecionada.');
      return;
    }
    // datas
    if (ini && fim && new Date(ini) > new Date(fim)){
      toast('Período inválido (início > término).');
      return;
    }

    setBusy(true,'Salvando…');
    try{
      // 1) Carregar jobs.csv
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { header:H, rows } = csvToObjsAndHeader(text);
      if (!rows.length || !H.length) throw new Error('jobs.csv vazio ou sem cabeçalho.');

      // 2) Encontrar e atualizar a linha do OT
      const idx = rows.findIndex(r => eqi(r.ot, ot));
      if (idx < 0) throw new Error('OT não encontrada em jobs.csv');

      const now = new Date().toISOString();
      const r = rows[idx];
      r.regional = regional;
      r.tipoLoja = tipoLoja;
      r.tipoJob  = tipoJob;
      r.nome     = nome;
      r.compl    = compl;
      r.uf       = uf;
      r.filial   = filial;
      r.ini      = ini;
      r.fim      = fim;
      r.tam      = tam;
      r.qtd      = String(qn);
      r.atualizado_em = now;

      // 3) Salvar de volta
      const nextText = toCsv(H, rows);
      await ghPutFile(GH.jobsPath, nextText, `chore(csv): edit job ${ot}`);

      // 4) Atualizar UI principal (recarrega e garante “+” e “…”)
      if (typeof window.loadJobsFromGitHub === 'function') {
        await window.loadJobsFromGitHub();
      }
      if (typeof window.decorateFiliaisCellForOT === 'function') {
        window.decorateFiliaisCellForOT(ot);
      }

      toast('Alterações salvas.');
      dlg.close();
    }catch(e){
      console.error(e);
      toast('Erro ao salvar edição.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== BINDS ====== */
  if (btnEditar)   btnEditar.addEventListener('click', openEditar);
  if (btnCancel)   btnCancel.addEventListener('click', ()=> dlg.close());
  if (btnSave)     btnSave.addEventListener('click', saveEditar);

})();
</script>

<!-- ============ BOTÃO EDITAR — configuração completa (com Nome como SELECT + “…” em Filial) ============ FIM -->

<!-- ============ BOTÃO DUPLICAR — IMPLEMENTAÇÃO COMPLETA (passo 1 + passo 2 + ações nacionais + gravação em jobs.csv) ============ -->
<script>
(function(){
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv',
    namesPath:'nome_tabloide.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnDuplicar  = document.getElementById('btnDuplicar');

  // Passo 1 (seleção)
  const dlgSel       = document.getElementById('modalDup1');
  const selReg       = document.getElementById('dupReg');
  let   selNomeFiltro= null; // (vai substituir o input #dupNome por SELECT)
  const btnFiltrar   = document.getElementById('dupFiltrar');
  const btnSelTodos  = document.getElementById('dupSelTodos');
  const btnSelNenhum = document.getElementById('dupSelNenhum');
  const tbodySel     = document.getElementById('dupList');
  const btn1Cancel   = document.getElementById('dup1Cancelar');
  const btn1Avancar  = document.getElementById('dup1Avancar');

  // Passo 2 (parâmetros)
  const dlgPar       = document.getElementById('modalDup2');
  const formPar      = document.getElementById('formDup2');
  const selTipoJob   = document.getElementById('dupTipoJob');
  let   selNomeNovo  = null; // (vai substituir o input #dupNomeNovo por SELECT)
  const inpIni       = document.getElementById('dupIni');
  const inpFim       = document.getElementById('dupFim');
  const selTam       = document.getElementById('dupTam');
  const inpQtd       = document.getElementById('dupQtd');

  // Ação nacional
  const radNacNao    = document.getElementById('dupAcaoNao');
  const radNacSim    = document.getElementById('dupAcaoSim');
  const inpAcaoNome  = document.getElementById('dupAcaoNome');
  const btnPickAcao  = document.getElementById('btnDupEscolherAcao'); // “Nova ação…”
  let   selAcaoExist = null; // SELECT dinâmico com ações existentes

  // Modal de ação nacional reutilizado
  const dlgAcao      = document.getElementById('modalAcao');
  const boxAcoes     = document.getElementById('acaoLista');
  const inpAcaoNova  = document.getElementById('acaoNova');
  const btnAcaoOk    = document.getElementById('acaoOk');
  const btnAcaoCanc  = document.getElementById('acaoCancelar');

  // Área de trabalho (pra ler subpartes existentes de ESPECIAL NACIONAL)
  const jobsBody     = document.getElementById('jobsBody');

  // Resumo
  const dupResumo    = document.getElementById('dupResumo');

  /* ====== UX helpers ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ====== CSV/GitHub ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else { if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== Dados/estado ====== */
  const REGIONALS = [
    'REGIONAL BA - SE','REGIONAL DF - GO - TO','REGIONAL MG','REGIONAL MS','REGIONAL MT - RO - AC',
    'REGIONAL NORDESTE 1','REGIONAL NORDESTE 2','REGIONAL NORTE','REGIONAL PR','REGIONAL RJ - ES',
    'REGIONAL RS','REGIONAL SP','REGIONAL SC'
  ];
  let _head = [];
  let _rows = [];
  let _selOTs = [];
  let _acaoPickerBound = false;

  /* ====== Helpers ====== */
  function fillRegFilter(){
    if(!selReg) return;
    if (!selReg.options.length){
      selReg.innerHTML = `<option>(todas)</option>` + REGIONALS.map(r=>`<option>${r}</option>`).join('');
    }
  }
  function ensureSelectReplacingInput(id, minWidthPx){
    const old = document.getElementById(id);
    if (old && old.tagName === 'SELECT') return old;
    const sel = document.createElement('select');
    sel.id = id;
    if (minWidthPx) sel.style.minWidth = minWidthPx + 'px';
    if (old) old.replaceWith(sel);
    return sel;
  }
  function updateResumo(){
    const parts = [];
    parts.push(`Selecionados: ${_selOTs.length}`);
    if (selTipoJob?.value) parts.push(`Tipo do JOB: ${selTipoJob.value}`);
    if (selNomeNovo && selNomeNovo.value) parts.push(`Nome: ${selNomeNovo.value}`);
    if (inpIni?.value && inpFim?.value) parts.push(`Período: ${inpIni.value} → ${inpFim.value}`);
    if (selTam?.value) parts.push(`Tamanho: ${selTam.value}`);
    if (inpQtd?.value) parts.push(`Páginas: ${inpQtd.value}`);
    if (radNacSim?.checked){
      parts.push('Ação nacional: Sim');
      if (inpAcaoNome?.value.trim()) parts.push(`Ação: ${inpAcaoNome.value.trim()}`);
    } else {
      parts.push('Ação nacional: Não');
    }
    if (dupResumo) dupResumo.textContent = parts.join(' • ');
  }
  function extractMaxOTNumber(rows){
    let max=0;
    for(const r of rows){
      const m = String(r.ot||'').match(/(\d+)/);
      if(!m) continue;
      const n = parseInt(m[1],10);
      if (!isNaN(n) && n>max) max=n;
    }
    return max;
  }
  function nextOTFactory(allRows){
    let maxN = extractMaxOTNumber(allRows);
    return () => {
      maxN += 1;
      return `OT-${String(maxN).padStart(4,'0')}`;
    };
  }

  /* ====== nome_tabloide.csv → OPTIONS (acentos OK via textContent) ====== */
  async function loadNomeOptionsIntoSelect(selectEl, includeBlank=true, blankLabel='— selecione —', listAllLabel='(todas)'){
    if (!selectEl) return;
    selectEl.innerHTML = '';
    if (includeBlank){
      const o = document.createElement('option');
      o.value = '';
      o.textContent = blankLabel;
      selectEl.appendChild(o);
    }
    try{
      const { text } = await ghGetFile(GH.namesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      let names = [];
      if (header.length){
        const idxNome = header.findIndex(h => String(h||'').trim().toLowerCase() === 'nome');
        if (idxNome >= 0) names = rows.map(r => r[header[idxNome]]).filter(Boolean);
        else {
          const raw = parseCsv(text);
          for (let i=1;i<raw.length;i++){ const v=raw[i][0]; if(v) names.push(v); }
        }
      }
      names = [...new Set(names.map(s => String(s).trim()))].filter(Boolean)
              .sort((a,b)=> a.localeCompare(b,'pt-BR'));

      // (modo filtro passo 1) se quiser “(todas)”
      if (includeBlank && listAllLabel === '(todas)') {
        selectEl.options[0].textContent = listAllLabel;
      }

      const frag=document.createDocumentFragment();
      names.forEach(n=>{
        const o=document.createElement('option');
        o.value = n;
        o.textContent = n; // acentos OK
        frag.appendChild(o);
      });
      selectEl.appendChild(frag);
    }catch(e){
      console.error(e);
      toast('Não foi possível carregar nome_tabloide.csv');
    }
  }

  /* ====== AÇÕES EXISTENTES (subpartes do ESPECIAL NACIONAL) ====== */
  function collectExistingActions(){
    const list = [];
    document.querySelectorAll('#jobsBody tr.sub-row[data-sub]').forEach(tr=>{
      const name = (tr.getAttribute('data-sub') || '').trim();
      if (name && !list.includes(name)) list.push(name);
    });
    return list.sort((a,b)=> a.localeCompare(b,'pt-BR'));
  }
  function ensureAcaoSelect(){
    // onde fica o campo Ação no passo 2 (col-9)
    const wrap = document.getElementById('modalDup2')?.querySelector('.col-9');
    if (!wrap) return null;
    const row = wrap.querySelector('div[style*="align-items:center"]') || wrap;
    let sel = row.querySelector('#dupAcaoSel');
    if (sel) return sel;

    sel = document.createElement('select');
    sel.id = 'dupAcaoSel';
    sel.style.minWidth = '220px';
    sel.style.flex = '0 0 auto';
    sel.style.marginRight = '8px';

    const beforeEl = btnPickAcao;
    if (beforeEl && beforeEl.parentNode) beforeEl.parentNode.insertBefore(sel, beforeEl);
    else row.prepend(sel);

    sel.addEventListener('change', ()=>{
      inpAcaoNome.value = sel.value || '';
      updateResumo();
    });

    return sel;
  }
  function populateAcaoSelect(){
    selAcaoExist = ensureAcaoSelect();
    if (!selAcaoExist) return;
    const actions = collectExistingActions();

    selAcaoExist.innerHTML = '';
    const ph = document.createElement('option'); ph.value=''; ph.textContent='(selecionar)'; selAcaoExist.appendChild(ph);
    actions.forEach(n=>{
      const o=document.createElement('option'); o.value=n; o.textContent=n; selAcaoExist.appendChild(o);
    });

    // sincroniza com o input caso já tenha valor
    const v = (inpAcaoNome.value||'').trim();
    selAcaoExist.value = actions.includes(v) ? v : '';
  }
  function openAcaoPicker(){
    if (!dlgAcao) return;
    // lista existentes
    const subs = collectExistingActions();
    if (boxAcoes){
      if (!subs.length){
        boxAcoes.innerHTML = `<div class="hint">Nenhuma ação existente. Crie uma nova abaixo.</div>`;
      } else {
        boxAcoes.innerHTML = subs.map(n =>
          `<label style="display:flex;gap:8px;align-items:center;padding:6px 4px;cursor:pointer">
             <input type="radio" name="acaoPick" value="${n.replace(/"/g,'&quot;')}"> <span>${n}</span>
           </label>`).join('');
      }
    }
    if (inpAcaoNova) inpAcaoNova.value = '';
    dlgAcao.showModal();

    if(!_acaoPickerBound){
      _acaoPickerBound = true;
      btnAcaoOk?.addEventListener('click', ()=>{
        const sel = dlgAcao.querySelector('input[name="acaoPick"]:checked');
        const chosen = sel ? sel.value : (inpAcaoNova?.value||'').trim();
        if (!chosen){ toast('Escolha ou digite uma ação.'); return; }
        inpAcaoNome.value = chosen;
        populateAcaoSelect(); // repopula e seleciona se for novo
        if (selAcaoExist) selAcaoExist.value = chosen;
        updateResumo();
        dlgAcao.close();
      });
      btnAcaoCanc?.addEventListener('click', ()=> dlgAcao.close());
    }
  }
  function onToggleNacional(){
    const isSim = radNacSim && radNacSim.checked;
    if (btnPickAcao) {
      btnPickAcao.disabled = !isSim;
      btnPickAcao.textContent = 'Nova ação…';
    }
    if (!selAcaoExist) selAcaoExist = ensureAcaoSelect();
    if (selAcaoExist) selAcaoExist.disabled = !isSim;
    if (isSim) populateAcaoSelect();
    if (!isSim){
      inpAcaoNome.value = '';
      if (selAcaoExist) selAcaoExist.value = '';
    }
    updateResumo();
  }

  /* ====== PASSO 1 ====== */
  function renderSelList(list){
    if(!tbodySel) return;
    if(!list.length){
      tbodySel.innerHTML = `<tr><td colspan="5" class="hint">Sem resultados. Use os filtros acima.</td></tr>`;
      return;
    }
    list.sort((a,b)=> String(a.ot||'').localeCompare(String(b.ot||''), undefined, {numeric:true, sensitivity:'base'}));
    const frag=document.createDocumentFragment();
    list.forEach(r=>{
      const tr=document.createElement('tr');
      const id='dup_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
      tr.innerHTML = `
        <td><input type="checkbox" data-ot="${r.ot||''}" id="${id}"></td>
        <td>${r.ot||'—'}</td>
        <td>${r.regional||'—'}</td>
        <td>${r.nome||'—'}</td>
        <td>${r.status||'—'}</td>`;
      frag.appendChild(tr);
    });
    tbodySel.innerHTML=''; tbodySel.appendChild(frag);
  }
  function applySelFilter(){
    const reg = (selReg?.value||'(todas)').trim();
    const nomeSelected = (selNomeFiltro?.value||'').trim();

    let list = _rows.slice();
    if (reg !== '(todas)') list = list.filter(r => (r.regional||'') === reg);
    if (nomeSelected)      list = list.filter(r => (r.nome||'') === nomeSelected);

    renderSelList(list);
  }
  async function openStep1(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    fillRegFilter();

    // transforma campo de filtro de nome em SELECT e carrega nomes
    selNomeFiltro = ensureSelectReplacingInput('dupNome', 220);
    await loadNomeOptionsIntoSelect(selNomeFiltro, true, '(todas)', '(todas)');
    selNomeFiltro.addEventListener('change', applySelFilter);

    if (formPar) formPar.reset();
    inpAcaoNome.value = '';
    if (btnPickAcao) btnPickAcao.disabled = true;
    if (!selAcaoExist) selAcaoExist = ensureAcaoSelect();
    if (selAcaoExist) { selAcaoExist.innerHTML = '<option value="">(selecionar)</option>'; selAcaoExist.disabled = true; }

    _selOTs = [];

    setBusy(true,'Carregando jobs…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      _head = parsed.header || [];
      _rows = parsed.rows   || [];

      renderSelList([]);
      dlgSel && dlgSel.showModal();
    }catch(e){
      console.error(e);
      toast('Falha ao carregar jobs.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== PASSO 2 ====== */
  async function openStep2(){
    if (formPar) formPar.reset();
    inpAcaoNome.value = '';
    if (!selAcaoExist) selAcaoExist = ensureAcaoSelect();
    if (selAcaoExist) { selAcaoExist.innerHTML = '<option value="">(selecionar)</option>'; selAcaoExist.disabled = true; }
    if (btnPickAcao) btnPickAcao.disabled = true;

    // Nome do tabloide no passo 2 como SELECT
    selNomeNovo = ensureSelectReplacingInput('dupNomeNovo', 240);
    await loadNomeOptionsIntoSelect(selNomeNovo, true, '— selecione —');
    selNomeNovo.addEventListener('change', updateResumo);

    updateResumo();
    dlgPar?.showModal();
  }

  /* ====== Validação / Duplicar ====== */
  function validateDupParams(){
    const tipoJob = (selTipoJob?.value||'').trim();
    const nomeComum = (selNomeNovo && selNomeNovo.value || '').trim();
    const ini = (inpIni?.value||'').trim();
    const fim = (inpFim?.value||'').trim();
    const tam = (selTam?.value||'').trim();
    const qtd = (inpQtd?.value||'').trim();
    const isNac = !!(radNacSim && radNacSim.checked);
    const acao = (inpAcaoNome?.value||'').trim();

    if (!tipoJob || !nomeComum || !ini || !fim || !tam || !qtd){
      toast('Preencha Tipo do JOB, Nome, Período, Tamanho e Quantidade.');
      return null;
    }
    if (isNac && !acao){
      toast('Defina a ação nacional.');
      return null;
    }
    const qn = parseInt(qtd,10);
    if (isNaN(qn) || qn<=0){ toast('Quantidade de páginas inválida.'); return null; }

    return { tipoJob, nomeComum, ini, fim, tam, qtd: String(qn), isNac, acao };
  }
  function findJobsByOTs(ots){
    const set = new Set(ots.map(String));
    return _rows.filter(r => set.has(String(r.ot)));
  }
  async function doDuplicate(){
    if(!_selOTs.length){ toast('Nenhum job selecionado para duplicar.'); return; }
    const params = validateDupParams();
    if(!params) return;
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    const origs = findJobsByOTs(_selOTs);
    if (!origs.length){ toast('Seleção vazia.'); return; }

    const now = new Date().toISOString();
    setBusy(true,'Duplicando…');

    try{
      const rowsAll = _rows.slice();
      const newRows = [];
      const nextOT = nextOTFactory(rowsAll);

      for (const src of origs){
        const obj = { ...src };

        obj.ot        = nextOT();
        obj.tipoJob   = params.tipoJob;
        obj.nome      = params.nomeComum;
        obj.ini       = params.ini;
        obj.fim       = params.fim;
        obj.tam       = params.tam;
        obj.qtd       = params.qtd;

        obj.isNacional = params.isNac ? 'sim' : 'nao';
        obj.acaoNome   = params.isNac ? params.acao : (src.acaoNome || '');

        // reset de status/logs
        obj.status       = 'Novo';
        obj.statusStep   = 'novo';
        obj.logs         = '{}';
        obj.criado_em    = now;
        obj.atualizado_em= now;

        newRows.push(obj);
        rowsAll.push(obj);
      }

      const csv = toCsv(_head, rowsAll);
      await ghPutFile(GH.jobsPath, csv, `chore(csv): duplicate ${newRows.length} job(s)`);

      // Atualiza UI
      if (typeof window.loadJobsFromGitHub === 'function') {
        await window.loadJobsFromGitHub();
      }

      toast(`${newRows.length} job(s) duplicados.`);
      dlgPar?.close();
      dlgSel?.close();
    }catch(e){
      console.error(e);
      toast('Erro ao duplicar. Tente novamente.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== BINDS ====== */
  if (btnDuplicar){
    btnDuplicar.addEventListener('click', openStep1);
  }
  btnFiltrar?.addEventListener('click', applySelFilter);
  btnSelTodos?.addEventListener('click', ()=> tbodySel?.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));
  btnSelNenhum?.addEventListener('click', ()=> tbodySel?.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=false));
  btn1Cancel?.addEventListener('click', ()=> dlgSel?.close());
  btn1Avancar?.addEventListener('click', async ()=>{
    const sel = [...(tbodySel?.querySelectorAll('input[type="checkbox"][data-ot]:checked')||[])].map(b=> b.getAttribute('data-ot'));
    if(!sel.length){ toast('Selecione ao menos 1 job.'); return; }
    _selOTs = sel;
    await openStep2();
  });

  // passo 2
  document.getElementById('dup2Voltar')?.addEventListener('click', ()=>{
    dlgPar?.close();
    dlgSel?.showModal();
  });
  document.getElementById('dup2Limpar')?.addEventListener('click', async ()=>{
    formPar?.reset();
    inpAcaoNome.value = '';
    if (!selAcaoExist) selAcaoExist = ensureAcaoSelect();
    if (selAcaoExist){ selAcaoExist.innerHTML = '<option value="">(selecionar)</option>'; selAcaoExist.disabled = true; }
    if (btnPickAcao) btnPickAcao.disabled = true;
    selNomeNovo = ensureSelectReplacingInput('dupNomeNovo', 240);
    await loadNomeOptionsIntoSelect(selNomeNovo, true, '— selecione —');
    updateResumo();
  });
  document.getElementById('dup2Lancar')?.addEventListener('click', doDuplicate);

  ;[selTipoJob, inpIni, inpFim, selTam, inpQtd]?.forEach(el=>{
    if(el) el.addEventListener('input', updateResumo);
  });

  radNacNao?.addEventListener('change', onToggleNacional);
  radNacSim?.addEventListener('change', onToggleNacional);
  btnPickAcao?.addEventListener('click', openAcaoPicker);

})();
</script>

<!-- ============ BOTÃO DUPLICAR — IMPLEMENTAÇÃO COMPLETA (passo 1 + passo 2 + ações nacionais + gravação em jobs.csv) ============ FIM -->

<!-- ============ DUPLICAR SELECIONADOS em “Visualizar finalizados” (#modalFinalizados) ============ -->
<script>
(function(){
  /* ====== CONFIG ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv',
    encPath:  'jobs_encerrados.csv',
    namesPath:'nome_tabloide.csv'
  };

  /* ====== ELEMENTOS (Finalizados) ====== */
  const dlgFinalizados = document.getElementById('modalFinalizados');
  const finzList       = document.getElementById('finzList');
  const btnFinzDup     = document.getElementById('finzDuplicar');

  /* ====== ELEMENTOS (Passo 2 – reutiliza o modal do Duplicar) ====== */
  const dlgPar      = document.getElementById('modalDup2');
  const formPar     = document.getElementById('formDup2');
  const selTipoJob  = document.getElementById('dupTipoJob');
  const inpIni      = document.getElementById('dupIni');
  const inpFim      = document.getElementById('dupFim');
  const selTam      = document.getElementById('dupTam');
  const inpQtd      = document.getElementById('dupQtd');
  const dupResumo   = document.getElementById('dupResumo');

  // Nome (vai virar <select>)
  let selNomeNovo   = null; // substitui #dupNomeNovo

  // Ação nacional
  const radNacNao   = document.getElementById('dupAcaoNao');
  const radNacSim   = document.getElementById('dupAcaoSim');
  const inpAcaoNome = document.getElementById('dupAcaoNome');
  const btnPickAcao = document.getElementById('btnDupEscolherAcao'); // “Nova ação…”
  let   selAcaoExist = null; // select com ações existentes (criamos dinamicamente)

  // Botões padrão do passo 2
  const btnVoltar   = document.getElementById('dup2Voltar');
  const btnLimpar   = document.getElementById('dup2Limpar');
  const btnLancar   = document.getElementById('dup2Lancar'); // vamos esconder quando vier de Finalizados
  let   btnLancarFinz = null; // botão temporário “Duplicar selecionados”

  /* ====== STATE ====== */
  let FINZ_MODE_ACTIVE = false;
  let _finzSources = [];     // linhas (objetos) do jobs_encerrados.csv selecionadas
  let _headJobs    = [];     // cabeçalho do jobs.csv (para salvar)
  let _allJobsRows = [];     // linhas atuais do jobs.csv (para gerar nova OT)

  /* ====== UX helpers ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ====== CSV/GitHub helpers ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== Helpers (UI passo 2) ====== */
  function FinzDup_updateResumo(){
    const parts=[];
    parts.push(`Selecionados: ${_finzSources.length}`);
    if (selTipoJob?.value) parts.push(`Tipo do JOB: ${selTipoJob.value}`);
    if (selNomeNovo && selNomeNovo.value) parts.push(`Nome: ${selNomeNovo.value}`);
    if (inpIni?.value && inpFim?.value) parts.push(`Período: ${inpIni.value} → ${inpFim.value}`);
    if (selTam?.value) parts.push(`Tamanho: ${selTam.value}`);
    if (inpQtd?.value) parts.push(`Páginas: ${inpQtd.value}`);
    if (radNacSim?.checked){
      parts.push('Ação nacional: Sim');
      if (inpAcaoNome?.value.trim()) parts.push(`Ação: ${inpAcaoNome.value.trim()}`);
    } else {
      parts.push('Ação nacional: Não');
    }
    if (dupResumo) dupResumo.textContent = parts.join(' • ');
  }
  function FinzDup_extractMaxOTNumber(rows){
    let max=0;
    for(const r of rows){
      const m = String(r.ot||'').match(/(\d+)/);
      if(!m) continue;
      const n = parseInt(m[1],10);
      if (!isNaN(n) && n>max) max=n;
    }
    return max;
  }
  function FinzDup_nextOTFactory(allRows){
    let maxN = FinzDup_extractMaxOTNumber(allRows);
    return () => {
      maxN += 1;
      return `OT-${String(maxN).padStart(4,'0')}`;
    };
  }
  function FinzDup_ensureSelectReplacingInput(id, minWidthPx){
    const old = document.getElementById(id);
    if (old && old.tagName === 'SELECT') return old;
    const sel = document.createElement('select');
    sel.id = id;
    if (minWidthPx) sel.style.minWidth = minWidthPx + 'px';
    if (old) old.replaceWith(sel);
    return sel;
  }
  async function FinzDup_loadNomeOptionsIntoSelect(selectEl){
    if (!selectEl) return;
    selectEl.innerHTML = '';
    const ph = document.createElement('option'); ph.value=''; ph.textContent='— selecione —'; selectEl.appendChild(ph);
    try{
      const { text } = await ghGetFile(GH.namesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      let names=[];
      if (header.length){
        const idx = header.findIndex(h => String(h||'').trim().toLowerCase()==='nome');
        if (idx>=0) names = rows.map(r=> r[header[idx]]).filter(Boolean);
        else {
          const raw=parseCsv(text);
          for(let i=1;i<raw.length;i++){ const v=raw[i][0]; if(v) names.push(v); }
        }
      }
      names = [...new Set(names.map(s=>String(s).trim()))].filter(Boolean)
               .sort((a,b)=> a.localeCompare(b,'pt-BR'));
      const frag=document.createDocumentFragment();
      names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; frag.appendChild(o); });
      selectEl.appendChild(frag);
    }catch(e){
      console.error(e);
      toast('Não foi possível carregar nome_tabloide.csv');
    }
  }

  /* ====== Ações existentes (subpartes de ESPECIAL NACIONAL) ====== */
  function FinzDup_collectExistingActions(){
    const list=[];
    document.querySelectorAll('#jobsBody tr.sub-row[data-sub]').forEach(tr=>{
      const name = (tr.getAttribute('data-sub')||'').trim();
      if (name && !list.includes(name)) list.push(name);
    });
    return list.sort((a,b)=> a.localeCompare(b,'pt-BR'));
  }
  function FinzDup_ensureAcaoSelect(){
    const wrap = document.getElementById('modalDup2')?.querySelector('.col-9');
    if (!wrap) return null;
    const row = wrap.querySelector('div[style*="align-items:center"]') || wrap;
    let sel = row.querySelector('#dupAcaoSel');
    if (sel) return sel;

    sel = document.createElement('select');
    sel.id = 'dupAcaoSel';
    sel.style.minWidth = '220px';
    sel.style.flex = '0 0 auto';
    sel.style.marginRight = '8px';

    const beforeEl = btnPickAcao;
    if (beforeEl && beforeEl.parentNode) beforeEl.parentNode.insertBefore(sel, beforeEl); else row.prepend(sel);

    sel.addEventListener('change', ()=>{
      inpAcaoNome.value = sel.value || '';
      FinzDup_updateResumo();
    });

    return sel;
  }
  function FinzDup_populateAcaoSelect(){
    selAcaoExist = FinzDup_ensureAcaoSelect();
    if (!selAcaoExist) return;
    const actions = FinzDup_collectExistingActions();

    selAcaoExist.innerHTML='';
    const ph = document.createElement('option'); ph.value=''; ph.textContent='(selecionar)'; selAcaoExist.appendChild(ph);
    actions.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; selAcaoExist.appendChild(o); });

    const v=(inpAcaoNome.value||'').trim();
    selAcaoExist.value = actions.includes(v) ? v : '';
  }
  // Reaproveita seu modal de ação nacional (#modalAcao) já existente
  function FinzDup_openAcaoPicker(){
    const dlgAcao = document.getElementById('modalAcao');
    const boxAcoes= document.getElementById('acaoLista');
    const inpNova = document.getElementById('acaoNova');
    const btnOk   = document.getElementById('acaoOk');
    const btnCanc = document.getElementById('acaoCancelar');
    if (!dlgAcao) return;

    const subs = FinzDup_collectExistingActions();
    if (boxAcoes){
      if(!subs.length){
        boxAcoes.innerHTML = `<div class="hint">Nenhuma ação existente. Crie uma nova abaixo.</div>`;
      }else{
        boxAcoes.innerHTML = subs.map(n =>
          `<label style="display:flex;gap:8px;align-items:center;padding:6px 4px;cursor:pointer">
             <input type="radio" name="acaoPick" value="${n.replace(/"/g,'&quot;')}"> <span>${n}</span>
           </label>`).join('');
      }
    }
    if (inpNova) inpNova.value='';

    dlgAcao.showModal();

    // bind one-off
    const okHandler = ()=> {
      const sel = dlgAcao.querySelector('input[name="acaoPick"]:checked');
      const chosen = sel ? sel.value : (inpNova?.value||'').trim();
      if (!chosen){ toast('Escolha ou digite uma ação.'); return; }
      inpAcaoNome.value = chosen;
      FinzDup_populateAcaoSelect();
      if (selAcaoExist) selAcaoExist.value = chosen;
      FinzDup_updateResumo();
      dlgAcao.close();
      btnOk.removeEventListener('click', okHandler);
      btnCanc.removeEventListener('click', cancHandler);
    };
    const cancHandler = ()=> {
      dlgAcao.close();
      btnOk.removeEventListener('click', okHandler);
      btnCanc.removeEventListener('click', cancHandler);
    };
    btnOk?.addEventListener('click', okHandler);
    btnCanc?.addEventListener('click', cancHandler);
  }
  function FinzDup_onToggleNacional(){
    const isSim = radNacSim && radNacSim.checked;
    if (btnPickAcao){
      btnPickAcao.disabled = !isSim;
      btnPickAcao.textContent = 'Nova ação…';
    }
    if (!selAcaoExist) selAcaoExist = FinzDup_ensureAcaoSelect();
    if (selAcaoExist) selAcaoExist.disabled = !isSim;
    if (isSim) FinzDup_populateAcaoSelect();
    if (!isSim){
      inpAcaoNome.value='';
      if (selAcaoExist) selAcaoExist.value='';
    }
    FinzDup_updateResumo();
  }

  /* ====== Coleta seleção no Finalizados ====== */
  function FinzDup_selectedOTs(){
    return [...(finzList?.querySelectorAll('input[type="checkbox"][data-ot]:checked')||[])]
      .map(b=> b.getAttribute('data-ot')).filter(Boolean);
  }

  /* ====== Abrir PASSO 2 já com fontes do jobs_encerrados.csv ====== */
  async function FinzDup_openStep2FromFinalizados(){
    const sel = FinzDup_selectedOTs();
    if (!sel.length){ toast('Selecione ao menos 1 job finalizado.'); return; }
    if (!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    setBusy(true,'Preparando…');
    try{
      // 1) Ler enc + jobs (para header e gerar próxima OT)
      const [encFile, jobsFile] = await Promise.all([
        ghGetFile(GH.encPath, GH.branch),
        ghGetFile(GH.jobsPath, GH.branch)
      ]);
      const encParsed  = csvToObjsAndHeader(encFile.text);
      const jobsParsed = csvToObjsAndHeader(jobsFile.text);
      _headJobs    = jobsParsed.header || [];
      _allJobsRows = jobsParsed.rows   || [];

      // 2) filtro fontes pelo OT
      const set = new Set(sel.map(String));
      _finzSources = (encParsed.rows||[]).filter(r => set.has(String(r.ot)));

      if(!_finzSources.length){ toast('Não encontrei os itens selecionados.'); return; }

      // 3) Preparar UI passo 2 (nome: select; ações nacionais; resumo)
      if (formPar) formPar.reset();
      // Nome em SELECT
      selNomeNovo = FinzDup_ensureSelectReplacingInput('dupNomeNovo', 240);
      await FinzDup_loadNomeOptionsIntoSelect(selNomeNovo);
      selNomeNovo.addEventListener('change', FinzDup_updateResumo, { once:false });

      // Ação nacional
      inpAcaoNome.value='';
      selAcaoExist = FinzDup_ensureAcaoSelect();
      if (selAcaoExist){ selAcaoExist.innerHTML='<option value="">(selecionar)</option>'; selAcaoExist.disabled = true; }
      if (btnPickAcao){
        btnPickAcao.disabled = true;
        btnPickAcao.onclick = FinzDup_openAcaoPicker;
      }
      radNacNao?.addEventListener('change', FinzDup_onToggleNacional, { once:false });
      radNacSim?.addEventListener('change', FinzDup_onToggleNacional, { once:false });

      // Troca botão “Lançar” por um específico desta jornada (para evitar conflito com outro fluxo)
      FINZ_MODE_ACTIVE = true;
      if (btnLancar){
        btnLancar.style.display = 'none';
      }
      if (!btnLancarFinz){
        btnLancarFinz = document.createElement('button');
        btnLancarFinz.type = 'button';
        btnLancarFinz.className = 'btn primary';
        btnLancarFinz.id = 'dup2LancarFinz';
        btnLancarFinz.textContent = 'Duplicar selecionados';
        // injeta antes do “Lançar” original (ou no fim das actions)
        const actions = formPar?.querySelector('.actions') || formPar;
        actions?.appendChild(btnLancarFinz);
      }
      btnLancarFinz.onclick = FinzDup_doDuplicate;

      // “Voltar” -> fecha passo 2 e reabre Finalizados
      const onBack = ()=>{
        dlgPar?.close();
        dlgFinalizados?.showModal();
        cleanupFinzMode();
      };
      btnVoltar?.addEventListener('click', onBack, { once:true });

      // Atualiza resumo e mostra
      FinzDup_updateResumo();
      dlgFinalizados?.close();
      dlgPar?.showModal();
    }catch(e){
      console.error(e);
      toast('Erro ao preparar duplicação.');
    }finally{
      setBusy(false);
    }
  }

  function cleanupFinzMode(){
    FINZ_MODE_ACTIVE = false;
    if (btnLancar) btnLancar.style.display = '';
    if (btnLancarFinz){
      btnLancarFinz.remove();
      btnLancarFinz = null;
    }
  }

  /* ====== Validar parâmetros ====== */
  function FinzDup_validateParams(){
    const tipoJob = (selTipoJob?.value||'').trim();
    const nomeComum = (selNomeNovo && selNomeNovo.value || '').trim();
    const ini = (inpIni?.value||'').trim();
    const fim = (inpFim?.value||'').trim();
    const tam = (selTam?.value||'').trim();
    const qtd = (inpQtd?.value||'').trim();
    const isNac = !!(radNacSim && radNacSim.checked);
    const acao = (inpAcaoNome?.value||'').trim();

    if (!tipoJob || !nomeComum || !ini || !fim || !tam || !qtd){
      toast('Preencha Tipo do JOB, Nome, Período, Tamanho e Quantidade.');
      return null;
    }
    if (isNac && !acao){
      toast('Defina a ação nacional.');
      return null;
    }
    const qn = parseInt(qtd,10);
    if (isNaN(qn) || qn<=0){ toast('Quantidade de páginas inválida.'); return null; }

    return { tipoJob, nomeComum, ini, fim, tam, qtd:String(qn), isNac, acao };
  }

  /* ====== DUPLICAR (a partir dos finalizados) ====== */
  async function FinzDup_doDuplicate(){
    if (!FINZ_MODE_ACTIVE) return; // proteção
    const params = FinzDup_validateParams();
    if(!params) return;
    if(!_finzSources.length){ toast('Seleção vazia.'); return; }
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    setBusy(true,'Duplicando…');
    try{
      // Gera novas OTs com base no jobs.csv atual
      const rowsAll = _allJobsRows.slice();
      const nextOT  = FinzDup_nextOTFactory(rowsAll);
      const now = new Date().toISOString();
      const newRows=[];

      for(const src of _finzSources){
        const obj = { ...src };

        obj.ot        = nextOT();
        obj.tipoJob   = params.tipoJob;
        obj.nome      = params.nomeComum;
        obj.ini       = params.ini;
        obj.fim       = params.fim;
        obj.tam       = params.tam;
        obj.qtd       = params.qtd;

        obj.isNacional = params.isNac ? 'sim' : 'nao';
        obj.acaoNome   = params.isNac ? params.acao : '';

        // mantém regional original (NÃO colocar “Especial Nacional” na coluna)
        // zera fluxo/estado
        obj.status       = 'Novo';
        obj.statusStep   = 'novo';
        obj.logs         = '{}';
        obj.criado_em    = now;
        obj.atualizado_em= now;

        newRows.push(obj);
        rowsAll.push(obj);
      }

      // Salva em jobs.csv
      const nextText = toCsv(_headJobs, rowsAll);
      await ghPutFile(GH.jobsPath, nextText, `chore(csv): duplicate from finalizados (${newRows.length})`);

      // Atualiza UI principal
      if (typeof window.loadJobsFromGitHub === 'function') {
        await window.loadJobsFromGitHub();
      }

      toast(`${newRows.length} job(s) duplicados a partir dos finalizados.`);
      dlgPar?.close();
      dlgFinalizados?.close();
      cleanupFinzMode();
    }catch(e){
      console.error(e);
      toast('Erro ao duplicar. Tente novamente.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== Binds ====== */
  if (btnFinzDup){
    btnFinzDup.addEventListener('click', FinzDup_openStep2FromFinalizados);
  }
  // Atualiza resumo conforme digita
  [selTipoJob, inpIni, inpFim, selTam, inpQtd].forEach(el=>{
    el && el.addEventListener('input', FinzDup_updateResumo);
  });
  radNacNao?.addEventListener('change', FinzDup_onToggleNacional);
  radNacSim?.addEventListener('change', FinzDup_onToggleNacional);
  btnPickAcao && (btnPickAcao.onclick = FinzDup_openAcaoPicker);

})();
</script>

<!-- ============ DUPLICAR SELECIONADOS em “Visualizar finalizados” (#modalFinalizados) ============ FIM -->

<!-- ============ BOTÃO FILTRAR — corrigido: filtro de REGIONAIS funcionando (lê r.regional OU r.regionalGrupo) ============ -->
<script>
(function(){
  /* ====== CONFIG ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv',
    namesPath:'nome_tabloide.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnOpen   = document.getElementById('btnFiltrar');
  const dlg       = document.getElementById('modalFiltro');
  const btnClose  = document.getElementById('fltFechar');
  const btnClear  = document.getElementById('fltLimpar');
  const btnApply  = document.getElementById('fltAplicar');

  const selRegional = document.getElementById('fltRegional');
  const inpNomeText = document.getElementById('fltNome'); // vira SELECT
  const inpIni      = document.getElementById('fltIni');
  const inpFim      = document.getElementById('fltFim');
  const selStatus   = document.getElementById('fltStatus');
  const selNac      = document.getElementById('fltNac');
  const selAcao     = document.getElementById('fltAcao');

  const tbody       = document.getElementById('fltList');

  let selNomeBox    = null; // <select id="fltNomeSel">

  /* ====== UX helpers ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  const eqi=(a,b)=> (a||'').trim().toLowerCase()===(b||'').trim().toLowerCase();
  const parseBool = v => ['1','true','sim','yes'].includes(String(v||'').trim().toLowerCase());

  /* ====== CSV / GitHub ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  function csvToObjects(text){
    const t=csvToObjsAndHeader(text); return t.rows;
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'' };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text = j && j.content ? b64ToUtf8(j.content) : '';
    return { text };
  }

  /* ====== Helpers ====== */
  function fillSelect(sel, options, withAllLabel){
    if (!sel) return;
    const list = withAllLabel ? [withAllLabel, ...options] : options.slice();
    sel.innerHTML = list.map(o=> `<option>${o}</option>`).join('');
  }
  function sortByOT(a,b){
    const na=(String(a.ot||'').match(/(\d+)/)||[])[1];
    const nb=(String(b.ot||'').match(/(\d+)/)||[])[1];
    const ia=na?parseInt(na,10):Number.MAX_SAFE_INTEGER;
    const ib=nb?parseInt(nb,10):Number.MAX_SAFE_INTEGER;
    if (ia!==ib) return ia-ib;
    return String(a.ot||'').localeCompare(String(b.ot||''), undefined, {numeric:true, sensitivity:'base'});
  }
  function inDateRange(jobIni, jobFim, fIni, fFim){
    if (!fIni && !fFim) return true;
    const jI = jobIni ? new Date(jobIni+'T00:00:00') : null;
    const jF = jobFim ? new Date(jobFim+'T23:59:59') : null;
    const dI = fIni   ? new Date(fIni +  'T00:00:00') : null;
    const dF = fFim   ? new Date(fFim +  'T23:59:59') : null;
    if (dI && dF){ return (!jF || jF >= dI) && (!jI || jI <= dF); }
    if (dI){ return (!jF || jF >= dI); }
    if (dF){ return (!jI || jI <= dF); }
    return true;
  }
  function updateAcaoEnabled(){
    if (!selAcao || !selNac) return;
    const on = (selNac.value === 'Sim');
    selAcao.disabled = !on;
    selAcao.style.opacity = on ? '1' : '.6';
  }
  function ensureNomeSelect(){
    if (selNomeBox && selNomeBox.tagName==='SELECT') return selNomeBox;
    const sel = document.createElement('select');
    sel.id = 'fltNomeSel';
    sel.style.minWidth = '240px';
    if (inpNomeText) {
      inpNomeText.replaceWith(sel);
    } else {
      const grid = dlg?.querySelector('.grid');
      if (grid) {
        const wrap = document.createElement('div');
        wrap.className = 'col-4';
        wrap.innerHTML = `<label>Nome do tabloide</label>`;
        wrap.appendChild(sel);
        grid.insertBefore(wrap, grid.children[1] || null);
      }
    }
    selNomeBox = sel;
    return sel;
  }
  async function loadNomeTabloideOptions(selectEl, current='(todas)'){
    if (!selectEl) return;
    selectEl.innerHTML = `<option>Carregando…</option>`;
    try{
      const { text } = await ghGetFile(GH.namesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      let names=[];
      if (header.length){
        let idx = header.findIndex(h => String(h||'').trim().toLowerCase()==='nome');
        if (idx<0) idx = 0;
        names = rows.map(r => r[header[idx]] || r[0] || '').map(s=>String(s).trim());
      }
      names = [...new Set(names)].filter(Boolean).sort((a,b)=> a.localeCompare(b,'pt-BR'));
      const all = ['(todas)', ...names];
      selectEl.innerHTML = all.map(n => `<option${n===current?' selected':''}>${n}</option>`).join('');
    }catch(e){
      console.error(e);
      selectEl.innerHTML = `<option>(todas)</option>`;
      toast('Falha ao carregar nome_tabloide.csv');
    }
  }
  async function loadAcoesToSelect(current){
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const rows = csvToObjects(text);
      const acoes = [...new Set(
        rows
          .filter(r => parseBool(r.isNacional) && (r.acaoNome||'').trim())
          .map(r => String(r.acaoNome).trim())
      )].sort((a,b)=> a.localeCompare(b,'pt-BR'));
      selAcao.innerHTML = ['(todas)', ...acoes].map(a => `<option${a===current?' selected':''}>${a}</option>`).join('');
    }catch(e){
      console.error(e);
      selAcao.innerHTML = `<option>(todas)</option>`;
    }
  }

  // NOVO: carrega as REGIONAIS existentes a partir do jobs.csv,
  // mantendo "(todas)" no topo.
  async function loadRegionaisToSelect(){
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const rows = csvToObjects(text);
      const regs = [...new Set(rows.map(r => (r.regional || r.regionalGrupo || '').trim()).filter(Boolean))]
                    .sort((a,b)=> a.localeCompare(b,'pt-BR'));
      fillSelect(selRegional, regs, '(todas)');
    }catch{
      // Se falhar, mantém o que já tiver no HTML
      if (!selRegional.options.length) selRegional.innerHTML = `<option>(todas)</option>`;
    }
  }

  function getRowRegional(r){ return (r.regional || r.regionalGrupo || ''); }

  function renderHint(){
    if (!tbody) return;
    tbody.innerHTML = `<tr><td colspan="13" class="hint">Defina os filtros e clique em “Aplicar”.</td></tr>`;
  }
  function renderRows(rows){
    if (!tbody) return;
    if (!rows.length){
      tbody.innerHTML = `<tr><td colspan="13" class="hint">Sem resultados para este filtro.</td></tr>`;
      return;
    }
    rows.sort(sortByOT);
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      const filialTxt=(r.filial||'').trim()||'—';
      const filialShort = filialTxt.length>18 ? filialTxt.slice(0,18)+'…' : filialTxt;
      const reg = getRowRegional(r);
      tr.innerHTML = `
        <td>${r.ot||'—'}</td>
        <td>${reg||'—'}</td>
        <td>${r.tipoLoja||'—'}</td>
        <td>${r.tipoJob||'—'}</td>
        <td>${r.nome||'—'}</td>
        <td>${r.compl||'—'}</td>
        <td>${r.uf||'—'}</td>
        <td><span class="clip" data-field="Filial(s)" data-full="${filialTxt}">${filialShort}</span></td>
        <td>${r.ini||'—'}</td>
        <td>${r.fim||'—'}</td>
        <td>${r.tam||'—'}</td>
        <td>${r.qtd||'—'}</td>
        <td>${r.status||'—'}</td>
      `;
      frag.appendChild(tr);
    });
    tbody.innerHTML=''; tbody.appendChild(frag);
  }

  // CORRIGIDO: aplica filtro de Regional usando r.regional OU r.regionalGrupo
  async function applyFilters(){
    if (!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    const fRegional = (selRegional?.value || '(todas)').trim();
    const fNome     = (selNomeBox?.value || '(todas)').trim();
    const fIni      = (inpIni?.value  || '').trim();
    const fFim      = (inpFim?.value  || '').trim();
    const fStatus   = (selStatus?.value || '(todos)').trim();
    const fNac      = (selNac?.value || '(ambos)').trim();
    const fAcao     = (selAcao?.value || '(todas)').trim();

    setBusy(true,'Aplicando filtros…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const rows = csvToObjects(text);

      const filtered = rows.filter(r=>{
        const rReg = getRowRegional(r);
        if (fRegional !== '(todas)' && rReg !== fRegional) return false;

        if (fNome !== '(todas)' && (r.nome||'') !== fNome) return false;

        if (fStatus !== '(todos)' && !eqi(r.status||'', fStatus)) return false;

        const isNac = parseBool(r.isNacional);
        if (fNac === 'Sim' && !isNac) return false;
        if (fNac === 'Não' && isNac) return false;

        if (fNac === 'Sim' && fAcao !== '(todas)' && !eqi(r.acaoNome||'', fAcao)) return false;

        if (!inDateRange(r.ini||'', r.fim||'', fIni||'', fFim||'')) return false;

        return true;
      });

      renderRows(filtered);
    }catch(e){
      console.error(e);
      tbody.innerHTML = `<tr><td colspan="13" class="hint">Erro ao filtrar.</td></tr>`;
    }finally{
      setBusy(false);
    }
  }

  function clearFilters(){
    if (selRegional) selRegional.value = '(todas)';
    if (selNomeBox)  selNomeBox.value  = '(todas)';
    if (inpIni)      inpIni.value      = '';
    if (inpFim)      inpFim.value      = '';
    if (selStatus)   selStatus.value   = '(todos)';
    if (selNac)      selNac.value      = '(ambos)';
    if (selAcao)     selAcao.value     = '(todas)';
    updateAcaoEnabled();
    renderHint();
  }

  // Abre o modal e prepara selects
  async function openFiltro(){
    // Regionais (agora carregadas do jobs.csv)
    await loadRegionaisToSelect();

    // Nome do tabloide (SELECT com acentos OK)
    const nomeSel = ensureNomeSelect();
    await loadNomeTabloideOptions(nomeSel, '(todas)');

    // Ações nacionais
    await loadAcoesToSelect('(todas)');

    updateAcaoEnabled();
    renderHint();
    dlg?.showModal();
  }

  /* ====== Binds ====== */
  if (btnOpen)  btnOpen.addEventListener('click', openFiltro);
  if (btnClose) btnClose.addEventListener('click', ()=> dlg?.close());
  if (btnClear) btnClear.addEventListener('click', clearFilters);
  if (btnApply) btnApply.addEventListener('click', applyFilters);
  if (selNac)   selNac.addEventListener('change', updateAcaoEnabled);

  // Clique no "..." de Filial(s) abre o modal de detalhe (reaproveita #modalCell)
  (function wireCellModal(){
    const cellDlg   = document.getElementById('modalCell');
    const cellTitle = document.getElementById('cellTitle');
    const cellBody  = document.getElementById('cellBody');
    if (!tbody || !cellDlg) return;
    tbody.addEventListener('click',(e)=>{
      const clip = e.target.closest('.clip');
      if(!clip) return;
      cellTitle.textContent = clip.getAttribute('data-field') || 'Detalhes';
      cellBody.textContent  = clip.getAttribute('data-full') || '';
      cellDlg.showModal();
    });
  })();

})();
</script>

<!-- ============ BOTÃO FILTRAR — configuração completa (abre modal, lista ações, aplica filtros) ============ FIM -->




<// ARTE + MODAL + BOTAO STATUS EM MASSA ---------------------------------- INICIO>

<!-- ==================== ETAPAS EM MASSA (botão + modal + status + lógica completa) ==================== -->
<dialog id="modalEtapasMassa">
  <form method="dialog" class="modal" id="formEtapasMassa">
    <h3>Etapas em massa</h3>

    <div class="grid" style="margin-bottom:8px">
      <div class="col-4">
        <label>Regional</label>
        <select id="emRegional">
          <option value="(todas)">(todas)</option>
          <option>REGIONAL BA - SE</option>
          <option>REGIONAL DF - GO - TO</option>
          <option>REGIONAL MG</option>
          <option>REGIONAL MS</option>
          <option>REGIONAL MT - RO - AC</option>
          <option>REGIONAL NORDESTE 1</option>
          <option>REGIONAL NORDESTE 2</option>
          <option>REGIONAL NORTE</option>
          <option>REGIONAL PR</option>
          <option>REGIONAL RJ - ES</option>
          <option>REGIONAL RS</option>
          <option>REGIONAL SP</option>
          <option>REGIONAL SC</option>
        </select>
      </div>
      <div class="col-5">
        <label>Nome do tabloide</label>
        <select id="emNome">
          <option value="(todos)">(todos)</option>
        </select>
        <div class="muted">Nomes carregados de <strong>nome_tabloide.csv</strong>.</div>
      </div>
      <div class="col-3">
        <label>Status</label>
        <select id="emStatus">
          <option value="(todos)">(todos)</option>
          <option>Novo</option>
          <option>Lista recebida</option>
          <option>Criando layout</option>
          <option>Digitando</option>
          <option>Diagramando</option>
          <option>Revisando</option>
          <option>Aprovado</option>
          <option>Encerrando</option>
          <option>Site</option>
          <option>Cancelado</option>
          <option>Finalizado</option>
        </select>
      </div>
    </div>

    <div class="frow" style="justify-content:flex-end">
      <button class="btn" type="button" id="emAplicar">Aplicar filtros</button>
      <button class="btn" type="button" id="emSelTodos">Selecionar todos</button>
      <button class="btn" type="button" id="emSelNenhum">Limpar seleção</button>
      <button class="btn primary" type="button" id="emAvancar" disabled>Avançar etapa</button>
    </div>

    <div class="list" style="margin-top:8px; max-height:55vh; overflow:auto">
      <table>
        <thead>
          <tr>
            <th style="width:36px"></th>
            <th>OT</th>
            <th>Regional</th>
            <th>Nome do tabloide</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="emList">
          <tr><td colspan="5" class="hint">Aplique os filtros para listar os jobs.</td></tr>
        </tbody>
      </table>
    </div>

    <div class="actions">
      <button class="btn" type="button" id="emFechar">Fechar</button>
    </div>
  </form>
</dialog>

<script>
(function(){
  /* ====== injeta botão ao lado do Dashboard ====== */
  (function ensureBtn(){
    const actions = document.getElementById('actions');
    if(!actions) return;
    if(document.getElementById('btnEtapasMassa')) return;
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.id = 'btnEtapasMassa';
    btn.textContent = 'Etapas em massa';
    const ref = document.getElementById('btnDash') || actions.lastElementChild;
    ref ? ref.after(btn) : actions.appendChild(btn);
  })();

  /* ====== Config GitHub ====== */
  const GH = {
    owner:'JPVectorsitem',
    repo:'LINKS-img',
    branch:'main',
    jobsPath:'jobs.csv',
    nomesPath:'nome_tabloide.csv',
    usersPath:'users.csv'
  };

  /* ====== Helpers UI/CSV/GitHub ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json();
    return { text: j && j.content ? b64ToUtf8(j.content) : '', sha: j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    // get current sha
    let sha=null;
    try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message: message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== DOM Refs ====== */
  const btnOpen  = document.getElementById('btnEtapasMassa');
  const dlg      = document.getElementById('modalEtapasMassa');
  const btnClose = document.getElementById('emFechar');
  const btnApply = document.getElementById('emAplicar');
  const btnAll   = document.getElementById('emSelTodos');
  const btnNone  = document.getElementById('emSelNenhum');
  const btnNext  = document.getElementById('emAvancar');

  const selRegional = document.getElementById('emRegional');
  const selNome     = document.getElementById('emNome');
  const selStatus   = document.getElementById('emStatus');
  const tbody       = document.getElementById('emList');

  /* ====== seleção: util ====== */
  function getSelectedOTs(){
    return [...tbody.querySelectorAll('input[type="checkbox"][data-ot]:checked')]
      .map(b => (b.getAttribute('data-ot')||'').trim())
      .filter(v => v.length > 0);
  }
  function refreshSelectionState(){
    const n = getSelectedOTs().length;
    if(btnNext){
      btnNext.disabled = n === 0;
      btnNext.title = n ? '' : 'Selecione ao menos 1 job';
    }
  }

  /* ====== Nomes (nome_tabloide.csv) com acento OK ====== */
  async function loadNomesTabloide(){
    try{
      const { text } = await ghGetFile(GH.nomesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      const key = (header.find(h => h.toLowerCase().includes('nome')) || header[0] || 'nome');
      const nomes = [...new Set(rows.map(r => (r[key]||'').trim()).filter(Boolean))]
        .sort((a,b)=> a.localeCompare(b, 'pt-BR'));
      selNome.innerHTML = '';
      const optAll = document.createElement('option'); optAll.value='(todos)'; optAll.textContent='(todos)'; selNome.appendChild(optAll);
      nomes.forEach(n=>{
        const o=document.createElement('option');
        o.value=n; o.textContent=n; selNome.appendChild(o);
      });
    }catch(e){
      console.error(e);
      selNome.innerHTML = '<option value="(todos)">(todos)</option>';
    }
  }

  /* ====== Filtro + Lista ====== */
  async function applyFilters(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    setBusy(true, 'Carregando jobs…');
    try{
      const reg = (selRegional?.value||'(todas)').trim();
      const nomeSel = (selNome?.value||'(todos)').trim();
      const statusSel = (selStatus?.value||'(todos)').trim().toLowerCase();

      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { header:H, rows } = csvToObjsAndHeader(text);

      const out = rows.filter(r=>{
        const okReg = (reg==='(todas)') || ((r.regional||'').trim()===reg);
        const okNom = (nomeSel==='(todos)') || ((r.nome||'').trim()===nomeSel);
        const okSta = (statusSel==='(todos)') || ((r.status||'').trim().toLowerCase()===statusSel);
        return okReg && okNom && okSta;
      }).sort((a,b)=> (a.ot||'').localeCompare(b.ot||'', undefined, {numeric:true, sensitivity:'base'}));

      if(!out.length){
        tbody.innerHTML = `<tr><td colspan="5" class="hint">Nenhum job encontrado com esses filtros.</td></tr>`;
        refreshSelectionState();
        return;
      }

      const frag = document.createDocumentFragment();
      out.forEach(r=>{
        const ot = (r.ot||'').trim();
        const hasOT = ot.length > 0;
        const id = 'em_'+(ot ? ot.replace(/[^a-z0-9]/gi,'_') : Math.random().toString(36).slice(2));
        const tr = document.createElement('tr');
        const td0 = document.createElement('td');
        const cb  = document.createElement('input');
        cb.type='checkbox';
        cb.setAttribute('data-ot', hasOT ? ot : '');
        if(!hasOT) cb.disabled = true;
        cb.id = id;
        td0.appendChild(cb);

        const td1 = document.createElement('td'); td1.textContent = ot || '—';
        const td2 = document.createElement('td'); td2.textContent = r.regional||'—';
        const td3 = document.createElement('td'); td3.textContent = r.nome||'—';
        const td4 = document.createElement('td'); td4.textContent = r.status||'—';

        tr.appendChild(td0); tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4);
        frag.appendChild(tr);
      });
      tbody.innerHTML = '';
      tbody.appendChild(frag);

      refreshSelectionState();
    }catch(e){
      console.error(e);
      tbody.innerHTML = `<tr><td colspan="5" class="hint">Erro ao carregar jobs.</td></tr>`;
      refreshSelectionState();
    }finally{
      setBusy(false);
    }
  }

  /* ====== Batch: abre modal do "+" já preparado ====== */
  async function openBatchEvtForTargets(ots){
    if(!ots.length){ toast('Seleção inválida. Marque ao menos um job.'); return; }

    async function loadUsersByRole(){
      const { text } = await ghGetFile(GH.usersPath, GH.branch);
      const { rows } = csvToObjsAndHeader(text);
      const roles = ['Layout','Digitador','Diagramador','Revisor','Encerramento','Site'];
      const by = {}; roles.forEach(r=> by[r]=[]);
      rows.forEach(u=>{
        const p=(u.cargo_principal||u.cargo||'').trim();
        const s=(u.cargo_secundaria||'').trim();
        roles.forEach(r=>{
          if (p.toLowerCase()===r.toLowerCase() || s.toLowerCase()===r.toLowerCase()){
            by[r].push(u.nome||'');
          }
        });
      });
      roles.forEach(r=> by[r] = [...new Set(by[r])].filter(Boolean).sort((a,b)=>a.localeCompare(b,'pt-BR')));
      return by;
    }

    function renderEvtFields(byRole, count){
      const addFields = document.getElementById('addEvtFields');
      const addTitle  = document.getElementById('addEvtTitle');
      if(addTitle) addTitle.textContent = count>1 ? `Adicionar evento (+) — ${count} selecionados` : 'Adicionar evento (+)';
      if(!addFields) return;

      const stepOpts = [
        ['lista','Lista'],
        ['aprovacao','Aprovação'],
        ['cancelado','Cancelado'],
        ['layout','Layout'],
        ['digitacao','Digitação'],
        ['diagramacao','Diagramação'],
        ['revisao','Revisão'],
        ['encerramento','Encerramento'],
        ['site','Site']
      ].map(([v,l])=> `<option value="${v}">${l}</option>`).join('');

      addFields.innerHTML = `
        <div class="field">
          <label>Etapa</label>
          <select id="evtStep">${stepOpts}</select>
          <div class="muted">${count>1 ? `Esta ação será aplicada em <strong>${count}</strong> job(s).` : ''}</div>
        </div>
        <div id="evtWhoWrap" class="field">
          <label>Responsável</label>
          <input id="evtWhoText" type="text" placeholder="Nome do responsável" />
          <select id="evtWhoSel" style="display:none"></select>
          <div class="muted" id="evtHint"></div>
        </div>
      `;

      const selStep = addFields.querySelector('#evtStep');
      const inpText = addFields.querySelector('#evtWhoText');
      const selWho  = addFields.querySelector('#evtWhoSel');
      const hint    = addFields.querySelector('#evtHint');

      function applyRoleUI(stepKey){
        const mapRole = {
          layout:'Layout', digitacao:'Digitador', diagramacao:'Diagramador',
          revisao:'Revisor', encerramento:'Encerramento', site:'Site'
        };
        const role = mapRole[stepKey] || null;
        if (!role){
          selWho.style.display='none';
          inpText.style.display='block';
          inpText.value='';
          hint.textContent = 'Digite o nome manualmente.';
        } else {
          const list = byRole[role] || [];
          selWho.innerHTML = list.length ? list.map(n=>`<option>${n.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</option>`).join('') : '<option>(sem nomes para este cargo)</option>';
          selWho.style.display='block';
          inpText.style.display='none';
          hint.innerHTML = `Selecione alguém do cargo <strong>${role}</strong>.`;
        }
      }
      selStep.addEventListener('change', ()=> applyRoleUI(selStep.value));
      applyRoleUI(selStep.value);
    }

    try{
      setBusy(true,'Preparando…');
      const byRole = await loadUsersByRole();
      window.__evtBatchTargets = ots.slice(); // alvos da ação em massa
      renderEvtFields(byRole, ots.length);
      document.getElementById('modalAddEvt')?.showModal();
    }catch(e){
      console.error(e);
      toast('Falha ao abrir a etapa em massa.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== Aplica SALVAR do modal "+" em lote (sem quebrar comportamento atual) ====== */
  (function hookBatchOk(){
    const ok = document.getElementById('btnAddEvtOk');
    if(!ok) return; // modal ainda não no DOM, mas no seu HTML original ele existe

    // evita duplicar
    if(ok.__batchHookAttached) return;
    ok.__batchHookAttached = true;

    ok.addEventListener('click', async (e)=>{
      const targets = Array.isArray(window.__evtBatchTargets) ? window.__evtBatchTargets : [];
      if(!targets.length) return; // deixa o handler original tratar o modo single

      e.stopImmediatePropagation();
      e.preventDefault();

      const fields = document.getElementById('addEvtFields');
      const step = fields?.querySelector('#evtStep')?.value || 'lista';
      const whoText = fields?.querySelector('#evtWhoText');
      const whoSel  = fields?.querySelector('#evtWhoSel');
      let nomeResp = '';
      // se select visível, usa select; senão usa texto
      if(whoSel && whoSel.style.display !== 'none') nomeResp = (whoSel.value||'').trim();
      else nomeResp = (whoText?.value||'').trim();
      if(!nomeResp){ toast('Informe o responsável.'); return; }

      // mapeia step -> status
      const STEP_STATUS = {
        lista:'Lista recebida',
        aprovacao:'Aprovado',
        cancelado:'Cancelado',
        layout:'Criando layout',
        digitacao:'Digitando',
        diagramacao:'Diagramando',
        revisao:'Revisando',
        encerramento:'Encerrando',
        site:'Site'
      };

      function nowISO(){ return new Date().toISOString(); }
      function statusToClass(status){
        const s=(status||'').toLowerCase();
        if(s==='novo') return 'st-novo';
        if(s==='lista recebida') return 'st-lista';
        if(s==='criando layout') return 'st-layout';
        if(s==='digitando') return 'st-digitando';
        if(s==='diagramando') return 'st-diagramando';
        if(s==='revisando') return 'st-revisando';
        if(s==='aprovado') return 'st-aprovado';
        if(s==='encerrando') return 'st-encerrando';
        if(s==='site') return 'st-site';
        if(s==='cancelado') return 'st-cancelado';
        if(s==='finalizado') return 'st-finalizado';
        return '';
      }
      function parseLogs(raw){
        try{ const j=JSON.parse(raw||'{}'); return j && typeof j==='object' ? j : {}; }catch{ return {}; }
      }

      if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

      setBusy(true, 'Salvando…');
      try{
        const { text } = await ghGetFile(GH.jobsPath, GH.branch);
        const { header:H, rows } = csvToObjsAndHeader(text);
        if(!H.length){ toast('Estrutura de jobs.csv inválida.'); setBusy(false); return; }

        const byOT = new Map(rows.map(r=>[String(r.ot||'').trim(), r]));
        const ev = { nome:nomeResp, ts: nowISO() };
        const newStatus = STEP_STATUS[step] || 'Novo';

        // atualiza objetos em memória
        targets.forEach(ot=>{
          const r = byOT.get(String(ot).trim());
          if(!r) return;
          const logs = parseLogs(r.logs);
          if(!Array.isArray(logs[step])) logs[step] = [];
          logs[step].push(ev);
          r.logs = JSON.stringify(logs);
          r.status = newStatus;
          r.statusStep = step;
          r.atualizado_em = nowISO();
        });

        // re-monta CSV
        const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
        const toCsvLine=o=> H.map(k=> csvEsc(o[k] ?? '')).join(',');
        const newText = H.join(',')+'\n'+rows.map(toCsvLine).join('\n')+'\n';
        await ghPutFile(GH.jobsPath, newText, `chore(csv): batch etapa (${targets.length})`);

        // atualiza UI (cores e texto do status)
        targets.forEach(ot=>{
          const tr = document.querySelector(`#jobsBody tr[data-ot="${CSS.escape(ot)}"]`);
          if(!tr) return;
          // limpa classes status antigas
          tr.className = tr.className.replace(/\bst\-[a-z]+/g,'').trim();
          tr.classList.add(statusToClass(newStatus));
          // coluna STATUS é a 13ª (0-index 12)
          const tdStatus = tr.children && tr.children[12];
          if(tdStatus) tdStatus.textContent = newStatus;
        });

        // fecha modal +
        document.getElementById('modalAddEvt')?.close();
        window.__evtBatchTargets = []; // limpa
        toast(`Etapa aplicada em ${targets.length} job(s).`);
      }catch(err){
        console.error(err);
        toast('Erro ao salvar alteração em lote.');
      }finally{
        setBusy(false);
      }
    });
  })();

  /* ====== binds ====== */
  if(btnOpen && dlg){
    btnOpen.addEventListener('click', async ()=>{
      try{ await loadNomesTabloide(); }catch{}
      tbody.innerHTML = `<tr><td colspan="5" class="hint">Aplique os filtros para listar os jobs.</td></tr>`;
      refreshSelectionState();
      dlg.showModal();
    });
  }
  if(btnClose && dlg) btnClose.addEventListener('click', ()=> dlg.close());
  if(btnApply) btnApply.addEventListener('click', applyFilters);

  // seleção
  if(btnAll)  btnAll.addEventListener('click', ()=>{
    tbody.querySelectorAll('input[type="checkbox"][data-ot]:not(:disabled)').forEach(b=> b.checked = true);
    refreshSelectionState();
  });
  if(btnNone) btnNone.addEventListener('click', ()=>{
    tbody.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked = false);
    refreshSelectionState();
  });
  tbody.addEventListener('change', (e)=>{
    if(e.target && e.target.matches('input[type="checkbox"][data-ot]')) refreshSelectionState();
  });

  if(btnNext){
    btnNext.addEventListener('click', ()=>{
      const sel = getSelectedOTs();
      if(!sel.length){
        toast('Seleção inválida. Marque ao menos um job.');
        refreshSelectionState();
        return;
      }
      openBatchEvtForTargets(sel);
    });
    refreshSelectionState();
  }
})();
</script>

<!-- ==================== /ETAPAS EM MASSA ==================== FIM -->

<//!OTIMIZAÇÃO LEITURA + GRAVAÇÃO ------>

<script>
(function(){
  "use strict";

  // Namespace único
  window.WV = window.WV || {};
  const GH = (WV.cfg && WV.cfg.GH) || {
    owner: 'JPVectorsitem',
    repo:  'LINKS-img',
    branch:'main',
    jobsPath: 'jobs.csv'
  };

  /* ===================== Utils ===================== */
  function getToken(){
    try{
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}');
      return (window.gh && window.gh.token) || saved.token || '';
    }catch{ return (window.gh && window.gh.token) || ''; }
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  function b64ToUtf8(b64){
    const bin=atob(b64); const bytes=new Uint8Array(bin.length);
    for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});

  // CSV helpers pra quem quiser usar WV.sync.pushCsv(head, rows)
  const csvEsc = v => {
    v = v==null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  const toCsv   = (H, rows) => H.join(',')+'\n' + rows.map(o => H.map(k=>csvEsc(o[k]??'')).join(',')).join('\n') + '\n';
  WV.csv = WV.csv || { toCsv, csvEsc };

  /* =================== Sync Engine ================== */
  WV.sync = (function(){
    let readTimer=null, writeTimer=null;
    let readEvery=1000, writeEvery=1000;

    let jobsEtag=null, jobsSha=null, lastText=null;
    let reading=false, writing=false;
    let started=false;

    // Backoff (auto-ajuste de intervalo quando der erro/limite)
    let readBackoff=1, writeBackoff=1;          // multiplicadores
    const BMIN=1, BMAX=15;                      // 1x..15x
    const BASE_READ=1000, BASE_WRITE=1000;      // ms base
    const HIDDEN_READ=3500;                     // quando aba oculta

    const writeQueue=[]; // coalesce (sempre usa o último CSV enfileirado)

    async function ghGetFileWithETag(path){
      const token = getToken();
      if(!token) throw new Error('Token GitHub não configurado.');

      const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(GH.branch)}`;
      const headers = ghHeaders(token);
      if(jobsEtag) headers['If-None-Match'] = jobsEtag;

      const r = await fetch(url, { headers });
      if(r.status === 304) return { notModified:true }; // rápido

      if(!r.ok){
        const t = await r.text();
        throw new Error('GET '+r.status+': '+t);
      }

      const etag = r.headers.get('ETag') || null;
      const j = await r.json();
      // /contents => base64
      const text = j && j.content ? b64ToUtf8(j.content) : '';
      return { text, sha: j.sha || null, etag };
    }

    async function ghPutFile(path, newText){
      const token = getToken();
      if(!token) throw new Error('Token GitHub não configurado.');

      if(!jobsSha){
        const fresh = await ghGetFileWithETag(path);
        if(!fresh.notModified){
          jobsSha = fresh.sha || jobsSha;
          jobsEtag = fresh.etag || jobsEtag;
          lastText = (fresh.text!=null?fresh.text:lastText);
        }
      }

      const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
      const body = {
        message: `chore(csv): update ${path}`,
        content: utf8ToB64(newText),
        branch: GH.branch,
        ...(jobsSha ? { sha: jobsSha } : {})
      };
      const r = await fetch(url, { method:'PUT', headers:{...ghHeaders(token),'Content-Type':'application/json'}, body: JSON.stringify(body) });
      const txt = await r.text();
      if(!r.ok) throw new Error('PUT '+r.status+': '+txt);

      let newSha=null;
      try{ const j=JSON.parse(txt); newSha=j?.content?.sha||null; }catch{}
      return { sha:newSha };
    }

    function scheduleLoops(){
      clearInterval(readTimer); clearInterval(writeTimer);
      const isHidden = document.hidden;
      const re = Math.max(250, (isHidden? HIDDEN_READ : BASE_READ) * readBackoff);
      const we = Math.max(250, BASE_WRITE * writeBackoff);
      readEvery = re; writeEvery = we;

      readTimer  = setInterval(readTick,  re);
      writeTimer = setInterval(writeTick, we);
    }

    async function readTick(){
      if(reading) return;
      reading = true;
      try{
        const res = await ghGetFileWithETag(GH.jobsPath);
        if(res.notModified){ readBackoff = Math.max(BMIN, readBackoff * 0.9); return; } // estabiliza para 304
        // Mudou:
        lastText = res.text;
        if(res.sha)  jobsSha  = res.sha;
        if(res.etag) jobsEtag = res.etag;

        // dispara atualização de UI (usa seu loader existente)
        if(typeof WV.onJobsFileUpdate === 'function'){
          WV.onJobsFileUpdate(lastText);
        }else if(typeof window.loadJobsFromGitHub === 'function'){
          window.loadJobsFromGitHub();
        }
        readBackoff = Math.max(BMIN, readBackoff * 0.8);
      }catch(e){
        // 403/429 -> aumenta backoff (evita rate limit)
        if(String(e).includes('403') || String(e).includes('429')) readBackoff = Math.min(BMAX, readBackoff*1.75);
        else readBackoff = Math.min(BMAX, readBackoff*1.35);
        scheduleLoops();
        // console.warn('[sync] read error', e);
      }finally{ reading=false; }
    }

    async function writeTick(){
      if(writing) return;
      if(writeQueue.length===0) return;
      writing = true;

      // coalesce: pega o último CSV
      const item = writeQueue.splice(0, writeQueue.length).pop();

      try{
        const { sha } = await ghPutFile(GH.jobsPath, item.text);
        if(sha) jobsSha = sha;
        writeBackoff = Math.max(BMIN, writeBackoff * 0.8);
        // leitura imediata pra alinhar ETag/sha/UI
        await readTick();
      }catch(err){
        const msg = String(err||'');
        if(msg.includes('409')){ // conflito: refaz SHA e tenta 1x
          try{
            const fresh = await ghGetFileWithETag(GH.jobsPath);
            if(!fresh.notModified){
              jobsSha = fresh.sha || jobsSha;
              jobsEtag = fresh.etag || jobsEtag;
              lastText = (fresh.text!=null?fresh.text:lastText);
            }
            const { sha } = await ghPutFile(GH.jobsPath, item.text);
            if(sha) jobsSha = sha;
            writeBackoff = Math.max(BMIN, writeBackoff * 0.9);
            await readTick();
          }catch(e2){
            writeBackoff = Math.min(BMAX, writeBackoff*1.5);
          }
        }else{
          // 403/429 = limite -> aumenta backoff
          if(msg.includes('403') || msg.includes('429')) writeBackoff = Math.min(BMAX, writeBackoff*1.8);
          else writeBackoff = Math.min(BMAX, writeBackoff*1.3);
        }
        scheduleLoops();
      }finally{ writing=false; }
    }

    function enqueueWrite(csvText){
      if(typeof csvText==='string'){
        writeQueue.push({ text: csvText });
      }
    }

    function start(opts={}){
      if(started) return;
      started=true;
      // quando token surgir (depois que o usuário salvar no modal ⚙), inicia
      const boot = () => {
        if(!getToken()){ setTimeout(boot, 400); return; }
        // Primeira leitura imediata e loops
        readTick().finally(scheduleLoops);
      };
      boot();

      // Ajustes live se o tab ficar oculto/visível
      document.addEventListener('visibilitychange', scheduleLoops);
      // Se alguém mudar o token em outra aba
      window.addEventListener('storage', (e)=>{ if(e.key==='wv_gh_cfg') scheduleLoops(); });

      // ajustes opcionais do usuário
      if(opts.readEveryMs)  { /* mantemos base e o backoff cuida */ }
      if(opts.writeEveryMs) { /* idem */ }
    }

    function stop(){
      clearInterval(readTimer); clearInterval(writeTimer);
      readTimer=writeTimer=null; started=false;
    }

    return { start, stop, enqueueWrite, toCsv };
  })();

  /* =========== Auto-start: liga sozinho =========== */
  // Vai iniciar assim que o token existir.
  WV.sync.start();

  // OPCIONAL: se você, em algum lugar, montar o CSV e quiser salvar via fila rápida:
  // WV.sync.enqueueWrite(WV.csv.toCsv(head, rows));

})();
</script>
<//!OTIMIZAÇÃO LEITURA + GRAVAÇÃO ---- FIM>

<//! PERSISTENCIA LOGIN 20 min ---->

<script>
(function(){
  "use strict";

  // ======= Config =======
  const IDLE_MS = 20 * 60 * 1000; // 20 minutos

  // ======= Elementos =======
  const loginView = document.getElementById('loginView');
  const jobsApp   = document.getElementById('jobsApp');
  const elUserName= document.getElementById('userName');
  const chip1     = document.getElementById('cargo1');
  const chip2     = document.getElementById('cargo2');
  const btnSair   = document.getElementById('btnSair');
  const inpEmail  = document.getElementById('email');
  const inpSenha  = document.getElementById('senha');
  const toastEl   = document.getElementById('toast');

  // ======= Helpers UI =======
  function toast(msg){
    if(!toastEl) return;
    toastEl.textContent = msg;
    toastEl.style.display = 'block';
    setTimeout(()=> toastEl.style.display='none', 2200);
  }
  function roleKey(c){
    const k=(c||'').trim().toLowerCase();
    if(['administrador','administrator','diretor','gerente'].includes(k)) return 'prata';
    if(k==='trafego') return 'verde';
    if(k==='layout') return 'roxo';
    if(k==='digitador') return 'azul';
    if(k==='diagramador') return 'laranja';
    if(k==='revisor') return 'rosa';
    if(k==='encerramento') return 'amarelo';
    if(k==='site') return 'roxoclaro';
    return 'prata';
  }

  function showJobsUI(user){
    if (elUserName) elUserName.textContent = user?.nome || '—';

    if (chip1) {
      const c1 = user?.cargo_principal || user?.cargo || '';
      if (c1) {
        chip1.textContent = c1;
        chip1.className = 'role-chip role-' + roleKey(c1);
        chip1.style.display = 'inline-block';
      } else chip1.style.display = 'none';
    }
    if (chip2) {
      const c2 = user?.cargo_secundaria || '';
      if (c2) {
        chip2.textContent = c2;
        chip2.className = 'role-chip role-' + roleKey(c2);
        chip2.style.display = 'inline-block';
      } else chip2.style.display = 'none';
    }

    if (loginView) { loginView.classList.add('hide'); loginView.setAttribute('aria-hidden','true'); }
    if (jobsApp)   { jobsApp.classList.remove('hide'); jobsApp.setAttribute('aria-hidden','false'); }

    if (typeof window.applyPermissions === 'function') window.applyPermissions();
    // dispara seus carregadores, se precisar
    if (typeof window.TurboJobs?.mount === 'function') {
      window.TurboJobs.mount().catch(()=>{});
    } else if (typeof window.loadJobsFromGitHub === 'function' && typeof window.insertJobRow === 'function') {
      window.loadJobsFromGitHub();
    }
  }

  function showLoginUI(reason){
    // reseta cabeçalho do usuário
    if (elUserName) elUserName.textContent = '—';
    if (chip1) { chip1.style.display = 'none'; chip1.textContent = ''; }
    if (chip2) { chip2.style.display = 'none'; chip2.textContent = ''; }

    if (jobsApp)   { jobsApp.classList.add('hide'); jobsApp.setAttribute('aria-hidden','true'); }
    if (loginView) { loginView.classList.remove('hide'); loginView.setAttribute('aria-hidden','false'); }

    if (inpSenha) inpSenha.value = '';
    if (inpEmail) inpEmail.focus();

    if (reason === 'idle') toast('Sessão expirada por inatividade (20 min).');
  }

  // ======= Persistência =======
  const SKEY = 'wv_session';
  function saveSession(user){
    const data = {
      isLoggedIn: true,
      user: {
        nome: user?.nome || '',
        cargo_principal: user?.cargo_principal || user?.cargo || '',
        cargo_secundaria: user?.cargo_secundaria || ''
      },
      lastActivity: Date.now(),
      loggedInAt: Date.now()
    };
    localStorage.setItem(SKEY, JSON.stringify(data));
  }
  function loadSession(){
    try{
      const j = JSON.parse(localStorage.getItem(SKEY) || '{}');
      if(j && j.isLoggedIn && j.user) return j;
    }catch{}
    return null;
  }
  function clearSession(){
    localStorage.removeItem(SKEY);
  }
  function touchActivity(){
    const s = loadSession();
    if(!s) return;
    s.lastActivity = Date.now();
    localStorage.setItem(SKEY, JSON.stringify(s));
  }

  // ======= Idle Timer =======
  let idleTimer = null;
  function scheduleIdleCheck(){
    clearTimeout(idleTimer);
    const s = loadSession();
    if(!s || !s.isLoggedIn) return;
    const remain = Math.max(0, IDLE_MS - (Date.now() - (s.lastActivity||Date.now())));
    idleTimer = setTimeout(()=> doLogout('idle'), remain || 0);
  }

  // ======= Login/Logout de verdade =======
  function doLoginFromCurrentUser(){
    // usa o que seu fluxo já definiu
    const u = window.currentUser;
    if(!u) return;
    window.currentUser = {
      nome: u.nome || '',
      cargo_principal: u.cargo_principal || u.cargo || '',
      cargo_secundaria: u.cargo_secundaria || ''
    };
    saveSession(window.currentUser);
    showJobsUI(window.currentUser);
    touchActivity();
    scheduleIdleCheck();
  }

  function doLoginFromStored(){
    const s = loadSession();
    if(!s || !s.isLoggedIn) return false;
    window.currentUser = {
      nome: s.user?.nome || '',
      cargo_principal: s.user?.cargo_principal || '',
      cargo_secundaria: s.user?.cargo_secundaria || ''
    };
    showJobsUI(window.currentUser);
    touchActivity();           // ao entrar/refresh, reseta o cronômetro
    scheduleIdleCheck();
    return true;
    }

  function doLogout(reason){
    clearSession();
    window.currentUser = null;
    showLoginUI(reason);
  }

  // ======= Observa o momento do login do seu fluxo =======
  // Quando #jobsApp ficar visível e houver window.currentUser,
  // persistimos a sessão (útil quando o login acontece pelo botão).
  if (jobsApp){
    const mo = new MutationObserver(() => {
      const visible = !jobsApp.classList.contains('hide') && jobsApp.getAttribute('aria-hidden') !== 'true';
      if (visible && window.currentUser && loadSession()?.isLoggedIn !== true){
        doLoginFromCurrentUser();
      }
    });
    mo.observe(jobsApp, { attributes: true, attributeFilter: ['class','aria-hidden'] });
  }

  // ======= Captura atividades do usuário =======
  const ACT_EVENTS = ['pointerdown','keydown','mousemove','scroll','touchstart','wheel'];
  const onAct = () => { touchActivity(); scheduleIdleCheck(); };
  ACT_EVENTS.forEach(ev => window.addEventListener(ev, onAct, { passive:true }));
  document.addEventListener('visibilitychange', () => {
    // se voltou pra aba depois de muito tempo, checa expiração
    const s = loadSession();
    if(!s || !s.isLoggedIn) return;
    if (document.visibilityState === 'visible') {
      const passed = Date.now() - (s.lastActivity || 0);
      if (passed >= IDLE_MS) {
        doLogout('idle');
      } else {
        onAct();
      }
    }
  });

  // ======= Sincroniza entre abas =======
  window.addEventListener('storage', (e)=>{
    if(e.key !== SKEY) return;
    const s = loadSession();
    if(!s || !s.isLoggedIn){
      // logout em outra aba
      showLoginUI();
      window.currentUser = null;
      clearTimeout(idleTimer);
    }else{
      // login/refresh em outra aba
      window.currentUser = {
        nome: s.user?.nome || '',
        cargo_principal: s.user?.cargo_principal || '',
        cargo_secundaria: s.user?.cargo_secundaria || ''
      };
      showJobsUI(window.currentUser);
      scheduleIdleCheck();
    }
  });

  // ======= Integra com seu botão "Sair" (garante limpar storage) =======
  if (btnSair){
    btnSair.addEventListener('click', () => {
      // deixa seu handler atual cuidar da UI; nós só limpamos a sessão
      clearSession();
    }, { passive:true });
  }

  // ======= Bootstrap: tenta restaurar sessão ao abrir/atualizar =======
  // se existir sessão salva, entra direto e reseta o timer
  doLoginFromStored();

  // expõe um mini-API opcional
  window.WV = window.WV || {};
  window.WV.session = {
    logout: () => doLogout('manual'),
    touch:  onAct,
    isLogged: () => !!(loadSession() && loadSession().isLoggedIn),
    getUser: () => (loadSession()?.user || null),
    IDLE_MS
  };
})();
</script>

<//! PERSISTENCIA LOGIN 20 min FIM ---->

<//!PREMISSÕES SEPARADOS POR CARGOS ---->

<script>
(function(){
  "use strict";

  // ========= util: normalização de cargos =========
  const ACCENT = (s)=> String(s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().trim();
  const ROLE_ALIAS = new Map([
    ['administrador','administrador'], ['adminstrador','administrador'], ['administrator','administrador'],
    ['diretor','diretor'], ['gerente','gerente'],
    ['trafego','trafego'], ['tráfego','trafego'],
    ['layout','layout'], ['digitador','digitador'],
    ['diagramador','diagramador'], ['diagramação','diagramador'], ['diagramacao','diagramador'],
    ['revisor','revisor'], ['encerramento','encerramento'], ['site','site']
  ]);
  const canonRole = (name)=> ROLE_ALIAS.get(ACCENT(name)) || ACCENT(name);

  function getUserRoles(){
    const u = (window.currentUser || {});
    const r1 = canonRole(u.cargo_principal || u.cargo || '');
    const r2 = canonRole(u.cargo_secundaria || '');
    const roles = [r1, r2].filter(Boolean);
    return Array.from(new Set(roles));
  }

  // ========= conjuntos =========
  const ROLESETS = {
    TOTAL: ['administrador','diretor','gerente','trafego'], // "permissão total"
  };

  // ========= botões (IDs) -> quem pode =========
  const ACTIONS = {
    btnNovo:            [...ROLESETS.TOTAL, 'layout'],
    btnDuplicar:        [...ROLESETS.TOTAL, 'layout'],
    btnEditar:          [...ROLESETS.TOTAL, 'layout'],
    btnFiltrar:         'ALL',
    btnDash:            'ALL',
    btnVerFinalizados:  [...ROLESETS.TOTAL, 'layout'],
    btnEtapasMassa:     [...ROLESETS.TOTAL],            // se o botão não existir, ignora
    btnFinalizar:       [...ROLESETS.TOTAL, 'site'],
    btnExcluir:         [...ROLESETS.TOTAL, 'layout'],
    btnEncerrar:        [...ROLESETS.TOTAL, 'encerramento'],
  };

  // ========= etapas por cargo (para quem NÃO é TOTAL) =========
  // IMPORTANTÍSSIMO: estas etapas de sistema são SOMENTE para TOTAL:
  const SYSTEM_ONLY_STEPS = new Set(['lista','aprovacao','cancelado']);

  const ROLE_TO_STEPS = {
    layout:       ['layout'],
    digitador:    ['digitacao'],
    diagramador:  ['diagramacao'],
    revisor:      ['revisao'],
    encerramento: ['encerramento'],
    site:         ['site'],
  };

  // ========= helpers perm =========
  function hasAny(required){
    const have = new Set(getUserRoles());
    return required.some(r => have.has(r));
  }
  function canAction(id){
    const rule = ACTIONS[id];
    if (!rule) return true;
    if (rule === 'ALL') return true;
    return hasAny(rule.map(canonRole));
  }
  function hasFullEtapas(){
    return hasAny(ROLESETS.TOTAL);
  }
  function allowedSteps(){
    if (hasFullEtapas()) {
      // TOTAL: tudo
      return new Set(['lista','aprovacao','cancelado','layout','digitacao','diagramacao','revisao','encerramento','site']);
    }
    // demais: apenas o(s) do(s) cargo(s) 1/2; NUNCA as de sistema
    const roles = getUserRoles();
    const allow = new Set();
    roles.forEach(r => (ROLE_TO_STEPS[r]||[]).forEach(s => allow.add(s)));
    // garante que as de sistema nunca entrem
    SYSTEM_ONLY_STEPS.forEach(s => allow.delete(s));
    return allow;
  }

  // expõe
  window.WV = window.WV || {};
  window.WV.perms = { rolesOf:getUserRoles, canAction, hasFullEtapas, allowedSteps };

  // ========= esconder botões sem permissão =========
  const BTN_IDS = [
    'btnNovo','btnDuplicar','btnEditar','btnFiltrar','btnDash','btnVerFinalizados',
    'btnEtapasMassa','btnFinalizar','btnExcluir','btnEncerrar'
  ];
  function hideEl(el, hide){
    if (!el) return;
    if (hide){
      if (el.style.display !== 'none'){
        el.dataset.prevDisplay = el.style.display || '';
        el.style.display = 'none';
      }
    } else {
      el.style.display = el.dataset.prevDisplay || '';
    }
  }
  function applyPermissions(){
    BTN_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      hideEl(el, !canAction(id));
    });
  }
  window.applyPermissions = applyPermissions;

  // aplica ao carregar / login
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyPermissions, { once:true });
  } else {
    applyPermissions();
  }

  // ========= controle do modal de ETAPAS (“+”) =========
  // bloqueio hard de clique em etapas não permitidas
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#etapasList [data-add-step]');
    if (!btn) return;
    const step = String(btn.getAttribute('data-add-step')||'').toLowerCase();

    const full = hasFullEtapas();
    const allow = allowedSteps();

    // sistema (lista/aprovacao/cancelado) só TOTAL
    if (SYSTEM_ONLY_STEPS.has(step) && !full){
      e.preventDefault(); e.stopPropagation();
      const t=document.getElementById('toast'); if(t){ t.textContent='Sem permissão para esta etapa.'; t.style.display='block'; setTimeout(()=>t.style.display='none',1600); }
      return;
    }
    // demais: precisa estar no allow
    if (!full && !allow.has(step)){
      e.preventDefault(); e.stopPropagation();
      const t=document.getElementById('toast'); if(t){ t.textContent='Sem permissão para esta etapa.'; t.style.display='block'; setTimeout(()=>t.style.display='none',1600); }
      return;
    }
  }, true);

  // ao abrir o modal, ESCONDER cartões de etapas sem permissão
  function restrictEtapasModalUI(){
    const dlg  = document.getElementById('modalEtapas');
    const list = document.getElementById('etapasList');
    if (!dlg || !dlg.open || !list) return;

    const full = hasFullEtapas();
    const allow = allowedSteps();

    list.querySelectorAll('.etapaCard').forEach(card => {
      const addBtn = card.querySelector('[data-add-step]');
      if (!addBtn) { hideEl(card, true); return; }
      const step = String(addBtn.getAttribute('data-add-step')||'').toLowerCase();

      let can = true;
      if (SYSTEM_ONLY_STEPS.has(step)) can = full; // sistema => só TOTAL
      else if (!full) can = allow.has(step);       // demais => conforme cargo

      hideEl(card, !can);
    });
  }

  // empacota openEtapasModal para aplicar quando abrir
  (function wrapOpenEtapas(){
    const tryWrap = () => {
      if (typeof window.openEtapasModal === 'function' && !window.openEtapasModal._wrapped){
        const orig = window.openEtapasModal;
        window.openEtapasModal = function(ot){
          const r = orig.call(this, ot);
          setTimeout(restrictEtapasModalUI, 0);
          return r;
        };
        window.openEtapasModal._wrapped = true;
      }
    };
    tryWrap();
    const obs = new MutationObserver(tryWrap);
    obs.observe(document.documentElement, { childList:true, subtree:true });
  })();

  // fallback: observar atributo open do dialog
  const dlgEtapas = document.getElementById('modalEtapas');
  if (dlgEtapas){
    const mo = new MutationObserver(restrictEtapasModalUI);
    mo.observe(dlgEtapas, { attributes:true, attributeFilter:['open'] });
  }

  // re-aplica se trocar usuário/sessão em localStorage
  window.addEventListener('storage', (e)=>{
    if (e.key === 'wv_session') setTimeout(()=>{ applyPermissions(); restrictEtapasModalUI(); }, 0);
  });

})();
</script>

<//!PREMISSÕES SEPARADOS POR CARGOS - FIM ---->

<!// AJUTES - Botão ver lojas + duplicar selecionados (visualizar finalizados) ---->
<script>
(function(){
  "use strict";

  /* =========================================================
   * 1) COLUNA "FILIAL(S)" => BOTÃO "VER LOJAS" (+ modal)
   * ========================================================= */

  function makeVerLojasButton(full){
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'btn small btnVerLojas';
    b.textContent = 'Ver lojas';
    b.setAttribute('data-full', (full||'').trim());
    b.title = 'Clique para ver todas as filiais';
    return b;
  }

  // Aplica ao TD (8ª coluna) do grid principal
  function decorateFiliaisTD(td){
    if (!td) return;
    // Se já virou botão, não refaz
    if (td.querySelector('.btnVerLojas')) return;

    // Pega conteúdo completo (prioriza data-full existente nos patches antigos)
    let full = '';
    const clip = td.querySelector('.clip[data-full]');
    if (clip) {
      full = clip.getAttribute('data-full') || '';
    } else {
      full = (td.textContent || '').trim();
    }

    // Se estiver vazio/traço, não vira botão
    if (!full || full === '—') return;

    // Substitui por botão
    td.textContent = '';
    td.appendChild(makeVerLojasButton(full));
  }

  // Decora todas as linhas do grid principal (#jobsBody)
  function decorateAllFiliaisMain(){
    const tbody = document.getElementById('jobsBody');
    if (!tbody) return;
    tbody.querySelectorAll('tr[data-ot]').forEach(tr=>{
      const td = tr.children && tr.children[7]; // 8ª coluna = Filial(s)
      if (td) decorateFiliaisTD(td);
    });
  }

  // Observa novas linhas no grid principal
  (function observeMainFiliais(){
    const tbody = document.getElementById('jobsBody');
    if (!tbody) return;
    const mo = new MutationObserver(muts=>{
      muts.forEach(m=>{
        m.addedNodes.forEach(n=>{
          if (n.nodeType===1 && n.matches('tr[data-ot]')) {
            const td = n.children && n.children[7];
            if (td) decorateFiliaisTD(td);
          }
        });
      });
    });
    mo.observe(tbody, { childList:true });
    decorateAllFiliaisMain();
  })();

  // Também aplica dentro do modal "Visualizar finalizados" (#finzList)
  function decorateAllFiliaisFinalizados(){
    const tbody = document.getElementById('finzList');
    if (!tbody) return;
    tbody.querySelectorAll('tr').forEach(tr=>{
      const td = tr.children && tr.children[7]; // 8ª col em "finalizados" é Filial(s)
      if (!td) return;

      // Se veio como .clip (do código anterior), converte em botão
      const clip = td.querySelector('.clip[data-full]');
      if (clip) {
        const full = clip.getAttribute('data-full')||'';
        td.textContent = '';
        td.appendChild(makeVerLojasButton(full));
      } else {
        // Caso futuro: se for texto direto
        decorateFiliaisTD(td);
      }
    });
  }

  // Quando abrir o modal de finalizados, faz a troca
  (function hookFinalizadosOpen(){
    const btn = document.getElementById('btnVerFinalizados');
    const dlg = document.getElementById('modalFinalizados');
    if (!btn || !dlg) return;
    btn.addEventListener('click', ()=>{
      // aguarda a tabela ser carregada pelo script existente e então decora
      setTimeout(decorateAllFiliaisFinalizados, 120);
    });
  })();

  // Clique no botão "Ver lojas" (vale para ambos os lugares)
  document.addEventListener('click', (e)=>{
    const b = e.target.closest('.btnVerLojas');
    if (!b) return;
    const full = b.getAttribute('data-full') || '';
    const dlg  = document.getElementById('modalCell');
    const ttl  = document.getElementById('cellTitle');
    const body = document.getElementById('cellBody');
    if (!dlg || !ttl || !body) return;

    const items = full.split(',').map(s=>s.trim()).filter(Boolean);
    ttl.textContent = 'Filial(s)';
    body.style.whiteSpace = 'pre-wrap';
    body.textContent = items.length ? items.join('\n') : (full || '—');
    dlg.showModal();
  });


  /* =====================================================================
   * 2) “DUPLICAR SELECIONADOS” (Visualizar finalizados) + AÇÃO NACIONAL
   *    - Liga/desliga UI quando “Sim/Não”
   *    - Botão “Definir ação…” lista subpartes existentes (ESPECIAL NACIONAL)
   *    - Caso crie nova, usa o modalAcao já existente
   *    - Na duplicação, a ação selecionada/ criada é usada
   * ===================================================================== */

  // Lê ações existentes a partir do DOM do grid principal (sub-rows de ESPECIAL NACIONAL)
  function getExistingAcoes(){
    const body = document.getElementById('jobsBody');
    const set = new Set();
    if (body) {
      body.querySelectorAll('tr.sub-row[data-sub]').forEach(tr=>{
        const nm = tr.getAttribute('data-sub')||'';
        const name = nm.trim();
        if (name) set.add(name);
      });
    }
    // fallback: se não encontrar nada no DOM, tenta via memória se existir
    if (!set.size && window.JOBS instanceof Map) {
      for (const [,j] of window.JOBS.entries()){
        if (String(j.isNacional).toLowerCase()==='true' && j.acaoNome) {
          set.add(String(j.acaoNome).trim());
        }
      }
    }
    return Array.from(set).sort((a,b)=> a.localeCompare(b,'pt-BR'));
  }

  function setDupAcaoUIEnabled(enabled){
    const btn = document.getElementById('btnDupEscolherAcao');
    const inp = document.getElementById('dupAcaoNome');
    if (btn) btn.disabled = !enabled;
    if (inp) {
      inp.readOnly = true; // segue o padrão do app
      if (!enabled) inp.value = '';
    }
  }

  function wireDupAcaoToggles(){
    const rSim = document.getElementById('dupAcaoSim');
    const rNao = document.getElementById('dupAcaoNao');
    const onChange = ()=>{
      const enabled = !!(rSim && rSim.checked);
      setDupAcaoUIEnabled(enabled);
    };
    if (rSim) rSim.addEventListener('change', onChange);
    if (rNao) rNao.addEventListener('change', onChange);
    // estado inicial
    onChange();
  }

  // Abre o modalAcao populando com as ações existentes e permite criar nova
  function openAcaoChooser(targetInputId){
    const dlg = document.getElementById('modalAcao');
    const box = document.getElementById('acaoLista');
    const inp = document.getElementById('acaoNova');
    const btnOk = document.getElementById('acaoOk');
    const btnCancel = document.getElementById('acaoCancelar');
    if (!dlg || !box || !btnOk) return;

    const actions = getExistingAcoes();
    // render simples clicável
    let sel = null;
    box.innerHTML = actions.length
      ? actions.map(a=>`<div class="acaoItem" data-name="${a.replace(/"/g,'&quot;')}"
           style="padding:6px 8px;border-bottom:1px dashed rgba(255,255,255,.12);cursor:pointer">${a}</div>`).join('')
      : '<div class="muted">Nenhuma ação existente encontrada.</div>';

    box.querySelectorAll('.acaoItem').forEach(div=>{
      div.addEventListener('click', ()=>{
        box.querySelectorAll('.acaoItem').forEach(d=> d.style.background='transparent');
        div.style.background = 'rgba(255,255,255,.06)';
        sel = div.getAttribute('data-name') || '';
        if (inp) inp.value = ''; // limpamos a criação se escolher existente
      });
    });

    if (inp) inp.value = ''; // limpa campo de nova ação

    function close(){
      try { btnOk.removeEventListener('click', onOk); } catch {}
      try { btnCancel && btnCancel.removeEventListener('click', onCancel); } catch {}
      dlg.close();
    }
    function onCancel(){ close(); }
    function onOk(){
      const target = document.getElementById(targetInputId);
      const viaNew = inp ? (inp.value||'').trim() : '';
      const chosen = viaNew || (sel||'');
      if (!chosen){
        const t=document.getElementById('toast'); if(t){ t.textContent='Selecione ou crie uma Ação.'; t.style.display='block'; setTimeout(()=>t.style.display='none',1500); }
        return;
      }
      if (target) target.value = chosen;
      // guarda no contexto de duplicação (usado por quem salva)
      window.WV = window.WV || {};
      window.WV._dupActionName = chosen;
      close();
    }

    btnOk.addEventListener('click', onOk);
    btnCancel && btnCancel.addEventListener('click', onCancel);
    dlg.showModal();
  }

  // Conecta o botão "Definir ação…" do modalDup2 ao chooser acima
  (function wireDupAcaoChooser(){
    const btn = document.getElementById('btnDupEscolherAcao');
    if (!btn) return;
    btn.addEventListener('click', ()=>{
      // só se marcado "Sim"
      const rSim = document.getElementById('dupAcaoSim');
      if (!rSim || !rSim.checked) return;
      openAcaoChooser('dupAcaoNome');
    });
  })();

  // Integração com “Duplicar selecionados” do modal de Finalizados
  (function hookFinalizadosDuplicate(){
    const btnDupSel = document.getElementById('finzDuplicar');
    const dlgDup2   = document.getElementById('modalDup2');      // parâmetros
    const resumen   = document.getElementById('dupResumo');
    const list      = document.getElementById('finzList');
    if (!btnDupSel || !dlgDup2 || !list) return;

    btnDupSel.addEventListener('click', ()=>{
      // coleta seleção
      const sel = [...list.querySelectorAll('input[type="checkbox"][data-ot]:checked')].map(b=> b.getAttribute('data-ot'));
      if (!sel.length){
        const t=document.getElementById('toast'); if(t){ t.textContent='Selecione pelo menos 1 job para duplicar.'; t.style.display='block'; setTimeout(()=>t.style.display='none',1500); }
        return;
      }

      // marca contexto de duplicação originado de finalizados
      window.WV = window.WV || {};
      window.WV._dupContext = { from:'finalizados', ots: sel };

      // limpa/ajusta UI do modalDup2
      const rNao = document.getElementById('dupAcaoNao');
      const rSim = document.getElementById('dupAcaoSim');
      const inpAcao = document.getElementById('dupAcaoNome');
      if (rNao) rNao.checked = true;
      if (rSim) rSim.checked = false;
      if (inpAcao) inpAcao.value = '';
      setDupAcaoUIEnabled(false);
      wireDupAcaoToggles();

      if (resumen) {
        resumen.classList.add('muted');
        resumen.textContent = `${sel.length} job(s) selecionado(s) para duplicar a partir dos Finalizados. Defina os parâmetros e clique em “Lançar”.`;
      }

      dlgDup2.showModal();
    });

    // Extra: se o código de duplicação já está implementado no seu projeto,
    // ele provavelmente lê dupAcaoSim/dupAcaoNome quando salva.
    // Apenas garantimos que WV._dupActionName esteja alinhado antes do "Lançar".
    const btnLaunch = document.getElementById('dup2Lancar');
    if (btnLaunch && !btnLaunch._wvPatched){
      btnLaunch.addEventListener('click', ()=>{
        const rSim = document.getElementById('dupAcaoSim');
        const inp  = document.getElementById('dupAcaoNome');
        window.WV = window.WV || {};
        window.WV._dupActionName = (rSim && rSim.checked && inp) ? (inp.value||'').trim() : '';
        // Observação:
        //  - Se _dupActionName for não-vazia, o seu fluxo de duplicação deve gravar:
        //      isNacional = true
        //      acaoNome   = _dupActionName
        //  - Se estiver vazia ou rNao marcado, gravar:
        //      isNacional = false
        //      acaoNome   = ''
        //
        // Se o launcher de duplicação for seu e quiser usar este contexto,
        // leia também window.WV._dupContext (ots selecionadas dos finalizados).
      });
      btnLaunch._wvPatched = true;
    }
  })();

})();
</script>

<!// AJUTES - Botão ver lojas + duplicar selecionados (visualizar finalizados) FIM ---->

<!// AJUTES - OT GLOBAL (Lançados e Finalizados) ---->

<script>
(function(){
  "use strict";

  /* ===========================
   *  CONFIG DO FORMATO DA OT
   * =========================== */
  const OT_FMT = { prefix: 'OT-', pad: 5 }; // resultado: OT-00001, OT-00002, ...

  /* ===========================
   *  CONFIG GITHUB
   *  (ajuste se seu owner/repo/branch forem outros)
   * =========================== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    jobsPath: 'jobs.csv',
    encPath:  'jobs_encerrados.csv',
    counterPath: 'ot_counter.txt'
  };

  /* ===========================
   *  HELPERS GERAIS
   * =========================== */
  const sleep = (ms)=> new Promise(r=> setTimeout(r, ms));

  function getToken(){
    try{
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}');
      return (window.gh && window.gh.token) || saved.token || '';
    }catch{
      return (window.gh && window.gh.token) || '';
    }
  }
  function ghHeaders(token, extra={}){
    return {
      'Accept':'application/vnd.github+json',
      'X-GitHub-Api-Version':'2022-11-28',
      ...(token ? {'Authorization':`Bearer ${token}`} : {}),
      ...extra
    };
  }
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  function formatOT(n){
    const s = String(n).padStart(OT_FMT.pad, '0');
    return `${OT_FMT.prefix}${s}`;
  }
  function numFromOT(ot){
    // extrai só os dígitos (ex.: "OT-00012" => 12)
    const m = String(ot||'').match(/(\d+)/);
    return m ? parseInt(m[1],10) : NaN;
  }

  // CSV simples (rápido)
  function parseCsv(text){
    if (!text) return [];
    const out=[]; let row=[], cur='', q=false;
    for(let i=0;i<text.length;i++){
      const c=text[i];
      if(q){
        if(c=='"'){ if(text[i+1]=='"'){cur+='"'; i++;} else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){ /* ignore */ }
        else if(c=='\n'){ row.push(cur); out.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); out.push(row); }
    return out;
  }
  function csvToObjs(text){
    const rows = parseCsv(text);
    if (!rows.length) return { head:[], rows:[] };
    const head = rows[0];
    const list=[];
    for(let i=1;i<rows.length;i++){
      const r=rows[i]; if(!r || (r.length===1 && r[0]==='')) continue;
      const o={}; for(let j=0;j<head.length;j++) o[head[j]] = r[j] ?? '';
      list.push(o);
    }
    return { head, rows:list };
  }
  const csvEsc = v => {
    v = v==null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  function objsToCsv(head, rows){
    const H = head.slice();
    const body = rows.map(o => H.map(h => csvEsc(o[h] ?? '')).join(',')).join('\n');
    return H.join(',') + '\n' + (body ? (body+'\n') : '');
  }

  /* ======================================================
   *  FETCH ORIGINAL & GUARDA-CHUVA PRA EVITAR RECURSÃO
   * ====================================================== */
  const _origFetch = window.fetch.bind(window);
  let _otHookInFlight = false; // evita loop quando usamos fetch internamente

  async function ghGetContent(path, headers, branch){
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await _origFetch(url, { headers });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('GET '+path+' '+r.status);
    const j = await r.json();
    const text = j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha: j.sha || null };
  }
  async function ghPutContent(path, newText, message, headers, branch, sha){
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: message || `chore: update ${path}`,
      content: utf8ToB64(newText),
      branch: branch || GH.branch,
      ...(sha ? { sha } : {})
    };
    const r = await _origFetch(url, {
      method:'PUT',
      headers: { ...headers, 'Content-Type':'application/json' },
      body: JSON.stringify(body)
    });
    if (!r.ok) {
      const t = await r.text();
      throw new Error('PUT '+path+' '+r.status+': '+t);
    }
    const et = r.headers.get('ETag') || null;
    let newSha=null; try{ const jj=await r.clone().json(); newSha = jj?.content?.sha || null; }catch{}
    return { sha: newSha, etag: et };
  }

  /* ======================================================
   *  COUNTER GLOBAL DE OT (ot_counter.txt)
   *  - Se não existir, cria com base no maior OT dos CSVs
   * ====================================================== */
  async function ensureCounter(headers){
    // tenta ler
    try{
      const { text, sha } = await ghGetContent(GH.counterPath, headers, GH.branch);
      const n = parseInt((text||'').trim(), 10);
      if (!isNaN(n)) return { value:n, sha };
    }catch{ /* continua */ }

    // não existe ou inválido -> calcular pelo maior OT nos dois CSVs
    let maxN = 0;
    try{
      const { text: jobsT } = await ghGetContent(GH.jobsPath, headers, GH.branch);
      const { text: encT  } = await ghGetContent(GH.encPath,  headers, GH.branch);
      const both = [jobsT, encT].filter(Boolean);
      for (const t of both){
        const { rows, head } = csvToObjs(t);
        const colOT = (head||[]).includes('ot') ? 'ot' : null;
        if (!colOT) continue;
        for (const r of rows){
          const n = numFromOT(r.ot);
          if (!isNaN(n) && n > maxN) maxN = n;
        }
      }
    }catch{/* ignore */}

    const initVal = maxN; // valor atual no arquivo; o próximo emitido será +1
    const put = await ghPutContent(GH.counterPath, String(initVal), 'chore(ot): init counter', headers, GH.branch, null);
    return { value: initVal, sha: put.sha || null };
  }

  async function reserveOTs(qty, headers, retries=3){
    if (qty <= 0) return [];
    let attempt = 0;
    while (attempt <= retries){
      attempt++;
      try{
        const { text, sha } = await ghGetContent(GH.counterPath, headers, GH.branch);
        const cur = parseInt((text||'').trim(),10);
        if (isNaN(cur)) throw new Error('counter invalid');
        const start = cur + 1;
        const end   = cur + qty;
        // grava novo valor (end) atomizando
        await ghPutContent(GH.counterPath, String(end), `chore(ot): reserve ${qty}`, headers, GH.branch, sha);
        // retorna formatado
        const arr=[]; for (let n=start;n<=end;n++) arr.push(formatOT(n));
        return arr;
      }catch(e){
        // Se 404, cria
        if (String(e).includes('404') || String(e).includes('counter invalid')){
          await ensureCounter(headers);
          continue; // tenta de novo
        }
        // conflito (409) ou intermitência -> espera e tenta
        await sleep(250 + Math.random()*400);
      }
    }
    throw new Error('Falha ao reservar OTs (concorrência).');
  }

  /* ======================================================
   *  AJUSTE DO PUT DE jobs.csv:
   *   - Intercepta PUT do GitHub API p/ jobs.csv
   *   - Garante OTs únicas (gera para novas/duplicadas)
   * ====================================================== */
  function urlIsJobsPut(url, method){
    if (String(method||'').toUpperCase() !== 'PUT') return false;
    return /\/repos\/[^/]+\/[^/]+\/contents\/jobs\.csv(\?|$)/.test(String(url));
  }

  function decodePutBody(init){
    const b = init && init.body;
    if (!b) return null;
    try{
      const obj = (typeof b === 'string') ? JSON.parse(b) : (b instanceof Blob ? null : b);
      if (!obj || !obj.content) return null;
      return obj;
    }catch{ return null; }
  }

  function cloneInitWithBody(init, bodyObj){
    const newInit = { ...(init||{}) };
    newInit.body = JSON.stringify(bodyObj);
    return newInit;
  }

  function countBy(arr, getKey){
    const m = new Map();
    arr.forEach((x,i)=>{
      const k = getKey(x,i);
      m.set(k, (m.get(k)||0)+1);
    });
    return m;
  }

  async function fixJobsCsvBeforePut(url, init){
    // headers do put original
    const token = getToken();
    const headers = ghHeaders(token, { 'Content-Type':'application/json' });

    // 1) conteúdo novo pretendido
    const putBody = decodePutBody(init);
    if (!putBody) return init; // sem body json? deixa seguir
    const newTextRaw = b64ToUtf8(putBody.content||'');
    const { head: newHead, rows: newRows } = csvToObjs(newTextRaw);
    if (!newHead.length || !newRows.length) return init;

    // 2) carrega CSV atual (antes do PUT) e finalizados
    const [{ text: curJobs }, { text: curEnc }] = await Promise.all([
      ghGetContent(GH.jobsPath, headers, GH.branch).catch(()=>({text:''})),
      ghGetContent(GH.encPath,  headers, GH.branch).catch(()=>({text:''}))
    ]);
    const { rows: oldRows } = csvToObjs(curJobs);
    const { rows: encRows } = csvToObjs(curEnc);

    const oldOTs = new Set(oldRows.map(r => String(r.ot||'')).filter(Boolean));
    const encOTs = new Set(encRows.map(r => String(r.ot||'')).filter(Boolean));
    const usedGlobal = new Set([...oldOTs, ...encOTs].filter(Boolean));

    // 3) detectar linhas candidatas a receber OT nova
    //    - sem OT
    //    - duplicadas de OT *dentro do próprio novo arquivo* (segunda ocorrência em diante)
    //    - com OT ainda não existente no jobs atual, mas que colide com enc (raro) => emitir nova
    const counts = countBy(newRows, r => String(r.ot||''));
    const needAssignIdx = []; // índices em newRows que precisam de OT
    const seen = new Set();   // para identificar "segunda ocorrência"

    for (let i=0;i<newRows.length;i++){
      const r = newRows[i];
      const ot = String(r.ot||'').trim();

      if (!ot){ needAssignIdx.push(i); continue; }

      // duplicado dentro do próprio arquivo novo?
      const key = ot + '|' + (counts.get(ot)||0);
      if (counts.get(ot) > 1){
        // marca todas menos a 1ª ocorrência
        if (seen.has(ot)) { needAssignIdx.push(i); continue; }
        seen.add(ot);
      }

      // se ot não existia no jobs atual, mas existe em finalizados -> trocamos
      if (!oldOTs.has(ot) && encOTs.has(ot)){
        needAssignIdx.push(i); continue;
      }
      // Se já existia no jobs atual, assumimos ser edição -> mantém OT
    }

    if (!needAssignIdx.length){
      // Nada a fazer; retorna init original
      return init;
    }

    // 4) reservar OTs e aplicar
    // garante counter
    await ensureCounter(headers);
    const freshOTs = await reserveOTs(needAssignIdx.length, headers);
    needAssignIdx.forEach((idx, j)=> {
      newRows[idx].ot = freshOTs[j];
    });

    // 5) reconstroi novo csv e reempacota body
    const fixedText = objsToCsv(newHead, newRows);
    const bodyObj = { ...putBody, content: utf8ToB64(fixedText) };
    return cloneInitWithBody(init, bodyObj);
  }

  // ============ PATCH GLOBAL DO FETCH ============
  window.fetch = async function(input, init){
    try{
      if (_otHookInFlight) {
        return _origFetch(input, init); // chamadas internas do patch
      }

      const url = (typeof input === 'string') ? input : (input && input.url) || '';
      const method = init && init.method;

      // intercepta somente PUT de jobs.csv
      if (urlIsJobsPut(url, method)) {
        _otHookInFlight = true;
        try{
          const nextInit = await fixJobsCsvBeforePut(url, init);
          return await _origFetch(input, nextInit);
        } finally {
          _otHookInFlight = false;
        }
      }

      return await _origFetch(input, init);
    }catch(e){
      // fallback em caso de erro no patch
      try{ return await _origFetch(input, init); } catch { throw e; }
    }
  };

  /* ======================================================
   *  API opcional (se quiser usar direto nos seus handlers)
   *   window.getNextOT(): Promise<string>
   *   window.reserveOTs(n): Promise<string[]>
   * ====================================================== */
  window.getNextOT = async function(){
    const token = getToken();
    const headers = ghHeaders(token);
    await ensureCounter(headers);
    const arr = await reserveOTs(1, headers);
    return arr[0];
  };
  window.reserveOTs = async function(n){
    const token = getToken();
    const headers = ghHeaders(token);
    await ensureCounter(headers);
    return reserveOTs(n, headers);
  };

  // Aviso no console
  console.log('[WV OT] Hook de OT global ativo: OTs únicas entre jobs.csv e jobs_encerrados.csv');

})();
</script>

<!// AJUTES - OT GLOBAL (Lançados e Finalizados) FIM ---->


<!// AJUTES - OT GLOBAL (OT sem zeros a esquerda)  ---->
<script>
(function(){
  "use strict";

  /* ===============================
   * Config GitHub (ajuste se mudar)
   * =============================== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    jobsPath: 'jobs.csv',
    encPath:  'jobs_encerrados.csv'
  };

  /* ===============================
   * Helpers gerais
   * =============================== */
  function getToken(){
    try{
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}');
      return (window.gh && window.gh.token) || saved.token || '';
    }catch{ return (window.gh && window.gh.token) || ''; }
  }
  function ghHeaders(token, extra={}){
    return {
      'Accept':'application/vnd.github+json',
      'X-GitHub-Api-Version':'2022-11-28',
      ...(token ? {'Authorization':`Bearer ${token}`} : {}),
      ...extra
    };
  }
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  async function ghGet(path, branch){
    const token = getToken();
    if (!token) throw new Error('Token GitHub não configurado.');
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('GET '+path+' '+r.status);
    const j = await r.json();
    const text = j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha: j.sha || null };
  }
  async function ghPut(path, newText, msg){
    const token = getToken();
    if (!token) throw new Error('Token GitHub não configurado.');
    let sha = null;
    try { const cur = await ghGet(path, GH.branch); sha = cur.sha; } catch {}
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body = { message: msg || `chore(csv): normalize OTs ${path}`, content: utf8ToB64(newText), branch: GH.branch, ...(sha?{sha}:{}) };
    const r = await fetch(url, { method:'PUT', headers: { ...ghHeaders(token), 'Content-Type':'application/json' }, body: JSON.stringify(body) });
    if (!r.ok) { const t = await r.text(); throw new Error('PUT '+path+' '+r.status+': '+t); }
    return true;
  }

  /* ===============================
   * CSV helpers leves
   * =============================== */
  function parseCsv(text){
    if (!text) return [];
    const out=[]; let row=[], cur='', q=false;
    for(let i=0;i<text.length;i++){
      const c=text[i];
      if(q){
        if(c=='"'){ if(text[i+1]=='"'){cur+='"'; i++;} else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){ /* ignore */ }
        else if(c=='\n'){ row.push(cur); out.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); out.push(row); }
    return out;
  }
  function csvToObjs(text){
    const rows = parseCsv(text);
    if (!rows.length) return { head:[], rows:[] };
    const head = rows[0];
    const list=[];
    for(let i=1;i<rows.length;i++){
      const r=rows[i]; if(!r || (r.length===1 && r[0]==='')) continue;
      const o={}; for(let j=0;j<head.length;j++) o[head[j]] = r[j] ?? '';
      list.push(o);
    }
    return { head, rows:list };
  }
  const csvEsc = v => {
    v = v==null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  function objsToCsv(head, rows){
    const H = head.slice();
    const body = rows.map(o => H.map(h => csvEsc(o[h] ?? '')).join(',')).join('\n');
    return H.join(',') + '\n' + (body ? (body+'\n') : '');
  }

  /* ===============================
   * Trim de zeros à esquerda
   * =============================== */
  function trimOT(ot){
    // Mantém prefixo se existir; extrai número; remove zeros à esquerda
    if (!ot) return ot;
    const s = String(ot);
    const m = s.match(/^([A-Za-z\-]*)(\d+)$/) || s.match(/^([A-Za-z\-]*)(0*)(\d+)$/) || s.match(/^(.+?)-?0*(\d+)$/) || [];
    // estratégia robusta: pega últimos dígitos
    const md = s.match(/(\d+)\s*$/);
    if (!md) return s;
    const num = parseInt(md[1],10);
    if (isNaN(num)) return s;
    // prefixo é tudo até os dígitos começarem
    const px = s.slice(0, s.lastIndexOf(md[1]));
    const dash = px.endsWith('-') ? '' : (px ? '-' : '');
    return `${px}${dash}${num}`;
  }

  // UI: sempre mostrar sem zeros (sem mexer em data-ot)
  function displayTrimInCell(td){
    if (!td) return;
    const txt = (td.textContent || '').trim();
    if (!txt) return;
    const trimmed = trimOT(txt);
    if (trimmed !== txt) td.textContent = trimmed;
  }
  function applyOTDisplayTrim(root){
    const scope = root || document;
    // tabela principal (OT está na 1ª coluna)
    scope.querySelectorAll('#jobsBody tr[data-ot] td:nth-child(1)').forEach(displayTrimInCell);
    // modais conhecidos (finalizar, finalizados, encerrar, duplicar) — 2ª col costuma ser OT
    scope.querySelectorAll('#finList tr td:nth-child(2), #finzList tr td:nth-child(2), #encList tr td:nth-child(2), #dupList tr td:nth-child(2)').forEach(displayTrimInCell);
  }

  // Observa inserções de linhas de jobs para aplicar o display trim automaticamente
  const bodyMo = new MutationObserver(muts=>{
    let needs = false;
    for (const m of muts){
      m.addedNodes && m.addedNodes.forEach(n=>{
        if (n.nodeType===1 && (n.matches('#jobsBody tr[data-ot]') || n.querySelector?.('#jobsBody tr[data-ot]'))) needs = true;
        // listas dos modais
        if (n.nodeType===1 && (n.matches('#finList tr, #finzList tr, #encList tr, #dupList tr') || n.querySelector?.('#finList tr, #finzList tr, #encList tr, #dupList tr'))) needs = true;
      });
    }
    if (needs) applyOTDisplayTrim();
  });
  bodyMo.observe(document.documentElement, { childList:true, subtree:true });

  // também ao carregar
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=> applyOTDisplayTrim());
  } else {
    applyOTDisplayTrim();
  }

  /* ===============================
   * Normalização em disco (uma vez)
   * =============================== */
  async function normalizeCsvOTs(path){
    const { text } = await ghGet(path, GH.branch);
    if (!text) return false;
    const { head, rows } = csvToObjs(text);
    if (!head.length) return false;

    const hasOT = head.includes('ot');
    if (!hasOT) return false;

    let changed = false;
    for (const r of rows){
      const cur = r.ot || '';
      const trimmed = trimOT(cur);
      if (trimmed && trimmed !== cur){
        r.ot = trimmed;
        changed = true;
      }
    }
    if (!changed) return false;

    const next = objsToCsv(head, rows);
    await ghPut(path, next, `chore(ot): trim leading zeros in ${path}`);
    return true;
  }

  async function normalizeAllOnce(){
    // roda só se tiver token + não rodou ainda nesta máquina
    if (!getToken()) return;
    if (localStorage.getItem('wv_ot_trim_done') === 'yes') return;

    try{
      // pequena espera para não competir com outras cargas logo no login
      await new Promise(r => setTimeout(r, 800));

      const changedJobs = await normalizeCsvOTs(GH.jobsPath).catch(()=>false);
      const changedEnc  = await normalizeCsvOTs(GH.encPath).catch(()=>false);

      if (changedJobs || changedEnc){
        // recarrega UI principal, se houver função disponível
        if (typeof window.loadJobsFromGitHub === 'function'){
          try { await window.loadJobsFromGitHub(); } catch {}
        }
      }
      localStorage.setItem('wv_ot_trim_done','yes');
    }catch(e){
      // não trava a app
      console.warn('[WV OT] normalização falhou:', e);
    }
  }

  // dispara após login (quando currentUser existir) ou após token presente
  function tryBootNormalize(){
    if (!getToken()) return; // sem token, não é possível
    if (window.currentUser){
      normalizeAllOnce();
      return true;
    }
    return false;
  }

  // tenta já
  if (!tryBootNormalize()){
    // observa login
    const mo = new MutationObserver(()=>{
      if (tryBootNormalize()) mo.disconnect();
    });
    mo.observe(document.documentElement, { childList:true, subtree:true, attributes:true });
    // timeout de segurança (se currentUser já existir mas não detectamos)
    setTimeout(tryBootNormalize, 2000);
  }

  // API opcional
  window.WV_OT = window.WV_OT || {};
  window.WV_OT.trimDisplayNow = () => applyOTDisplayTrim();
  window.WV_OT.trimString = trimOT;

  console.log('[WV OT] visual e normalização: zeros à esquerda removidos (OT-0007 → OT-7)');
})();
</script>

<!// AJUTES - OT GLOBAL (OT sem zeros a esquerda) FIM ---->

<!//BLOCK IP>

<script>
(function(){
  "use strict";

  // ===== CONFIG =====
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    path:   'segurancaallow_ip.txt' // NA RAIZ do repo (sem "/")
  };
  const DEBUG = false;          // true para ver detalhes do motivo
  const TEXT_DENY = 'Acesso bloqueado: IP não autorizado.';
  const TEXT_CHECK = 'Verificando acesso…';

  // ===== Overlay full-screen =====
  function ensureOverlay(){
    if (document.getElementById('ipBlocker')) return;
    const css = document.createElement('style');
    css.textContent = `
      #ipBlocker{position:fixed;inset:0;z-index:2147483647;display:grid;place-items:center;background:#0b1220;color:#eaf0ff;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
      #ipBlocker .box{max-width:680px;width:min(92vw,680px);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:18px 20px;text-align:center;box-shadow:0 18px 60px rgba(0,0,0,.6)}
      #ipBlocker h2{margin:0 0 8px 0;font-size:20px}
      #ipBlocker p{margin:6px 0;color:#c7d2fe}
      #ipBlocker .muted{color:#94a3b8;font-size:.9rem}
      #ipBlocker .btn{appearance:none;cursor:pointer;border-radius:10px;padding:10px 14px;font-weight:600;background:#0d1628;border:1px solid rgba(255,255,255,.12);color:#eaf0ff;margin:4px}
      #ipBlocker .btn.primary{background:linear-gradient(180deg,#2a60ff,#1b47c9);border-color:transparent}
      #ipBlocker .debug{margin-top:8px;color:#9ca3af;font-size:.85rem;word-break:break-all;display:none}
      body.ip-guard-hidden{overflow:hidden}
    `;
    document.head.appendChild(css);

    const div = document.createElement('div');
    div.id='ipBlocker';
    div.innerHTML = `
      <div class="box">
        <h2 id="ipTitle">${TEXT_CHECK}</h2>
        <p class="muted">IP detectado: <span id="ipClient">—</span></p>
        <div id="ipDebug" class="debug"></div>
        <div>
          <button class="btn" id="ipRetry">Tentar novamente</button>
          <button class="btn primary" id="ipReload">Recarregar</button>
        </div>
      </div>`;
    document.body.appendChild(div);
    document.body.classList.add('ip-guard-hidden');
    document.getElementById('ipRetry')?.addEventListener('click', runCheck);
    document.getElementById('ipReload')?.addEventListener('click', ()=> location.reload());
  }
  ensureOverlay();

  const $ = (id)=> document.getElementById(id);

  function setOverlay(state, ip, dbg){
    if ($('ipClient')) $('ipClient').textContent = ip || '—';
    if (state==='allow'){
      // remove overlay
      const blk = $('ipBlocker');
      blk?.parentElement?.removeChild(blk);
      document.body.classList.remove('ip-guard-hidden');
    } else if (state==='deny'){
      if ($('ipTitle')) $('ipTitle').textContent = TEXT_DENY;
      if (DEBUG && $('ipDebug')) { $('ipDebug').style.display='block'; $('ipDebug').textContent = dbg || ''; }
    } else {
      if ($('ipTitle')) $('ipTitle').textContent = TEXT_CHECK;
      if ($('ipDebug')) { $('ipDebug').style.display='none'; $('ipDebug').textContent=''; }
    }
  }

  // ===== Fetch allowlist (RAW GitHub prioritário; API fallback) =====
  async function fetchAllowRaw(){
    const url = `https://raw.githubusercontent.com/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/${encodeURIComponent(GH.branch)}/${GH.path}`;
    const r = await fetch(url, { cache:'no-store' });
    if (!r.ok) throw new Error('raw '+r.status);
    return await r.text();
  }
  function b64ToText(b64){
    const bin = atob(b64); const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  async function fetchAllowApi(){
    const token = (()=>{
      try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; }
    })();
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(GH.path)}?ref=${encodeURIComponent(GH.branch)}`;
    const r = await fetch(url, { headers: { 'Accept':'application/vnd.github+json','X-GitHub-Api-Version':'2022-11-28', ...(token?{'Authorization':`Bearer ${token}`}:{}) } });
    if (!r.ok) throw new Error('api '+r.status);
    const j = await r.json();
    if (!j || !j.content) throw new Error('api sem content');
    return b64ToText(j.content);
  }
  async function getAllowList(){
    try { return await fetchAllowRaw(); } catch(_){}
    return await fetchAllowApi();
  }

  // ===== Descobre IPv4 público rápido =====
  async function getIPv4(){
    const probes = [
      async ()=> (await (await fetch('https://ipv4.icanhazip.com', { cache:'no-store' })).text()).trim(),
      async ()=> (await (await fetch('https://api.ipify.org?format=text', { cache:'no-store' })).text()).trim()
    ];
    for (const p of probes){
      try{
        const ip = (await p())||'';
        if (/^\d{1,3}(\.\d{1,3}){3}$/.test(ip)) return ip;
      }catch{}
    }
    return '';
  }

  // ===== Parse / match =====
  function parseLines(t){
    return String(t||'').replace(/^\uFEFF/,'').split(/\r?\n/).map(s=>s.trim()).filter(s=> s && !s.startsWith('#'));
  }

  async function runCheck(){
    setOverlay('checking', '…', DEBUG ? 'checando…' : '');
    try{
      const [txt, ip] = await Promise.all([getAllowList(), getIPv4()]);
      const rules = parseLines(txt);
      if (DEBUG && $('ipDebug')) $('ipDebug').textContent = `Regras: ${rules.join(', ')}`;
      if ($('ipClient')) $('ipClient').textContent = ip || '—';

      // Só permite EXATO (sem wildcard/CIDR)
      const ok = !!(ip && rules.some(r => r === ip));
      if (ok) setOverlay('allow', ip);
      else    setOverlay('deny',  ip, `IP ${ip||'—'} não consta na lista.`);
    }catch(e){
      setOverlay('deny', '', DEBUG ? String(e) : '');
    }
  }

  // roda já
  runCheck();
})();
</script>


<<!// BLOCK IP - FIM>

</body>
</html>
