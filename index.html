<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Workflow Vector — Login & Jobs</title>
<style>
  :root{
    --bg:#0b1220;--card:#111a2b;--muted:#7e8aa0;--text:#eaf0ff;--accent:#6aa6ff;--accent-2:#8b5cf6;
    --ring:0 0 0 3px rgba(106,166,255,.25);
    --topbar-h:64px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background:
      radial-gradient(1200px 1200px at 10% -10%,rgba(138,92,246,.15),transparent 50%),
      radial-gradient(900px 900px at 120% 10%,rgba(106,166,255,.15),transparent 60%),
      var(--bg);
    color:var(--text);
    min-height:100vh;
  }
  /* ====== LOGIN ====== */
  .app{width:min(1300px,100%); display:grid; gap:18px; margin:0 auto; padding:24px}
  .title{text-align:center; line-height:1.2}
  .title h1{margin:.2rem 0;font-size:clamp(22px,4vw,34px)}
  .title p{margin:0;color:var(--muted)}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.45); overflow:hidden}
  .login{display:grid; grid-template-columns: 1.1fr .9fr; gap:0; min-height:380px}
  @media (max-width:920px){.login{grid-template-columns:1fr}.side{display:none}}
  .panel{padding:28px}
  .side{background:
    radial-gradient(100% 100% at 0% 0%, rgba(139,92,246,.25), transparent 55%),
    radial-gradient(100% 100% at 100% 0%, rgba(106,166,255,.25), transparent 55%),
      linear-gradient(180deg, #0c172a, #0a1424);
    border-left:1px solid rgba(255,255,255,.06); display:grid; place-items:center; padding:24px}
  .brand{display:grid; gap:12px; text-align:center; place-items:center}
  .logo{width:180px;height:180px;border-radius:18px;
    background:conic-gradient(from 180deg at 50% 50%, var(--accent), var(--accent-2));
    display:grid;place-items:center;font-weight:800;font-size:3.3rem; color:#fff}
  .field{display:grid; gap:6px; margin:10px 0}
  label{font-size:.9rem;color:var(--muted)}
  input,select,textarea{
    width:100%; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.12);
    background:#0b1426; color:var(--text);outline:none; transition:.2s border-color,.2s box-shadow; font-size:.95rem}
  textarea{min-height:90px; resize:vertical}
  input:focus, select:focus, textarea:focus{border-color:var(--accent); box-shadow:var(--ring)}
  .row{display:flex; gap:12px; flex-wrap:wrap; margin-top:8px}
  .btn{appearance:none; border:1px solid rgba(255,255,255,.12); background:#0d1628; color:#eaf0ff;
    padding:10px 14px; border-radius:10px; cursor:pointer;transition:.2s transform,.2s background,.2s border-color, .2s box-shadow; font-weight:600}
  .btn:hover{transform:translateY(-1px); border-color:rgba(255,255,255,.25)}
  .btn:focus{outline:none; box-shadow:var(--ring)}
  .btn.primary{background:linear-gradient(180deg, #2a60ff, #1b47c9); border-color:transparent}
  .btn.ghost{background:transparent}
  .btn.small{padding:6px 10px; font-size:.85rem}
  .muted{color:var(--muted); font-size:.9rem}
  .warning{font-size:.85rem;color:#f8c37a}
  dialog{border:none; border-radius:14px; max-width:1200px; width:min(98vw,1200px); box-shadow:0 20px 60px rgba(0,0,0,.6); background:var(--card); color:var(--text)}
  dialog::backdrop{background:rgba(0,0,0,.55)}
  .modal{padding:18px}
  .modal h3{margin:0 0 8px 0}
  .modal .actions{display:flex; justify-content:flex-end; gap:10px; margin-top:10px}
  #busy{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;place-items:center;z-index:99999}
  #busy .box{background:#0e1730;border:1px solid rgba(255,255,255,.12);padding:14px 16px;border-radius:12px}
  /* ====== APP ====== */
  .hide{display:none !important}
  .topbar{
    height:var(--topbar-h);
    display:flex; align-items:center; gap:12px; padding:10px 14px;
    border-bottom:1px solid rgba(255,255,255,.08);
    background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
    box-shadow:0 10px 30px rgba(0,0,0,.25);
    position: sticky; top: 0; z-index: 50;
  }
  .left{display:flex; gap:10px; flex-wrap:wrap}
  .right{margin-left:auto; display:flex; align-items:center; gap:10px}
  .userName{font-weight:700}
  .content{ flex:1; display:flex; align-items:stretch; justify-content:stretch; min-height:0; padding:12px; }
  .box{ width:100%; height:100%; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); border-radius:12px; padding:14px; overflow:hidden; }
  #toast{position:fixed;left:50%;top:18px;transform:translateX(-50%);background:#1f2a44;color:#eaf0ff;padding:10px 14px;border:1px solid rgba(255,255,255,.16);border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,.5);z-index:9999;display:none}
  /* tabela jobs */
  #mainBox .tableWrap{height:100%; overflow:auto;}
  #mainBox table{ table-layout: fixed; width:100%; border-collapse:collapse; font-size:.95rem }
  #mainBox thead th{ font-size:.82rem; padding:8px 10px; position:sticky; top:0; z-index:2; background:#0f182b; border-bottom:1px solid rgba(255,255,255,.12); border-right:1px solid rgba(255,255,255,.12) }
  #mainBox thead th:last-child{ border-right:none }
  #mainBox tbody td{ text-align:center; vertical-align:middle; padding:8px 10px; border-bottom:1px solid rgba(255,255,255,.06); border-right:1px solid rgba(255,255,255,.12); font-size:.84rem; line-height:1.25 }
  #mainBox tbody td:last-child{ border-right:none }
  #mainBox .sep-row td{ text-align:center; font-size:.82rem; font-weight:700; letter-spacing:.02em; padding:8px 10px; background:rgba(255,255,255,.02); border-top:1px solid rgba(255,255,255,.08); }
  #mainBox .sub-row td{ text-align:left; font-size:.82rem; font-weight:700; letter-spacing:.01em; padding:8px 10px 8px 24px; background:rgba(255,255,255,.03); border-top:1px dashed rgba(255,255,255,.12); color:var(--text); }
  /* status cores */
  #mainBox tbody tr.st-novo{background:#ffffff; color:#111827}
  #mainBox tbody tr.st-lista{background:#cfe8ff; color:#111827}
  #mainBox tbody tr.st-layout{background:#4c1d95; color:#ffffff}
  #mainBox tbody tr.st-digitando{background:#1e3a8a; color:#ffffff}
  #mainBox tbody tr.st-diagramando{background:#f59e0b; color:#111827}
  #mainBox tbody tr.st-revisando{background:#fbcfe8; color:#111827}
  #mainBox tbody tr.st-aprovado{background:#bbf7d0; color:#065f46}
  #mainBox tbody tr.st-encerrando{background:#fde68a; color:#111827}
  #mainBox tbody tr.st-site{background:#d8b4fe; color:#111827}
  #mainBox tbody tr.st-cancelado{background:#991b1b; color:#ffffff}
  #mainBox tbody tr.st-finalizado{background:#4b5563; color:#ffffff}
  #mainBox tbody tr[class^="st-"] .btn{ border-color: rgba(0,0,0,.2); box-shadow:none }
  #mainBox tbody tr.st-layout .btn, #mainBox tbody tr.st-digitando .btn, #mainBox tbody tr.st-cancelado .btn{ border-color: rgba(255,255,255,.4) }
  #mainBox tbody td .clip{ display:inline-block; max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; cursor:pointer; border-bottom:1px dotted rgba(255,255,255,.35); }
  #mainBox tbody tr.sel{ outline:2px solid var(--accent); outline-offset:-2px; }
  /* chips cargos */
  .role-chip{ display:inline-block; padding:4px 8px; border-radius:999px; font-size:.8rem; font-weight:700; border:1px solid rgba(255,255,255,.18) }
  .role-prata{background:linear-gradient(180deg,#d1d5db,#9ca3af); color:#111827}
  .role-verde{background:rgba(130,230,150,.25); border-color:rgba(130,230,150,.4)}
  .role-roxo{background:rgba(150,114,255,.22); border-color:rgba(150,114,255,.35)}
  .role-azul{background:rgba(129,199,245,.22); border-color:rgba(129,199,245,.35)}
  .role-laranja{background:rgba(255,170,86,.25); border-color:rgba(255,255,255,.4)}
  .role-rosa{background:rgba(255,140,200,.25); border-color:rgba(255,140,200,.4)}
  .role-amarelo{background:rgba(255,220,120,.3); border-color:rgba(255,255,255,.5)}
  .role-roxoclaro{background:rgba(192,132,252,.25); border-color:rgba(192,132,252,.4)}
  /* grids/inputs modais app */
  .grid{ display:grid; grid-template-columns:repeat(12,1fr); gap:10px }
  .col-6{ grid-column:span 6 } .col-4{ grid-column:span 4 } .col-3{ grid-column:span 3 } .col-2{ grid-column:span 2 } .col-12{ grid-column:span 12 }
  .actions{ display:flex; justify-content:flex-end; gap:10px; margin-top:12px }
  .err{border-color:#f87171 !important; box-shadow:0 0 0 3px rgba(248,113,113,.25) !important}
  /* listas em modais */
  .frow{ display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 12px }
  .list{ border:1px solid rgba(255,255,255,.12); border-radius:10px; overflow:hidden }
  .list table{ width:100%; border-collapse:collapse }
  .list thead th{ background:#0f182b; font-size:.82rem; padding:8px 10px; text-align:left }
  .list tbody td{ padding:8px 10px; border-top:1px solid rgba(255,255,255,.08); font-size:.9rem }
  .list .hint{ padding:12px; color:var(--muted) }
</style>
</head>
<body>
<!-- ===== VIEW LOGIN ===== -->
<div id="loginView" class="app">
  <div class="title">
    <h1>Workflow Vector</h1>
    <p>Seja bem vindo ao Workflow Vector, plataforma de lançamentos de JOBS.</p>
  </div>

  <section class="card login">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <h2 style="margin:0 0 12px 0">Entrar</h2>
          <p class="muted">Use seu e-mail e senha para acessar.</p>
        </div>
        <button class="btn" id="btnCfg">⚙ Configurar GitHub</button>
      </div>

      <div class="field"><label for="email">E-mail</label><input id="email" type="email" placeholder="voce@empresa.com.br" /></div>
      <div class="field"><label for="senha">Senha</label><input id="senha" type="password" placeholder="••••••••" /></div>

      <div class="row" style="margin-top:10px">
        <button class="btn ghost" id="btnCadastrar">Cadastrar</button>
        <button class="btn primary" id="btnLogin">Login</button>
        <button class="btn ghost" id="btnEsqueci">Esqueci minha senha/e-mail!</button>
      </div>

      <p class="warning" style="margin-top:8px">Versão: 1.1.0 <strong>-WKF job</strong> Vector TI.</p>
    </div>
    <aside class="side">
      <div class="brand">
        <div class="logo">WV</div>
        <div class="muted" style="margin-top:6px">
          <span class="chip" style="padding:6px 10px;border:1px solid rgba(255,255,255,.14);border-radius:999px">V0.1 - Job manager Vector</span>
        </div>
      </div>
    </aside>
  </section>

  <!-- MODAL: Config GitHub -->
  <dialog id="modalCfg">
    <form method="dialog" class="modal" id="formCfg">
      <h3>Definir Token do GitHub</h3>
      <div class="field">
        <label>TOKEN (GitHub Personal Access Token)</label>
        <input id="cfgToken" type="password" placeholder="ghp_xxx..." />
        <div class="muted">Gere um token com acesso a <strong>Contents: read &amp; write</strong> no repositório configurado.</div>
      </div>
      <div class="row" style="align-items:center">
        <label style="display:flex;gap:8px;align-items:center">
          <input id="cfgRemember" type="checkbox" checked />
          Lembrar token neste navegador
        </label>
      </div>
      <div class="actions">
        <button class="btn" type="button" data-close="modalCfg">Cancelar</button>
        <button class="btn primary" type="button" id="btnCfgSalvar">Salvar</button>
      </div>
    </form>
  </dialog>

  <!-- MODAL: Cadastro -->
  <dialog id="modalCadastro">
    <form method="dialog" class="modal" id="formCadastro">
      <h3>Novo cadastro</h3>
      <div class="field"><label for="cadNome">Nome completo</label><input id="cadNome" type="text" placeholder="Seu nome completo" /></div>
      <div class="field"><label for="cadEmail">E-mail</label><input id="cadEmail" type="email" placeholder="voce@empresa.com.br" /></div>
      <div class="field"><label for="cadSenha">Senha</label><input id="cadSenha" type="password" placeholder="Crie uma senha" /></div>

      <div class="row" style="gap:16px;flex-wrap:wrap">
        <div class="field" style="min-width:220px">
          <label for="cadCargoP">Cargo (PRINCIPAL)</label>
          <select id="cadCargoP">
            <option value="">— selecione —</option>
            <option>Administrador</option><option>Diretor</option><option>Gerente</option>
            <option>Trafego</option><option>Layout</option><option>Diagramador</option>
            <option>Digitador</option><option>Revisor</option><option>Site</option>
            <option>Encerramento</option>
          </select>
        </div>
        <div class="field" style="min-width:220px">
          <label for="cadCargoS">Cargo (SECUNDÁRIA) — opcional</label>
          <select id="cadCargoS">
            <option value="">— nenhuma —</option>
            <option>Administrador</option><option>Diretor</option><option>Gerente</option>
            <option>Trafego</option><option>Layout</option><option>Diagramador</option>
            <option>Digitador</option><option>Revisor</option><option>Site</option>
            <option>Encerramento</option>
          </select>
        </div>
      </div>

      <div class="field">
        <label for="cadGate">Senha de liberação do cadastro</label>
        <input id="cadGate" type="password" placeholder="Informe a senha para autorizar o cadastro" />
        <div class="muted">Inserir senha ADM para cadastro ou entre em contato com adm_ti@vectorpropaganda.com.br.</div>
      </div>

      <div class="actions">
        <button class="btn" type="button" id="btnLimparCadastro">Limpar</button>
        <button class="btn" type="button" data-close="modalCadastro">Cancelar</button>
        <button class="btn primary" type="button" id="btnDoCadastrar">Cadastrar</button>
      </div>
    </form>
  </dialog>

  <!-- MODAL: Reset senha -->
  <dialog id="modalReset">
    <form method="dialog" class="modal" id="formReset">
      <h3>Atualizar senha</h3>
      <div class="field"><label for="resetNome">Nome</label><input id="resetNome" type="text" placeholder="Seu nome completo" /></div>
      <div class="field"><label for="resetEmail">E-mail</label><input id="resetEmail" type="email" placeholder="voce@empresa.com.br" /></div>
      <div class="field">
        <label for="resetCargo">Cargo</label>
        <select id="resetCargo">
          <option value="">— selecione —</option>
          <option>Administrador</option><option>Diretor</option><option>Gerente</option>
          <option>Trafego</option><option>Layout</option><option>Diagramador</option>
          <option>Digitador</option><option>Revisor</option><option>Site</option>
          <option>Encerramento</option>
        </select>
      </div>
      <div id="resetNovaSenhaWrap" class="field" style="display:none">
        <label for="resetNovaSenha">Nova senha</label>
        <input id="resetNovaSenha" type="password" placeholder="Digite a nova senha" />
      </div>
      <div class="actions">
        <button class="btn" type="button" id="btnResetLimpar">Limpar</button>
        <button class="btn" type="button" data-close="modalReset">Cancelar</button>
        <button class="btn" type="button" id="btnResetValidar">Validar</button>
        <button class="btn primary" type="button" id="btnResetAtualizar" style="display:none">Atualizar</button>
      </div>
    </form>
  </dialog>
</div>

<!-- ===== VIEW APP (Jobs) ===== -->
<div id="jobsApp" class="hide" aria-hidden="true">
  <header class="topbar" aria-label="Barra de ações e usuário">
    <div class="left" id="actions">
      <button class="btn primary" id="btnNovo">Novo</button>
      <button class="btn" id="btnExcluir">Excluir</button>
      <button class="btn" id="btnDuplicar">Duplicar</button>
      <button class="btn" id="btnEditar">Editar</button>
      <button class="btn" id="btnFiltrar">Filtrar</button>
      <button class="btn" id="btnEncerrar">Encerrar</button>
      <button class="btn" id="btnFinalizar">Finalizar</button>
      <button class="btn" id="btnVerFinalizados">Visualizar Finalizados</button>
      <button class="btn" id="btnDash">Dashboard</button>
    </div>
    <div class="right" id="userArea">
      <div class="muted">Usuário:</div>
      <div class="userName" id="userName">—</div>
      <span id="cargo1" class="role-chip role-prata" style="display:none"></span>
      <span id="cargo2" class="role-chip role-roxo" style="display:none"></span>
      <button class="btn small" id="btnSair">Sair</button>
    </div>
  </header>

  <main class="content">
    <section class="box" id="mainBox" aria-label="Área principal">
      <div class="tableWrap" style="border:1px solid rgba(255,255,255,.12); border-radius:10px">
        <table aria-label="Cabeçalhos de JOBs">
          <thead>
            <tr>
              <th style="text-align:left;padding:10px 12px;">OT (Ordem de Tabloide)</th>
              <th style="text-align:left;padding:10px 12px;">REGIONAL</th>
              <th style="text-align:left;padding:10px 12px;">TIPO DA LOJA</th>
              <th style="text-align:left;padding:10px 12px;">TIPO DO JOB</th>
              <th style="text-align:left;padding:10px 12px;">NOME TABLOIDE</th>
              <th style="text-align:left;padding:10px 12px;">COMPLEMENTO</th>
              <th style="text-align:left;padding:10px 12px;">ESTADO</th>
              <th style="text-align:left;padding:10px 12px;">FILIAL (S)</th>
              <th style="text-align:left;padding:10px 12px;">VALIDADE INÍCIO</th>
              <th style="text-align:left;padding:10px 12px;">VALIDADE TÉRMINO</th>
              <th style="text-align:left;padding:10px 12px;">PÁGINA (TAMANHO)</th>
              <th style="text-align:left;padding:10px 12px;">PÁGINA (QUANTIDADE)</th>
              <th style="text-align:left;padding:10px 12px;">STATUS</th>
              <th style="text-align:left;padding:10px 12px;">ETAPAS PRODUÇÃO</th>
            </tr>
          </thead>
          <tbody id="jobsBody">
            <tr class="sep-row"><td colspan="14">REGIONAL BA - SE</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL DF - GO - TO</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL MG</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL MS</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL MT - RO - AC</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL NORDESTE 1</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL NORDESTE 2</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL NORTE</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL PR</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL RJ - ES</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL RS</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL SP</td></tr>
            <tr class="sep-row"><td colspan="14">REGIONAL SC</td></tr>
            <tr class="sep-row"><td colspan="14">ESPECIAL NACIONAL</td></tr>
          </tbody>
        </table>
      </div>
    </section>
  </main>
</div>

<!-- ===== MODAL: Novo ===== -->
<dialog id="modalNovo">
  <form method="dialog" class="modal" id="formNovo">
    <h3>Novo tabloide</h3>

    <div class="grid">
      <div class="col-6">
        <label>Regional</label>
        <select id="novoRegional">
          <option value="">— selecione —</option>
          <option>REGIONAL BA - SE</option>
          <option>REGIONAL DF - GO - TO</option>
          <option>REGIONAL MG</option>
          <option>REGIONAL MS</option>
          <option>REGIONAL MT - RO - AC</option>
          <option>REGIONAL NORDESTE 1</option>
          <option>REGIONAL NORDESTE 2</option>
          <option>REGIONAL NORTE</option>
          <option>REGIONAL PR</option>
          <option>REGIONAL RJ - ES</option>
          <option>REGIONAL RS</option>
          <option>REGIONAL SP</option>
          <option>REGIONAL SC</option>
        </select>
      </div>

      <div class="col-3">
        <label>Tipo da loja</label>
        <select id="novoTipoLoja">
          <option value="">— selecione —</option>
          <option>AS</option>
          <option>AT</option>
        </select>
      </div>

      <div class="col-3">
        <label>Tipo do JOB</label>
        <select id="novoTipoJob">
          <option value="">— selecione —</option>
          <option>Tabloide Digital</option>
          <option>Tabloide Impresso</option>
        </select>
      </div>

      <div class="col-6">
        <label>Nome do tabloide</label>
        <div style="display:flex; gap:8px; align-items:center">
          <select id="novoNomeSel" style="flex:1 1 auto; min-width:240px">
            <option value="">— selecione —</option>
          </select>
          <button class="btn small" type="button" id="btnNomeNovo">Novo nome</button>
        </div>
        <!-- espelho opcional -->
        <input id="novoNome" type="hidden" />
      </div>

      <div class="col-6">
        <label>Complemento</label>
        <input id="novoCompl" type="text" placeholder="Opcional" />
      </div>

      <!-- Linha principal de UF/Filial/Data -->
      <div class="col-3">
        <label>Estado</label>
        <div style="display:flex; gap:8px; align-items:center">
          <select id="novoEstado" style="flex:1 1 auto"></select>
          <button class="btn small" type="button" id="novoAddLinha" title="Adicionar linha (UF/Filial/Data)">+</button>
        </div>
      </div>

      <div class="col-3">
        <label>Filial(s)</label>
        <input id="novoFilial" type="text" placeholder="001, 002" />
      </div>

      <div class="col-3">
        <label>Validade início</label>
        <input id="novoIni" type="date" />
      </div>

      <div class="col-3">
        <label>Validade término</label>
        <input id="novoFim" type="date" />
      </div>

      <div class="col-3">
        <label>Página (tamanho)</label>
        <select id="novoTam">
          <option value="">— selecione —</option>
          <option>A3</option>
          <option>A4</option>
        </select>
      </div>

      <div class="col-3">
        <label>Página (quantidade)</label>
        <input id="novoQtd" type="number" min="1" step="1" />
      </div>

      <div class="col-3">
        <label>Ação nacional</label>
        <div class="frow" role="group" aria-label="Ação nacional">
          <label><input type="radio" name="novoAcaoNac" id="novoAcaoNao" value="nao" checked> Não</label>
          <label><input type="radio" name="novoAcaoNac" id="novoAcaoSim" value="sim"> Sim</label>
        </div>
      </div>

      <div class="col-6">
        <label>Ação (quando nacional)</label>
        <div style="display:flex; gap:8px; align-items:center">
          <input id="novoAcaoNome" type="text" placeholder="Escolha/crie uma ação" readonly />
          <button class="btn small" type="button" id="btnEscolherAcao" disabled>Definir ação…</button>
        </div>
        <div class="muted">Se marcar “Sim”, escolha uma ação existente ou crie uma nova (usada em “Especial nacional”).</div>
      </div>

      <div class="col-6">
        <label>Link pasta</label>
        <input id="novoLink" type="url" placeholder="https://... (Google Drive, rede, etc.)" />
      </div>

      <!-- ====== Lista de linhas (repeater) ====== -->
      <div class="col-12" id="novoBatchArea" style="margin-top:8px">
        <div class="muted" style="margin-bottom:6px">Linhas a salvar (UF, Filial(s), Datas). Use o “+” para adicionar.</div>
        <div id="novoBatchList" style="display:flex; flex-direction:column; gap:8px"></div>
      </div>
    </div>

    <div class="actions">
      <button class="btn" type="button" id="btnNovoCancelar">Cancelar</button>
      <button class="btn primary" type="button" id="btnNovoSalvar">Salvar</button>
    </div>
  </form>
</dialog>

<!-- Sub-modal: “Novo nome” -->
<dialog id="modalNomeTab">
  <form method="dialog" class="modal" id="formNomeTab">
    <h3>Novo nome de tabloide</h3>
    <div class="field">
      <label>Nome</label>
      <input id="nomeTabTexto" type="text" placeholder="Ex.: Festival Vinhos, Queijos e Massas" />
      <div class="muted">Será gravado em <strong>nome_tabloide.csv</strong>.</div>
    </div>
    <div class="actions">
      <button class="btn" type="button" id="nomeTabCancelar">Cancelar</button>
      <button class="btn primary" type="button" id="nomeTabSalvar">Salvar</button>
    </div>
  </form>
</dialog>
<!-- ===== MODAL: Novo FIM ===== -->


<!-- ===== MODAL: Editar ===== -->
<dialog id="modalEdit"><form method="dialog" class="modal" id="formEdit">
  <h3>Editar tabloide — <span id="editOT"></span></h3>
  <div class="grid">
    <div class="col-6"><label>Regional</label><select id="editRegional"></select></div>
    <div class="col-3"><label>Tipo da loja</label>
      <select id="editTipoLoja"><option value="">— selecione —</option><option>AS</option><option>AT</option></select>
    </div>
    <div class="col-3"><label>Tipo do JOB</label>
      <select id="editTipoJob"><option value="">— selecione —</option><option>Tabloide Digital</option><option>Tabloide Impresso</option></select>
    </div>
    <div class="col-6"><label>Nome do tabloide</label><input id="editNome" type="text" /></div>
    <div class="col-6"><label>Complemento</label><input id="editCompl" type="text" /></div>
    <div class="col-3"><label>Estado</label><select id="editEstado"></select></div>
    <div class="col-3"><label>Filial(s)</label><input id="editFilial" type="text" /></div>
    <div class="col-3"><label>Validade início</label><input id="editIni" type="date" /></div>
    <div class="col-3"><label>Validade término</label><input id="editFim" type="date" /></div>
    <div class="col-3"><label>Página (tamanho)</label>
      <select id="editTam"><option value="">— selecione —</option><option>A3</option><option>A4</option></select>
    </div>
    <div class="col-3"><label>Página (quantidade)</label><input id="editQtd" type="number" min="1" step="1" /></div>
    <div class="col-12">
      <h4 style="margin:8px 0 6px 0">Etapas de produção</h4>
      <div id="editEtapasList" class="etapasGrid"></div>
    </div>
  </div>
  <div class="actions">
    <button class="btn" type="button" id="btnEditCancelar">Cancelar</button>
    <button class="btn primary" type="button" id="btnEditSalvar">Salvar</button>
  </div>
</form></dialog>

<!-- ===== MODAL: Editar ===== FIM -->

<!-- MODAL: Célula -->
<dialog id="modalCell"><div class="modal">
  <h3 id="cellTitle">Detalhes</h3>
  <div id="cellBody" class="mono"></div>
  <div class="actions"><button class="btn" type="button" id="btnCellFechar">Fechar</button></div>
</div></dialog>

<!-- MODAL: Etapas (lista) -->
<dialog id="modalEtapas"><div class="modal">
  <h3>Etapas de produção — <span id="etapasTitleOT"></span></h3>
  <div id="etapasHead" class="muted" style="margin-bottom:8px"></div>
  <div id="etapasList" class="etapasGrid"></div>
  <div class="actions"><button class="btn" type="button" id="btnEtapasFechar">Fechar</button></div>
</div></dialog>

<!-- MODAL: Adicionar Evento (data/hora automáticas) -->
<dialog id="modalAddEvt"><form method="dialog" class="modal" id="formAddEvt">
  <h3 id="addEvtTitle">Adicionar evento</h3>
  <div id="addEvtFields">
    <div class="field"><label>Responsável</label><input id="addNome" type="text" placeholder="Seu nome" /></div>
    <div class="muted">A data e a hora serão registradas automaticamente ao salvar.</div>
  </div>
  <div class="actions">
    <button class="btn" type="button" id="btnAddEvtCancelar">Cancelar</button>
    <button class="btn primary" type="button" id="btnAddEvtOk">OK</button>
  </div>
</form></dialog>

<!-- MODAL: Ação nacional -->
<dialog id="modalAcao"><form method="dialog" class="modal" id="formAcao">
  <h3>Definir Ação nacional</h3>
  <div class="grid">
    <div class="col-12">
      <label>Ações existentes</label>
      <div id="acaoLista" class="mono" style="max-height:220px; overflow:auto; padding:10px;"></div>
    </div>
    <div class="col-12">
      <label>Criar nova ação</label>
      <input id="acaoNova" type="text" placeholder="Ex.: Primavera Nacional, Semana do Cliente..." />
    </div>
  </div>
  <div class="actions">
    <button class="btn" type="button" id="acaoCancelar">Cancelar</button>
    <button class="btn primary" type="button" id="acaoOk">Pronto</button>
  </div>
</form></dialog>

<!-- MODAL: Encerrar (Aprovados -> Encerrando) -->
<dialog id="modalEncerrar"><div class="modal">
  <h3>Encerrar jobs — Aprovados</h3>
  <div class="grid" style="margin-bottom:10px">
    <div class="col-3">
      <label>Status</label>
      <select id="encStatus" disabled>
        <option value="Aprovado" selected>Aprovado</option>
      </select>
      <div class="muted">Lista inicia com todos em “Aprovado”.</div>
    </div>

<//!editado inicia aqui>

    <div class="col-6">
  <label>Nome do tabloide</label>
  <select id="encNomeSel">
    <option>(todos)</option>
  </select>
  <div class="muted">Carregado de <strong>nome_tabloide.csv</strong> (acentos preservados).</div>
</div>

<//!editado até aqui>

    <div class="col-3">
      <label>Link pasta mãe</label>
      <input id="encLinkFiltro" type="text" placeholder="contém… (opcional)" />
    </div>
  </div>

  <div class="frow" style="justify-content:flex-end">
    <button class="btn" id="encFiltrar" type="button">Filtrar</button>
    <button class="btn" id="encSelTodos" type="button">Selecionar todos</button>
    <button class="btn primary" id="encExecutar" type="button">Encerrar</button>
  </div>

  <div class="list">
    <table>
      <thead>
        <tr>
          <th></th><th>OT</th><th>REGIONAL</th><th>TIPO DA LOJA</th><th>TIPO DO JOB</th>
          <th>NOME TABLOIDE</th><th>COMPLEMENTO</th><th>ESTADO</th><th>FILIAL (S)</th>
          <th>VALIDADE INÍCIO</th><th>VALIDADE TÉRMINO</th><th>PÁGINA (TAMANHO)</th>
          <th>PÁGINA (QUANTIDADE)</th><th>STATUS</th>
        </tr>
      </thead>
      <tbody id="encList"><tr><td colspan="14" class="hint">Carregando aprovados…</td></tr></tbody>
    </table>
  </div>

  <div class="actions"><button class="btn" id="encCancelar" type="button">Fechar</button></div>
</div></dialog>

<!-- MODAL: Filtrar (lista plana) -->
<dialog id="modalFiltro"><div class="modal">
  <h3>Filtrar jobs</h3>
  <div class="grid">
    <div class="col-4"><label>Regional</label><select id="fltRegional"><option>(todas)</option></select></div>
    <div class="col-4"><label>Nome do tabloide</label><input id="fltNome" type="text" placeholder="contém…" /></div>
    <div class="col-2"><label>Validade início</label><input id="fltIni" type="date" /></div>
    <div class="col-2"><label>Validade término</label><input id="fltFim" type="date" /></div>
    <div class="col-3"><label>Status</label>
      <select id="fltStatus">
        <option>(todos)</option><option>Novo</option><option>Lista recebida</option><option>Criando layout</option>
        <option>Digitando</option><option>Diagramando</option><option>Revisando</option>
        <option>Aprovado</option><option>Encerrando</option><option>Site</option><option>Cancelado</option>
      </select>
    </div>
    <div class="col-3"><label>Ação nacional</label>
      <select id="fltNac"><option>(ambos)</option><option>Sim</option><option>Não</option></select>
    </div>
    <div class="col-6">
      <label>Selecionar Ação (quando nacional)</label>
      <select id="fltAcao"><option>(todas)</option></select>
      <div class="muted">Lista com as ações criadas em “Especial nacional”.</div>
    </div>
  </div>

  <div class="frow" style="justify-content:flex-end">
    <button class="btn" id="fltLimpar" type="button">Limpar</button>
    <button class="btn primary" id="fltAplicar" type="button">Aplicar</button>
  </div>

  <div class="list" style="margin-top:10px">
    <table>
      <thead>
        <tr>
          <th>OT</th><th>REGIONAL</th><th>TIPO DA LOJA</th><th>TIPO DO JOB</th>
          <th>NOME TABLOIDE</th><th>COMPLEMENTO</th><th>ESTADO</th><th>FILIAL (S)</th>
          <th>VALIDADE INÍCIO</th><th>VALIDADE TÉRMINO</th><th>PÁGINA (TAMANHO)</th>
          <th>PÁGINA (QUANTIDADE)</th><th>STATUS</th>
        </tr>
      </thead>
      <tbody id="fltList"><tr><td colspan="13" class="hint">Defina os filtros e clique em “Aplicar”.</td></tr></tbody>
    </table>
  </div>

  <div class="actions"><button class="btn" id="fltFechar" type="button">Fechar</button></div>
</div></dialog>

<!-- MODAIS: Duplicar -->
<dialog id="modalDup1"><div class="modal">
  <h3>Duplicar jobs — Seleção</h3>

  <div class="frow" style="gap:10px; flex-wrap:wrap">
    <div style="flex:1 1 200px">
      <label>Origem dos jobs</label>
      <select id="dupFonte">
        <option value="jobs.csv">JOBS LANÇADOS</option>
        <option value="jobs_encerrados.csv">JOBS FINALIZADOS</option>
      </select>
    </div>

    <div style="flex:1 1 220px">
      <label>Regional</label>
      <select id="dupReg"></select>
    </div>

    <div style="flex:2 1 260px">
      <label>Nome do tabloide</label>
      <!-- vira SELECT via JS (lista de nome_tabloide.csv) -->
      <input id="dupNome" type="text" placeholder="(todas)" />
    </div>

    <div style="align-self:flex-end">
      <button class="btn" id="dupFiltrar" type="button">Filtrar</button>
    </div>
    <div style="align-self:flex-end">
      <button class="btn" id="dupSelTodos" type="button">Selecionar todos</button>
    </div>
    <div style="align-self:flex-end">
      <button class="btn" id="dupSelNenhum" type="button">Limpar seleção</button>
    </div>
  </div>

  <div class="list">
    <table>
      <thead>
        <tr><th></th><th>OT</th><th>Regional</th><th>Nome</th><th>Status</th></tr>
      </thead>
      <tbody id="dupList">
        <tr><td colspan="5" class="hint">Sem resultados. Use os filtros acima.</td></tr>
      </tbody>
    </table>
  </div>

  <div class="actions">
    <button class="btn" id="dup1Cancelar" type="button">Cancelar</button>
    <button class="btn primary" id="dup1Avancar" type="button">Avançar</button>
  </div>
</div></dialog>

<dialog id="modalDup2"><form method="dialog" class="modal" id="formDup2">
  <h3>Duplicar jobs — Parâmetros</h3>
  <div class="grid">
    <div class="col-3"><label>Tipo do JOB</label>
      <select id="dupTipoJob">
        <option value="">— selecione —</option>
        <option>Tabloide Digital</option>
        <option>Tabloide Impresso</option>
      </select>
    </div>

    <div class="col-12 dup-nome-col"><label>Nome do tabloide</label>
      <!-- vira SELECT via JS (lista de nome_tabloide.csv) -->
      <input id="dupNomeNovo" type="text" placeholder="Novo nome comum para os duplicados" />
    </div>

    <div class="col-3"><label>Validade início</label><input id="dupIni" type="date" /></div>
    <div class="col-3"><label>Validade término</label><input id="dupFim" type="date" /></div>
    <div class="col-3"><label>Página (tamanho)</label>
      <select id="dupTam"><option value="">— selecione —</option><option>A3</option><option>A4</option></select>
    </div>
    <div class="col-3"><label>Página (quantidade)</label><input id="dupQtd" type="number" min="1" step="1" /></div>

    <div class="col-3">
      <label>Ação nacional</label>
      <div class="frow" role="group">
        <label><input type="radio" name="dupAcaoNac" id="dupAcaoNao" value="nao" checked> Não</label>
        <label><input type="radio" name="dupAcaoNac" id="dupAcaoSim" value="sim"> Sim</label>
      </div>
    </div>

    <div class="col-9">
      <label>Ação (quando nacional)</label>
      <div style="display:flex; gap:8px; align-items:center">
        <!-- SELECT de ações existentes é inserido antes deste input -->
        <input id="dupAcaoNome" type="text" placeholder="Escolha/crie uma ação" readonly />
        <button class="btn small" type="button" id="btnDupEscolherAcao" disabled>Definir ação…</button>
      </div>
    </div>

    <div class="col-12" id="dupResumo" class="muted"></div>
  </div>

  <div class="actions">
    <button class="btn" type="button" id="dup2Voltar">Cancelar</button>
    <button class="btn" type="button" id="dup2Limpar">Limpar</button>
    <button class="btn primary" type="button" id="dup2Lancar">Lançar</button>
  </div>
</form></dialog>


<!-- MODAL: Finalizar -->
<dialog id="modalFinalizar"><div class="modal">
  <h3>Finalizar jobs — Site e Cancelados</h3>
  <div class="list" style="margin-top:8px">
    <table>
      <thead><tr><th></th><th>OT</th><th>Nome</th><th>Regional</th><th>Status atual</th></tr></thead>
      <tbody id="finList"><tr><td colspan="5" class="hint">Nenhum job em Site ou Cancelado.</td></tr></tbody>
    </table>
  </div>
  <div class="actions">
    <button class="btn" id="finCancelar" type="button">Cancelar</button>
    <button class="btn" id="finTodos" type="button">Finalizar todos</button>
    <button class="btn primary" id="finSalvar" type="button">Finalizar selecionados</button>
  </div>
</div></dialog>

<!-- MODAL: Visualizar Finalizados (com filtros) -->
<dialog id="modalFinalizados"><div class="modal">
  <h3>Jobs finalizados</h3>

  <div class="frow" id="finzToolbar" style="gap:10px;flex-wrap:wrap;justify-content:flex-end">
    <div style="flex:1 1 220px;min-width:220px">
      <label>Regional</label>
      <select id="finzReg">
        <option value="(todas)">(todas)</option>
        <!-- opções reais são preenchidas via JS com base no CSV -->
      </select>
    </div>
    <div style="flex:0 0 160px;min-width:160px">
      <label>Período — Início</label>
      <input id="finzIni" type="date">
    </div>
    <div style="flex:0 0 160px;min-width:160px">
      <label>Período — Término</label>
      <input id="finzFim" type="date">
    </div>
    <div style="align-self:flex-end">
      <button class="btn" id="finzFiltrar" type="button">Aplicar filtro</button>
    </div>
    <div style="align-self:flex-end">
      <button class="btn" id="finzFechar" type="button">Fechar</button>
    </div>
  </div>

  <div class="list">
    <table>
      <thead>
        <tr>
          <th>OT</th><th>REGIONAL</th><th>TIPO DO JOB</th>
          <th>NOME TABLOIDE</th><th>COMPLEMENTO</th><th>UF</th><th>FILIAL(S)</th>
          <th>INI</th><th>FIM</th><th>TAM</th><th>QTD</th>
        </tr>
      </thead>
      <tbody id="finzList">
        <tr><td colspan="11" class="hint">Carregando finalizados…</td></tr>
      </tbody>
    </table>
  </div>
</div></dialog>


<!-- MODAL: Dashboard -->
<dialog id="modalDash"><div class="modal">
  <h3>Dashboard — Produtividade por setor</h3>
  <div class="grid">
    <div class="col-3"><label>Período — início</label><input id="dashIni" type="date" /></div>
    <div class="col-3"><label>Período — término</label><input id="dashFim" type="date" /></div>
    <div class="col-3"><label>Status (opcional)</label>
      <select id="dashStatus">
        <option>(todos)</option><option>Novo</option><option>Lista recebida</option><option>Criando layout</option>
        <option>Digitando</option><option>Diagramando</option><option>Revisando</option>
        <option>Aprovado</option><option>Encerrando</option><option>Site</option><option>Cancelado</option><option>Finalizado</option>
      </select>
    </div>
    <div class="col-3" style="display:flex;align-items:flex-end"><button class="btn primary" id="dashAplicar" type="button">Aplicar</button></div>
  </div>

  <div id="dashOut" class="list" style="margin-top:10px;max-height:55vh;overflow:auto">
    <table>
      <thead><tr><th>Setor</th><th>Pessoa</th><th>Eventos no período</th></tr></thead>
      <tbody id="dashBody"><tr><td colspan="3" class="hint">Defina o período e clique em “Aplicar”.</td></tr></tbody>
    </table>
  </div>

  <div class="actions"><button class="btn" id="dashFechar" type="button">Fechar</button></div>
</div></dialog>

<div id="busy"><div class="box">Sincronizando…</div></div>
<div id="toast"></div>

<!-- MODAL: Excluir jobs -->
<dialog id="modalExcluir"><div class="modal">
  <h3>Excluir jobs</h3>

  <div class="frow" style="gap:10px;flex-wrap:wrap">
    <div style="flex:1 1 220px;min-width:220px">
      <label>Regional</label>
      <select id="exReg">
        <option value="(todas)">(todas)</option>
      </select>
    </div>

    <div style="flex:1 1 260px;min-width:240px">
      <label>Nome do tabloide</label>
      <select id="exNome">
        <option value="(todos)">(todos)</option>
      </select>
    </div>

    <div style="flex:0 0 160px;min-width:160px">
      <label>Data início</label>
      <input id="exIni" type="date">
    </div>

    <div style="flex:0 0 160px;min-width:160px">
      <label>Data término</label>
      <input id="exFim" type="date">
    </div>

    <div style="align-self:flex-end">
      <button class="btn" id="exFiltrar" type="button">Aplicar filtro</button>
    </div>
    <div style="align-self:flex-end">
      <button class="btn" id="exSelTodos" type="button">Selecionar todos</button>
    </div>
    <div style="align-self:flex-end">
      <button class="btn" id="exSelNenhum" type="button">Limpar</button>
    </div>
  </div>

  <div class="list" style="margin-top:10px">
    <table>
      <thead>
        <tr>
          <th></th>
          <th>OT</th>
          <th>REGIONAL</th>
          <th>TIPO DO JOB</th>
          <th>NOME TABLOIDE</th>
          <th>UF</th>
          <th>FILIAL(S)</th>
          <th>INI</th>
          <th>FIM</th>
          <th>TAM</th>
          <th>QTD</th>
          <th>STATUS</th>
        </tr>
      </thead>
      <tbody id="exList">
        <tr><td colspan="12" class="hint">Carregando…</td></tr>
      </tbody>
    </table>
  </div>

  <div class="actions">
    <button class="btn" id="exCancelar" type="button">Cancelar</button>
    <button class="btn danger" id="exExcluir" type="button">Excluir selecionados</button>
  </div>
</div></dialog>

<!//--------------------------------------------------------------------------BOTÕES-----------------------------------------------------------------------//>

<//INICIO BOTÃO CONFGI GITHUB/>
<!-- // BOTÃO CONFIGURAR GITHUB -->
<script>
  (function () {
    const btn = document.getElementById('btnCfg');
    const modal = document.getElementById('modalCfg');
    if (btn && modal) {
      btn.addEventListener('click', () => modal.showModal());
    }
  })();
</script>

<!-- // BOTÕES CONFIG GITHUB — CANCELAR + SALVAR -->
<script>
  (function () {
    const dlg         = document.getElementById('modalCfg');
    const btnCancel   = document.querySelector('#modalCfg [data-close="modalCfg"]');
    const btnSave     = document.getElementById('btnCfgSalvar');
    const inputToken  = document.getElementById('cfgToken');
    const chkRemember = document.getElementById('cfgRemember');

    // Cancelar: fecha o modal
    if (btnCancel && dlg) {
      btnCancel.addEventListener('click', () => dlg.close());
    }

    // Salvar: lê token, (opcional) salva no localStorage e fecha o modal
    if (btnSave && dlg && inputToken) {
      btnSave.addEventListener('click', () => {
        const token = (inputToken.value || '').trim();
        const remember = !!(chkRemember && chkRemember.checked);

        // deixa disponível em memória (caso você use depois)
        window.gh = window.gh || {};
        window.gh.token = token;

        // persistência opcional
        try {
          if (remember) {
            localStorage.setItem('wv_gh_cfg', JSON.stringify({ token }));
          } else {
            localStorage.removeItem('wv_gh_cfg');
          }
        } catch (e) { /* ignore */ }

        dlg.close();
      });
    }
  })();
</script>

<!-- // BOTÃO CADASTRAR -->
<script>
  (function () {
    const btn  = document.getElementById('btnCadastrar');
    const dlg  = document.getElementById('modalCadastro');
    const form = document.getElementById('formCadastro');

    if (btn && dlg) {
      btn.addEventListener('click', () => {
        if (form) form.reset(); // abre o modal com o formulário limpo
        dlg.showModal();
      });
    }
  })();
</script>

<!-- // CADASTRO: LIMPAR • CANCELAR • CADASTRAR (grava em users.csv no GitHub) -->
<script>
(function () {
  /* ====== AJUSTE AQUI SE PRECISAR ====== */
  const GH = {
    owner:  'JPVectorsitem',       // <- dono da conta/org no GitHub
    repo:   'LINKS-img',           // <- repositório
    branch: 'main',                // <- branch
    usersPath: 'users.csv'         // <- caminho do arquivo de usuários
  };
  const CAD_GATE = 'WKflvec104tp1408'; // senha de liberação do cadastro

  /* ====== ELEMENTOS ====== */
  const dlg   = document.getElementById('modalCadastro');
  const form  = document.getElementById('formCadastro');
  const btnL  = document.getElementById('btnLimparCadastro');
  const btnC  = document.querySelector('#modalCadastro [data-close="modalCadastro"]');
  const btnOK = document.getElementById('btnDoCadastrar');

  /* ====== UTILS ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { alert(msg); return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if (msg) o.querySelector('.box').textContent = msg;
  }
  function nowISO(){ return new Date().toISOString(); }

  // Pega token salvo pelo modal "Configurar GitHub"
  function getToken(){
    try {
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg') || '{}');
      // prioridade para token em memória se você tiver definido window.gh.token
      return (window.gh && window.gh.token) || saved.token || '';
    } catch { return (window.gh && window.gh.token) || ''; }
  }

  // CSV helpers (simples e seguro p/ vírgulas e quebras)
  const csvEsc = v => {
    v = v == null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  const toCsvLine = arr => arr.map(csvEsc).join(',');

  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){ cur+='"'; i++; } else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjects(t){
    const rows=parseCsv(t); if(!rows.length) return [];
    const H=rows[0]; const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return out;
  }
  function objectsToCsv(H, objs){
    const head = H.join(',')+'\n';
    const body = objs.map(o=> toCsvLine(H.map(h=> o[h] ?? '')) ).join('\n');
    return head + body + (body ? '\n' : '');
  }

  // GitHub helpers
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }

  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token){ throw new Error('Token GitHub não configurado.'); }
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler arquivo no GitHub ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToUtf8(j.content) : '';
    return { text: content, sha: j.sha || null };
  }

  async function ghPutFile(path, newText, message){
    const token = getToken();
    if(!token){ throw new Error('Token GitHub não configurado.'); }
    // Primeiro descobre se existe para pegar o SHA
    let sha = null;
    try {
      const cur = await ghGetFile(path, GH.branch);
      sha = cur.sha;
    } catch (e) {
      // se der 404 acima, seguimos com sha = null para criar
    }
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: message || `chore(csv): update ${path}`,
      content: utf8ToB64(newText),
      branch: GH.branch,
      ...(sha ? { sha } : {})
    };
    const r = await fetch(url, {
      method: 'PUT',
      headers: { ...ghHeaders(token), 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!r.ok) {
      const txt = await r.text();
      throw new Error('Falha ao salvar no GitHub ('+r.status+'): '+txt);
    }
    return true;
  }

  async function appendUserRow(user){
    // Lê users.csv (ou cria com cabeçalho)
    const HEAD = ['nome','email','senha','cargo_principal','cargo_secundaria','criado_em'];
    const { text } = await ghGetFile(GH.usersPath, GH.branch);
    let list = [];
    if (!text) {
      list = [];
    } else {
      list = csvToObjects(text);
    }

    // checa duplicidade por e-mail (case-insensitive)
    const emailEq = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();
    if (list.some(u => emailEq(u.email, user.email))) {
      throw new Error('E-mail já cadastrado.');
    }

    list.push(user);
    const csv = objectsToCsv(HEAD, list);
    await ghPutFile(GH.usersPath, csv, `chore(csv): add user ${user.email}`);
  }

  /* ====== HANDLERS ====== */
  // LIMPAR
  if (btnL && form) {
    btnL.addEventListener('click', () => form.reset());
  }

  // CANCELAR
  if (btnC && dlg) {
    btnC.addEventListener('click', () => dlg.close());
  }

  // CADASTRAR (grava no users.csv)
  if (btnOK && form && dlg) {
    btnOK.addEventListener('click', async () => {
      const nome   = (document.getElementById('cadNome')?.value || '').trim();
      const email  = (document.getElementById('cadEmail')?.value || '').trim();
      const senha  = (document.getElementById('cadSenha')?.value || '').trim();
      const cargoP = (document.getElementById('cadCargoP')?.value || '').trim();
      const cargoS = (document.getElementById('cadCargoS')?.value || '').trim();
      const gate   = (document.getElementById('cadGate')?.value || '').trim();

      // validações básicas
      if (!nome || !email || !senha || !cargoP) {
        toast('Preencha Nome, E-mail, Senha e Cargo PRINCIPAL.');
        return;
      }
      if (!/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email)) {
        toast('E-mail inválido.');
        return;
      }
      if (!gate) {
        toast('Informe a senha de liberação.');
        return;
      }
      if (gate !== CAD_GATE) {
        toast('Senha de liberação inválida.');
        return;
      }
      if (!getToken()) {
        toast('Configurar GitHub primeiro (⚙).');
        return;
      }

      // grava
      setBusy(true, 'Salvando cadastro…');
      try {
        await appendUserRow({
          nome,
          email,
          senha,
          cargo_principal: cargoP,
          cargo_secundaria: cargoS,
          criado_em: nowISO()
        });
        toast('Cadastro salvo.');
        form.reset();
        dlg.close();
      } catch (e) {
        console.error(e);
        toast(e.message || 'Erro ao cadastrar.');
      } finally {
        setBusy(false);
      }
    });
  }
})();
</script>

<!-- // CADASTRO: LIMPAR • CANCELAR • CADASTRAR (grava em users.csv no GitHub) - FIM -->

<!-- // ESQUECI A SENHA: abrir modal + LIMPAR • CANCELAR • VALIDAR • ATUALIZAR -->
<script>
(function () {
  /* ====== CONFIG GITHUB (ajuste se precisar) ====== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    usersPath: 'users.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnOpen   = document.getElementById('btnEsqueci');
  const dlg       = document.getElementById('modalReset');
  const form      = document.getElementById('formReset');
  const btnLimpar = document.getElementById('btnResetLimpar');
  const btnCancel = document.querySelector('#modalReset [data-close="modalReset"]');
  const btnValid  = document.getElementById('btnResetValidar');
  const btnAtual  = document.getElementById('btnResetAtualizar');
  const wrapNova  = document.getElementById('resetNovaSenhaWrap');

  /* ====== CAMPOS ====== */
  const inpNome   = document.getElementById('resetNome');
  const inpEmail  = document.getElementById('resetEmail');
  const selCargo  = document.getElementById('resetCargo');
  const inpNova   = document.getElementById('resetNovaSenha');

  /* ====== STATE ====== */
  let _users = [];
  let _idx   = -1;

  /* ====== UTILS ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { alert(msg); return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if (msg) o.querySelector('.box').textContent = msg;
  }
  function getToken(){
    try {
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg') || '{}');
      return (window.gh && window.gh.token) || saved.token || '';
    } catch { return (window.gh && window.gh.token) || ''; }
  }
  const eqi = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();

  // CSV helpers
  const csvEsc = v => {
    v = v == null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  const toCsvLine = arr => arr.map(csvEsc).join(',');
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){ cur+='"'; i++; } else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjects(t){
    const rows=parseCsv(t); if(!rows.length) return [];
    const H=rows[0]; const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return out;
  }
  function objectsToCsv(H, objs){
    const head = H.join(',')+'\n';
    const body = objs.map(o=> toCsvLine(H.map(h=> o[h] ?? '')) ).join('\n');
    return head + body + (body ? '\n' : '');
  }

  // GitHub helpers
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token) throw new Error('Token GitHub não configurado.');
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToUtf8(j.content) : '';
    return { text: content, sha: j.sha || null };
  }
  async function ghPutFile(path, newText, message){
    const token = getToken();
    if(!token) throw new Error('Token GitHub não configurado.');
    // pega SHA atual (se existir)
    let sha = null;
    try { const cur = await ghGetFile(path, GH.branch); sha = cur.sha; } catch {}
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: message || `chore(csv): update ${path}`,
      content: utf8ToB64(newText),
      branch: GH.branch,
      ...(sha ? { sha } : {})
    };
    const r = await fetch(url, {
      method: 'PUT',
      headers: { ...ghHeaders(token), 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!r.ok) throw new Error('Falha ao salvar ('+r.status+')');
    return true;
  }

  async function loadUsers(){
    const { text } = await ghGetFile(GH.usersPath, GH.branch);
    return csvToObjects(text);
  }
  async function saveUsers(list){
    const HEAD = ['nome','email','senha','cargo_principal','cargo_secundaria','criado_em'];
    const csv = objectsToCsv(HEAD, list);
    await ghPutFile(GH.usersPath, csv, `chore(csv): update ${GH.usersPath}`);
  }

  function hideUpdateUI(){
    if (wrapNova) wrapNova.style.display = 'none';
    if (btnAtual) btnAtual.style.display = 'none';
    if (inpNova) inpNova.value = '';
    _idx = -1;
  }
  function showUpdateUI(){
    if (wrapNova) wrapNova.style.display = 'block';
    if (btnAtual) btnAtual.style.display = 'inline-block';
  }

  /* ====== ABRIR MODAL (Esqueci minha senha/e-mail!) ====== */
  if (btnOpen && dlg) {
    btnOpen.addEventListener('click', () => {
      if (form) form.reset();
      hideUpdateUI();
      dlg.showModal();
    });
  }

  /* ====== LIMPAR ====== */
  if (btnLimpar && form) {
    btnLimpar.addEventListener('click', () => {
      form.reset();
      hideUpdateUI();
    });
  }

  /* ====== CANCELAR ====== */
  if (btnCancel && dlg) {
    btnCancel.addEventListener('click', () => {
      hideUpdateUI();
      dlg.close();
    });
  }

  /* ====== VALIDAR (confere Nome + E-mail + Cargo) ====== */
  if (btnValid) {
    btnValid.addEventListener('click', async () => {
      const nome  = (inpNome?.value  || '').trim();
      const email = (inpEmail?.value || '').trim();
      const cargo = (selCargo?.value || '').trim();

      if (!nome || !email || !cargo) {
        toast('Preencha Nome, E-mail e Cargo.');
        hideUpdateUI();
        return;
      }
      if (!getToken()) {
        toast('Configurar GitHub primeiro (⚙).');
        hideUpdateUI();
        return;
      }

      setBusy(true,'Validando…');
      try {
        _users = await loadUsers();

        // procura por Nome+Email+Cargo (aceita cargo_principal, cargo_secundaria ou cargo)
        _idx = _users.findIndex(u =>
          eqi(u.nome, nome) &&
          eqi(u.email, email) &&
          ( eqi(u.cargo_principal, cargo) || eqi(u.cargo_secundaria, cargo) || eqi(u.cargo, cargo) )
        );

        if (_idx === -1) {
          toast('Nome/E-mail/Cargo não correspondente.');
          hideUpdateUI();
        } else {
          showUpdateUI();
        }
      } catch (e) {
        console.error(e);
        toast('Erro ao validar.');
        hideUpdateUI();
      } finally {
        setBusy(false);
      }
    });
  }

  /* ====== ATUALIZAR (salva nova senha no users.csv) ====== */
  if (btnAtual) {
    btnAtual.addEventListener('click', async () => {
      if (_idx < 0 || !_users.length) {
        toast('Valide seus dados primeiro.');
        return;
      }
      const nova = (inpNova?.value || '').trim();
      if (!nova) {
        toast('Digite a nova senha.');
        return;
      }
      _users[_idx].senha = nova;

      setBusy(true,'Salvando…');
      try {
        await saveUsers(_users);
        toast('Senha atualizada!');
        if (form) form.reset();
        hideUpdateUI();
        dlg?.close();
      } catch (e) {
        console.error(e);
        toast('Erro ao salvar.');
      } finally {
        setBusy(false);
      }
    });
  }
})();
</script>

<!-- // ESQUECI A SENHA: abrir modal + LIMPAR • CANCELAR • VALIDAR • ATUALIZAR - FIM-->

<!-- BOTÃO LOGIN — lê users.csv no GitHub, valida e abre a área de trabalho (jobs) [versão TURBO] -->
<script>
(function () {
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    usersPath: 'users.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnLogin  = document.getElementById('btnLogin');
  const inpEmail  = document.getElementById('email');
  const inpSenha  = document.getElementById('senha');

  const loginView = document.getElementById('loginView');
  const jobsApp   = document.getElementById('jobsApp');

  const elUserName = document.getElementById('userName');
  const chip1 = document.getElementById('cargo1');
  const chip2 = document.getElementById('cargo2');

  /* ====== UTILS ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { alert(msg); return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if (msg) o.querySelector('.box').textContent = msg;
  }
  function getToken(){
    try {
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg') || '{}');
      return (window.gh && window.gh.token) || saved.token || '';
    } catch { return (window.gh && window.gh.token) || ''; }
  }
  const eqi = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();

  // CSV helpers
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){ cur+='"'; i++; } else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){ }
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjects(t){
    const rows=parseCsv(t); if(!rows.length) return [];
    const H=rows[0]; const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return out;
  }

  // GitHub helpers
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token){ throw new Error('Token GitHub não configurado.'); }
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler arquivo no GitHub ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToUtf8(j.content) : '';
    return { text: content, sha: j.sha || null };
  }

  // UI helpers
  function roleKey(c){
    const k=(c||'').trim().toLowerCase();
    if(['administrador','administrator','diretor','gerente'].includes(k)) return 'prata';
    if(k==='trafego') return 'verde';
    if(k==='layout') return 'roxo';
    if(k==='digitador') return 'azul';
    if(k==='diagramador') return 'laranja';
    if(k==='revisor') return 'rosa';
    if(k==='encerramento') return 'amarelo';
    if(k==='site') return 'roxoclaro';
    return 'prata';
  }
  function showJobsApp(user){
    if (elUserName) elUserName.textContent = user?.nome || '—';
    if (chip1) {
      const c1 = user?.cargo_principal || user?.cargo || '';
      if (c1) {
        chip1.textContent = c1;
        chip1.className = 'role-chip role-' + roleKey(c1);
        chip1.style.display = 'inline-block';
      } else chip1.style.display = 'none';
    }
    if (chip2) {
      const c2 = user?.cargo_secundaria || '';
      if (c2) {
        chip2.textContent = c2;
        chip2.className = 'role-chip role-' + roleKey(c2);
        chip2.style.display = 'inline-block';
      } else chip2.style.display = 'none';
    }
    if (loginView) { loginView.classList.add('hide'); loginView.setAttribute('aria-hidden','true'); }
    if (jobsApp)   { jobsApp.classList.remove('hide'); jobsApp.setAttribute('aria-hidden','false'); }
    if (typeof window.applyPermissions === 'function') window.applyPermissions();
  }

  async function handleLogin(){
    const email = (inpEmail?.value || '').trim();
    const senha = (inpSenha?.value || '').trim();

    if (!email || !senha) { toast('Informe e-mail e senha.'); return; }
    if (!getToken())      { toast('Configurar GitHub primeiro (⚙).'); return; }

    setBusy(true, 'Lendo usuários…');
    try {
      const { text } = await ghGetFile(GH.usersPath, GH.branch);
      const list = csvToObjects(text); // cabeçalho: nome,email,senha,cargo_principal,cargo_secundaria,criado_em

      const user = list.find(u => eqi(u.email, email) && (u.senha === senha));
      if (!user) { toast('Credenciais inválidas.'); return; }

      window.currentUser = {
        nome: user.nome || email.split('@')[0],
        cargo_principal: user.cargo_principal || user.cargo || '',
        cargo_secundaria: user.cargo_secundaria || ''
      };

      toast(`Login OK. Bem-vindo, ${window.currentUser.nome}!`);
      showJobsApp(user);

      // === TURBO LOAD do jobs.csv ===
      if (window.TurboJobs && typeof window.TurboJobs.mount === 'function') {
        await window.TurboJobs.mount();
      } else if (typeof window.loadJobsCsv === 'function' && typeof window.insertJobRow === 'function') {
        // fallback antigo
        setBusy(true,'Carregando jobs…');
        await window.loadJobsCsv();
        document.querySelectorAll('#jobsBody tr[data-ot]').forEach(tr=>tr.remove());
        [...window.JOBS.values()]
          .sort((a,b)=> a.ot.localeCompare(b.ot, undefined, {numeric:true, sensitivity:'base'}))
          .forEach(window.insertJobRow);
      }
    } catch (e) {
      console.error(e);
      toast('Falha ao carregar usuários.');
    } finally {
      setBusy(false);
    }
  }

  if (btnLogin) btnLogin.addEventListener('click', handleLogin);
  // Enter na tela de login
  document.addEventListener('keydown', (e)=>{
    if (e.key !== 'Enter') return;
    const visibleLogin = loginView && !loginView.classList.contains('hide');
    if (visibleLogin) handleLogin();
  });
})();
</script>
<!-- // BOTÃO LOGIN — FIM -->


<!//---------------------------------------------------------FIM DOS BOTÕES TELA LOGIN--------------------------------------------------------------//>

<!//--------------------------------------------------------____INICIO BOTÕES JOBS____--------------------------------------------------------------//>

<!-- // BOTÃO SAIR (segunda tela / jobs) -->
<script>
(function () {
  const btnSair   = document.getElementById('btnSair');
  const loginView = document.getElementById('loginView');
  const jobsApp   = document.getElementById('jobsApp');

  const elUserName = document.getElementById('userName');
  const chip1 = document.getElementById('cargo1');
  const chip2 = document.getElementById('cargo2');

  const inpEmail = document.getElementById('email');
  const inpSenha = document.getElementById('senha');

  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 1800);
  }

  function showLogin(){
    if (jobsApp) {
      jobsApp.classList.add('hide');
      jobsApp.setAttribute('aria-hidden','true');
    }
    if (loginView) {
      loginView.classList.remove('hide');
      loginView.setAttribute('aria-hidden','false');
    }
  }

  if (btnSair) {
    btnSair.addEventListener('click', () => {
      // limpa estado em memória (se estiver usando)
      window.currentUser = null;

      // reseta cabeçalho do usuário
      if (elUserName) elUserName.textContent = '—';
      if (chip1) { chip1.style.display = 'none'; chip1.textContent = ''; }
      if (chip2) { chip2.style.display = 'none'; chip2.textContent = ''; }

      // volta para a tela de login
      showLogin();

      // opcional: limpa campos de login e foca no e-mail
      if (inpSenha) inpSenha.value = '';
      if (inpEmail) { inpEmail.focus(); }

      toast('Sessão encerrada.');
    });
  }
})();
</script>

<!-- // BOTÃO SAIR (segunda tela / jobs) FIM-->

<!-- // CARREGAR JOBS DE jobs.csv E POPULAR A TABELA DA ÁREA DE TRABALHO -->
<script>
(function () {
  /* ====== CONFIG GITHUB (ajuste se precisar) ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv'
  };

  /* ====== ELEMENTOS ====== */
  const jobsApp  = document.getElementById('jobsApp');
  const tbody    = document.getElementById('jobsBody');

  /* ====== UX helpers ====== */
  function toast(msg){
    const el = document.getElementById('toast');
    if (!el) { return; }
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(()=> el.style.display='none', 2200);
  }
  function setBusy(v,msg){
    const o=document.getElementById('busy');
    if(!o) return;
    o.style.display = v ? 'grid' : 'none';
    if (msg) o.querySelector('.box').textContent = msg;
  }
  function getToken(){
    try {
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg') || '{}');
      return (window.gh && window.gh.token) || saved.token || '';
    } catch { return (window.gh && window.gh.token) || ''; }
  }

  /* ====== CSV helpers ====== */
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){ cur+='"'; i++; } else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjects(t){
    const rows=parseCsv(t); if(!rows.length) return [];
    const H=rows[0]; const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return out;
  }

  /* ====== GitHub helpers ====== */
  const GH_API_VER = '2022-11-28';
  const ghHeaders = (token) => ({
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': GH_API_VER,
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  });
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  async function ghGetFile(path, branch){
    const token = getToken();
    if(!token){ throw new Error('Token GitHub não configurado.'); }
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('Falha ao ler arquivo no GitHub ('+r.status+')');
    const j = await r.json();
    const content = j && j.content ? b64ToUtf8(j.content) : '';
    return { text: content, sha: j.sha || null };
  }

  /* ====== Render helpers ====== */
  const eqi = (a,b)=> (a||'').trim().toLowerCase() === (b||'').trim().toLowerCase();
  function parseBool(v){ return ['1','true','sim','yes'].includes(String(v||'').trim().toLowerCase()); }
  function statusToClass(status){
    const s=(status||'').toLowerCase();
    if(s==='novo') return 'st-novo';
    if(s==='lista recebida') return 'st-lista';
    if(s==='criando layout') return 'st-layout';
    if(s==='digitando') return 'st-digitando';
    if(s==='diagramando') return 'st-diagramando';
    if(s==='revisando') return 'st-revisando';
    if(s==='aprovado') return 'st-aprovado';
    if(s==='encerrando') return 'st-encerrando';
    if(s==='site') return 'st-site';
    if(s==='cancelado') return 'st-cancelado';
    if(s==='finalizado') return 'st-finalizado';
    return '';
  }

  // acha o header de uma regional (tr.sep-row) pelo texto
  function findRegionalHeader(name){
    const rows = tbody ? tbody.querySelectorAll('tr.sep-row') : null;
    if (!rows) return null;
    name = (name||'').trim();
    for (const r of rows) {
      if ((r.textContent || '').trim() === name) return r;
    }
    return null;
  }

  // garante a sub-row "AÇÃO — X" dentro de ESPECIAL NACIONAL
  function ensureActionSubRow(actionName){
    if (!tbody) return null;
    const name = (actionName || '').trim();
    if (!name) return null;
    let sub = tbody.querySelector(`tr.sub-row[data-sub="${CSS.escape(name)}"]`);
    if (sub) return sub;

    sub = document.createElement('tr');
    sub.className = 'sub-row';
    sub.setAttribute('data-sub', name);
    const td = document.createElement('td');
    td.colSpan = 14;
    td.textContent = `AÇÃO — ${name}`;
    sub.appendChild(td);

    const header = findRegionalHeader('ESPECIAL NACIONAL');
    if (header) header.after(sub);
    else tbody.appendChild(sub);

    return sub;
  }

  // insere tr após o último item dentro do mesmo grupo (regional ou sub-ação)
  function insertAfterGroup(anchorRow, tr, matchAttr){
    // percorre a frente até outro "sep-row" (novo grupo) ou sub-row diferente
    let cursor = anchorRow;
    let last = anchorRow;
    while (cursor && (cursor = cursor.nextElementSibling)) {
      if (cursor.classList.contains('sep-row')) break;
      if (cursor.classList.contains('sub-row') && matchAttr === 'data-sub') {
        // parou quando mudou a ação
        if (cursor.getAttribute('data-sub') !== anchorRow.getAttribute('data-sub')) break;
      }
      // se for linha comum, mas pertencer a outro sub-grupo, para
      if (!cursor.classList.contains('sep-row') && !cursor.classList.contains('sub-row')) {
        if (matchAttr) {
          const a = (cursor.getAttribute(matchAttr) || '');
          const b = (anchorRow.getAttribute(matchAttr) || '');
          if (a !== b) break;
        }
      }
      last = cursor;
    }
    last.after(tr);
  }

  function insertUnderRegional(headerRow, tr){
    if (!headerRow) { tbody.appendChild(tr); return; }
    insertAfterGroup(headerRow, tr); // usa o header como âncora
  }

  function insertUnderActionSubRow(subRow, tr){
    if (!subRow) { tbody.appendChild(tr); return; }
    tr.setAttribute('data-sub', subRow.getAttribute('data-sub') || '');
    insertAfterGroup(subRow, tr, 'data-sub');
  }

  function fmt(v){ return v ? v : '—'; }

  function makeJobRow(j){
    const tr = document.createElement('tr');
    tr.setAttribute('data-ot', j.ot || '');
    tr.className = statusToClass(j.status) || 'st-novo';

    tr.innerHTML = `
      <td>${fmt(j.ot)}</td>
      <td>${fmt(j.regional)}</td>
      <td>${fmt(j.tipoLoja)}</td>
      <td>${fmt(j.tipoJob)}</td>
      <td>${fmt(j.nome)}</td>
      <td>${fmt(j.compl)}</td>
      <td>${fmt(j.uf)}</td>
      <td>${fmt(j.filial)}</td>
      <td>${fmt(j.ini)}</td>
      <td>${fmt(j.fim)}</td>
      <td>${fmt(j.tam)}</td>
      <td>${fmt(j.qtd)}</td>
      <td>${fmt(j.status)}</td>
      <td>—</td>
    `;
    return tr;
  }

  function clearOldJobRows(){
    if (!tbody) return;
    // mantém apenas os separadores de regionais e possíveis sub-rows já existentes
    [...tbody.querySelectorAll('tr')].forEach(tr=>{
      if (tr.classList.contains('sep-row') || tr.classList.contains('sub-row')) return;
      tr.remove();
    });
    // remove sub-rows de ações (serão refeitas conforme necessário)
    [...tbody.querySelectorAll('tr.sub-row')].forEach(tr=> tr.remove());
  }

  function sortByOT(a,b){
    // tenta extrair número do "OT- 01" etc.
    const na = (String(a.ot||'').match(/(\d+)/)||[])[1];
    const nb = (String(b.ot||'').match(/(\d+)/)||[])[1];
    const ia = na ? parseInt(na,10) : Number.MAX_SAFE_INTEGER;
    const ib = nb ? parseInt(nb,10) : Number.MAX_SAFE_INTEGER;
    if (ia !== ib) return ia - ib;
    return String(a.ot||'').localeCompare(String(b.ot||''), undefined, {numeric:true});
  }

  async function loadAndRenderJobs(){
    if (!tbody) return;
    setBusy(true, 'Carregando jobs…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const rows = csvToObjects(text);

      // mapeia campos esperados
      const jobs = rows.map(r => ({
        ot: r.ot,
        regional: r.regional || r.regionalGrupo || '',
        tipoLoja: r.tipoLoja,
        tipoJob:  r.tipoJob,
        nome:     r.nome,
        compl:    r.compl,
        uf:       r.uf,
        filial:   r.filial,
        ini:      r.ini,
        fim:      r.fim,
        tam:      r.tam,
        qtd:      r.qtd,
        isNacional: parseBool(r.isNacional),
        acaoNome:  r.acaoNome || '',
        status:    r.status || 'Novo'
      })).sort(sortByOT);

      clearOldJobRows();

      if (!jobs.length){
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 14;
        td.className = 'hint';
        td.textContent = 'Sem jobs cadastrados.';
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }

      // insere cada job no seu grupo
      for (const j of jobs){
        const tr = makeJobRow(j);
        if (j.isNacional) {
          const sub = ensureActionSubRow(j.acaoNome || '—');
          insertUnderActionSubRow(sub, tr);
        } else {
          const header = findRegionalHeader(j.regional || 'REGIONAL SP'); // fallback
          insertUnderRegional(header, tr);
        }
      }
    } catch (e){
      console.error(e);
      toast('Falha ao carregar jobs.');
    } finally {
      setBusy(false);
    }
  }

  /* ====== Dispara quando a tela de jobs abrir ======
     (observa mudança de visibilidade e carrega uma única vez) */
  let loadedOnce = false;
  function maybeLoad(){
    if (loadedOnce) return;
    const isVisible = jobsApp && !jobsApp.classList.contains('hide') && jobsApp.getAttribute('aria-hidden') !== 'true';
    if (isVisible) {
      loadedOnce = true;
      loadAndRenderJobs();
    }
  }

  if (jobsApp) {
    // tenta já carregar se estiver visível
    maybeLoad();

    // observa mudanças (ex.: após login)
    const mo = new MutationObserver(maybeLoad);
    mo.observe(jobsApp, { attributes: true, attributeFilter: ['class','aria-hidden'] });
  }

  // também expõe manualmente se quiser chamar após o login:
  window.loadJobsFromGitHub = loadAndRenderJobs;
})();
</script>

<!-- // CARREGAR JOBS DE jobs.csv E POPULAR A TABELA DA ÁREA DE TRABALHO - FIM -->

<!-- // FILIAIS: mostrar "…" na tabela e abrir modal com a lista completa ao clicar -->
<script>
(function () {
  const tbody = document.getElementById('jobsBody');
  const dlg   = document.getElementById('modalCell');
  const title = document.getElementById('cellTitle');
  const body  = document.getElementById('cellBody');
  const btnClose = document.getElementById('btnCellFechar');

  // Converte a célula de Filiais em "…" clicável com o valor completo em data-full
  function decorateFiliaisRow(tr){
    if (!tr || !tr.matches('tr[data-ot]')) return;
    const td = tr.children && tr.children[7]; // coluna "FILIAL (S)" (8ª coluna)
    if (!td || td.querySelector('.clip')) return;

    const full = (td.textContent || '').trim();
    // se vazio, deixa como está (não vira link)
    if (!full || full === '—') return;

    const span = document.createElement('span');
    span.className = 'clip';
    span.textContent = '…';       // mostra apenas "…"
    span.setAttribute('data-full', full);
    span.setAttribute('title', 'Clique para ver todas as filiais');

    td.textContent = '';
    td.appendChild(span);
  }

  // Decora todas as linhas atuais
  function decorateAll(){
    if (!tbody) return;
    tbody.querySelectorAll('tr[data-ot]').forEach(decorateFiliaisRow);
  }

  // Observa novas linhas inseridas (ex.: após carregar CSV)
  if (tbody) {
    const mo = new MutationObserver(muts=>{
      muts.forEach(m=>{
        m.addedNodes.forEach(n=>{
          if (n.nodeType === 1 && n.matches('tr[data-ot]')) decorateFiliaisRow(n);
        });
      });
    });
    mo.observe(tbody, { childList: true });
    decorateAll();
  }

  // Clique no "…" abre o modal com a lista completa
  if (tbody) {
    tbody.addEventListener('click', (e)=>{
      const el = e.target.closest('.clip[data-full]');
      if (!el) return;

      const full = el.getAttribute('data-full') || '';
      const items = full.split(',').map(s=>s.trim()).filter(Boolean);

      if (title) title.textContent = 'Filial(s)';
      if (body) {
        body.style.whiteSpace = 'pre-wrap';
        body.textContent = items.length ? items.join('\n') : full || '—';
      }
      dlg && dlg.showModal();
    });
  }

  // Fechar modal
  if (btnClose && dlg) {
    btnClose.addEventListener('click', ()=> dlg.close());
  }
})();
</script>

<!-- // FILIAIS: mostrar "…" na tabela e abrir modal com a lista completa ao clicar - FIM -->

<!-- // SELEÇÃO DE LINHAS NA TABELA DE JOBS (single-select) -->
<script>
(function () {
  const tbody = document.getElementById('jobsBody');

  // estado global (opcional, para outros scripts usarem)
  window.selectedOT = null;

  function clearSelection() {
    if (!tbody) return;
    tbody.querySelectorAll('tr.sel').forEach(tr => {
      tr.classList.remove('sel');
      tr.removeAttribute('aria-selected');
    });
    window.selectedOT = null;
  }

  function selectRow(tr) {
    if (!tr || !tr.hasAttribute('data-ot')) return;
    // ignora cabeçalhos/separadores
    if (tr.classList.contains('sep-row') || tr.classList.contains('sub-row')) return;

    clearSelection();
    tr.classList.add('sel');
    tr.setAttribute('aria-selected', 'true');
    window.selectedOT = tr.getAttribute('data-ot') || null;
  }

  // evita selecionar quando o clique é em elementos interativos (links, botões, "…", inputs etc.)
  function isInteractive(target) {
    return !!(
      target.closest('a,button,input,select,textarea,[contenteditable="true"]') ||
      target.closest('.clip') // o "…" das filiais
    );
  }

  function rowFromEventTarget(target) {
    const tr = target.closest('tr');
    if (!tr || !tr.hasAttribute('data-ot')) return null;
    if (isInteractive(target)) return null;
    return tr;
  }

  if (tbody) {
    // clique para selecionar (single-select)
    tbody.addEventListener('click', (e) => {
      const tr = rowFromEventTarget(e.target);
      if (tr) selectRow(tr);
    });

    // mantém a seleção após recarregar/repintar linhas
    const mo = new MutationObserver(() => {
      if (!window.selectedOT) return;
      const esc = (window.CSS && CSS.escape) ? CSS.escape : (s)=> String(s).replace(/"/g, '\\"');
      const tr = tbody.querySelector(`tr[data-ot="${esc(window.selectedOT)}"]`);
      if (!tr) {
        // linha sumiu, limpa seleção
        clearSelection();
      } else {
        // garante a classe/atributo se perderem
        tbody.querySelectorAll('tr.sel').forEach(r => {
          if (r !== tr) { r.classList.remove('sel'); r.removeAttribute('aria-selected'); }
        });
        tr.classList.add('sel');
        tr.setAttribute('aria-selected','true');
      }
    });
    mo.observe(tbody, { childList: true });
  }

  // helpers públicos (caso queira usar em outros scripts)
  window.getSelectedOT  = () => window.selectedOT || null;
  window.getSelectedRow = () => (tbody && tbody.querySelector('tr.sel')) || null;
  window.clearJobSelection = clearSelection;
})();
</script>

<!-- // SELEÇÃO DE LINHAS NA TABELA DE JOBS (single-select) - FIM -->

<!-- // FIX: topbar sólida e fixa + cabeçalho e separadores grudados -->
<style>
  /* Topbar: fixa e com fundo sólido */
  #jobsApp .topbar{
    position: fixed;          /* fixa no topo */
    top: 0; left: 0; right: 0;
    height: var(--topbar-h);
    z-index: 2000;
    background: #0f182b;      /* sólido (sem transparência/gradiente) */
    border-bottom: 1px solid rgba(255,255,255,.14);
    box-shadow: 0 8px 28px rgba(0,0,0,.35);
  }
  /* empurra o conteúdo para não ficar sob a topbar */
  #jobsApp main.content{ 
    padding-top: calc(var(--topbar-h) + 12px);
  }

  /* Área rolável da tabela ocupa o viewport restante */
  #mainBox .tableWrap{
    position: relative;
    overflow: auto;
    /* tenta ocupar o que sobra da tela abaixo da topbar */
    max-height: calc(100vh - var(--topbar-h) - 32px);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 10px;
    background: rgba(0,0,0,.18);
  }

  /* Cabeçalho grudado, acima de tudo dentro da área rolável */
  #mainBox thead th{
    position: sticky;
    top: 0;                   /* topo da área rolável */
    z-index: 10;
    background: #0f182b;      /* sólido para não vazar o fundo */
    box-shadow: 0 2px 0 rgba(255,255,255,.08);
  }

  /* Linhas de separação (REGIONAL …) grudam logo abaixo do cabeçalho */
  #mainBox tbody tr.sep-row td{
    position: sticky;
    top: var(--thead-h, 40px); /* preenchido via JS com a altura real do thead */
    z-index: 8;
    background: #0d1628;       /* sólido */
    border-top: 1px solid rgba(255,255,255,.14) !important;
    border-bottom: 1px solid rgba(255,255,255,.14) !important;
  }

  /* Sub-separadores (AÇÕES do Especial Nacional) grudam abaixo das separações */
  #mainBox tbody tr.sub-row td{
    position: sticky;
    top: calc(var(--thead-h, 40px) + var(--sep-h, 34px));
    z-index: 7;
    background: #0b1426;       /* sólido */
    border-top: 1px dashed rgba(255,255,255,.16) !important;
    border-bottom: 1px dashed rgba(255,255,255,.16) !important;
  }

  /* Realça o cabeçalho quando a lista rola */
  #mainBox .tableWrap.stuck-head thead th{
    box-shadow: 0 6px 14px rgba(0,0,0,.35);
  }
</style>

<script>
(function(){
  const wrap = document.querySelector('#mainBox .tableWrap');
  const thead = document.querySelector('#mainBox thead');

  // 1) mede a altura REAL do thead e salva numa var CSS,
  //    para posicionar as linhas de separação exatamente abaixo dele.
  function setHeadVars(){
    if (!wrap || !thead) return;
    const h = thead.offsetHeight || 40;             // altura do cabeçalho
    const sepRow = document.querySelector('#mainBox tbody tr.sep-row td');
    const sepH = sepRow ? sepRow.offsetHeight : 34; // altura típica da separação
    wrap.style.setProperty('--thead-h', h + 'px');
    wrap.style.setProperty('--sep-h', sepH + 'px');
  }
  setHeadVars();
  // recalcula quando a janela redimensiona (responsivo)
  window.addEventListener('resize', setHeadVars, { passive:true });

  // 2) adiciona sombra no cabeçalho quando a lista está rolando
  if (wrap){
    const onScroll = () => wrap.classList.toggle('stuck-head', wrap.scrollTop > 0);
    onScroll();
    wrap.addEventListener('scroll', onScroll, { passive:true });
  }

  // 3) garante que a área de jobs ocupe a tela e a rolagem principal fique dentro da tableWrap
  //    (opcional, mas ajuda a evitar que a topbar "pareça descer")
  const jobsApp = document.getElementById('jobsApp');
  if (jobsApp && !jobsApp.classList.contains('ready-fixed')){
    jobsApp.classList.add('ready-fixed');
    document.documentElement.style.height = '100%';
    document.body.style.height = '100%';
    // mantém o body sem rolagem vertical exagerada; rola só a lista
    document.body.style.overscrollBehavior = 'none';
  }

  // 4) se o conteúdo do thead mudar dinamicamente, observe e recalcule
  if (thead){
    const mo = new MutationObserver(setHeadVars);
    mo.observe(thead, { childList:true, subtree:true });
  }
})();
</script>

<!-- // FIX: topbar sólida e fixa + cabeçalho e separadores grudados FIM -->

<!-- // DASHBOARD v3: boxes com rolagem horizontal + modal mais largo -->
<style>
  /* Modal maior (override da regra global de dialog) */
  #modalDash {
    width: min(98vw, 1600px);
    max-width: 1600px;
  }

  #dashChartsGrid{
    margin-top:12px;
    display:grid;
    grid-template-columns: repeat(auto-fill, minmax(420px, 1fr)); /* boxes mais largos por padrão */
    gap:12px;
  }
  .chartBox{
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    background:#0b1420; /* sólido e mais escuro pra contraste */
    padding:10px 12px;
  }
  .chartBox h4{
    margin:0 0 6px 0;
    font-size:1rem;
    display:flex; align-items:center; justify-content:space-between;
    color:var(--text);
  }
  .chartBox .sub{ color:var(--muted); font-size:.85rem }

  /* SCROLLER: onde o SVG entra; cria barra horizontal se precisar */
  .chartBox .scroller{
    overflow:auto;             /* H e V se necessário */
    padding-bottom:4px;        /* espaço pra barra de rolagem */
    border-radius:8px;
    background:rgba(255,255,255,.03);
  }

  .chartBox svg{ display:block; height:320px } /* altura maior pro rótulo rotacionado */
  .axis{ stroke: rgba(255,255,255,.2); stroke-width:1 }
  .label{ font-size:11px; fill:#cfd6e6 }
  .bar:hover{ opacity:.9 }
  .empty{ color:var(--muted); font-size:.95rem; padding:8px 0 }
</style>

<script>
(function(){
  /* ===== Config GitHub ===== */
  const GH = { owner:'JPVectorsitem', repo:'LINKS-img', branch:'main', encPath:'jobs_encerrados.csv' };

  /* ===== Elementos ===== */
  const btnDash  = document.getElementById('btnDash');
  const dlg      = document.getElementById('modalDash');
  const btnClose = document.getElementById('dashFechar');
  const btnApply = document.getElementById('dashAplicar');
  const inpIni   = document.getElementById('dashIni');
  const inpFim   = document.getElementById('dashFim');
  const dashOut  = document.getElementById('dashOut');

  /* ===== Helpers ===== */
  function toast(msg){ const el=document.getElementById('toast'); if(!el) return; el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const saved=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||saved.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ===== CSV + GitHub ===== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;}else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';} else if(c=='\r'){}
      else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){row.push(cur);r.push(row);} return r;
  }
  function csvToObjects(t){ const rows=parseCsv(t); if(!rows.length) return []; const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){ const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue; const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; out.push(o); }
    return out;
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(token)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER,...(token?{'Authorization':`Bearer ${token}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path,branch){ const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)}); if(r.status===404) return {text:'',sha:null}; if(!r.ok) throw new Error('Falha ao ler ('+r.status+')'); const j=await r.json();
    return { text: j && j.content ? b64ToUtf8(j.content) : '', sha: j.sha||null };
  }

  /* ===== Lógica ===== */
  const STEP_LABEL = { layout:'Layout', digitacao:'Digitação', diagramacao:'Diagramação', revisao:'Revisão', encerramento:'Encerramento', site:'Site' };
  const SECTORS = Object.keys(STEP_LABEL);
  const parseBool = v => ['1','true','sim','yes'].includes(String(v||'').trim().toLowerCase());
  function jobRegionalGroup(row){ return parseBool(row.isNacional) ? 'ESPECIAL NACIONAL' : (row.regional || row.regionalGrupo || ''); }
  function parseLogs(raw){ try{ const j=JSON.parse(raw||'{}'); for(const k of SECTORS){ if(!Array.isArray(j[k])) j[k]=[]; } return j; }catch{ const e={}; for(const k of SECTORS) e[k]=[]; return e; } }
  function normalizeDateRange(){ const i=(inpIni?.value||'').trim(), f=(inpFim?.value||'').trim(); let dI=i?new Date(i+'T00:00:00'):null, dF=f?new Date(f+'T23:59:59'):null; if(dI&&dF&&dF<dI){const t=dI;dI=dF;dF=t;} return {dI,dF}; }
  function inRange(ts,dI,dF){ if(!ts) return false; const d=new Date(ts); if(isNaN(+d)) return false; if(dI&&d<dI) return false; if(dF&&d>dF) return false; return true; }
  function paletteFor(index){ const hue=(index*47)%360; return `hsl(${hue} 70% 60%)`; }

  /* ===== UI dinâmico: Regional + Grid ===== */
  let selRegional=null, chartsGrid=null;

  function ensureRegionalFilter(options){
    if(!selRegional){
      const grid = dlg?.querySelector('.grid');
      if(!grid) return;
      const wrap=document.createElement('div');
      wrap.className='col-3';
      wrap.innerHTML = `<label>Regional</label><select id="dashRegional"></select>`;
      grid.appendChild(wrap);
      selRegional = wrap.querySelector('#dashRegional');
    }
    const cur = selRegional.value || '(todas)';
    const opts = ['(todas)', ...options];
    selRegional.innerHTML = opts.map(o=>`<option${o===cur?' selected':''}>${o}</option>`).join('');
  }
  function ensureChartsGrid(){
    if(!chartsGrid){
      chartsGrid = document.createElement('div');
      chartsGrid.id = 'dashChartsGrid';
      dashOut?.insertAdjacentElement('afterend', chartsGrid);
    }
  }
  function clearCharts(){ if(chartsGrid) chartsGrid.innerHTML=''; }

  /* ===== Render: uma box por setor com SCROLLER ===== */
  function renderSectorBox(sectorLabel, data){
    // cria box e encaixa já no grid para conseguir medir larguras
    const box = document.createElement('div');
    box.className='chartBox';
    const total = data.reduce((s,x)=>s+x.count,0);
    box.innerHTML = `<h4>${sectorLabel} <span class="sub">Total eventos: ${total}</span></h4>`;
    const scroller = document.createElement('div');
    scroller.className = 'scroller';
    box.appendChild(scroller);
    chartsGrid.appendChild(box);

    if(!data.length){
      scroller.innerHTML = '<div class="empty">Sem dados neste período/filtragem.</div>';
      return;
    }

    // Agora que o box está no DOM, dá pra medir a largura disponível
    const availW = scroller.clientWidth || 600;

    // Geometria
    const H = 320, padL=46, padR=20, padT=12, padB=84;
    const n = data.length;
    const max = Math.max(1, ...data.map(d=>d.count));

    // Tamanho mínimo por barra para manter legibilidade
    const BAR_MIN = 22;      // largura mínima por barra
    const GAP = 8;           // gap entre barras
    const minW = padL + padR + n*BAR_MIN + (n-1)*GAP; // largura mínima total p/ caber as barras
    const W = Math.max(minW, availW);                 // se maior que área, surgirá rolagem

    const plotW = W - padL - padR;
    const barW = Math.max(BAR_MIN, (plotW - (n-1)*GAP) / n);
    const x = i => padL + i*(barW+GAP);
    const y = v => padT + (H - padT - padB) * (1 - (v/max));

    // SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', W);
    svg.setAttribute('height', H);
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    // eixo X
    const axisX=document.createElementNS(svg.namespaceURI,'line');
    axisX.setAttribute('x1',padL); axisX.setAttribute('x2',W-padR);
    axisX.setAttribute('y1',H-padB); axisX.setAttribute('y2',H-padB);
    axisX.setAttribute('class','axis');
    svg.appendChild(axisX);

    // grid Y
    for(let k=0;k<=4;k++){
      const val=Math.round(max*k/4), yy=y(val);
      const gl=document.createElementNS(svg.namespaceURI,'line');
      gl.setAttribute('x1',padL); gl.setAttribute('x2',W-padR);
      gl.setAttribute('y1',yy); gl.setAttribute('y2',yy);
      gl.setAttribute('class','axis'); gl.setAttribute('opacity','0.4');
      svg.appendChild(gl);

      const txt=document.createElementNS(svg.namespaceURI,'text');
      txt.setAttribute('x',padL-8); txt.setAttribute('y',yy+4);
      txt.setAttribute('text-anchor','end'); txt.setAttribute('class','label');
      txt.textContent=String(val);
      svg.appendChild(txt);
    }

    // barras + rótulos
    data.forEach((d,i)=>{
      const hh=(H-padT-padB)*(d.count/max);

      const rect=document.createElementNS(svg.namespaceURI,'rect');
      rect.setAttribute('x',x(i)); rect.setAttribute('y',H-padB-hh);
      rect.setAttribute('width',barW); rect.setAttribute('height',hh);
      rect.setAttribute('rx','6'); rect.setAttribute('class','bar');
      rect.setAttribute('fill', paletteFor(i));
      rect.setAttribute('title', `${d.person}: ${d.count}`);
      svg.appendChild(rect);

      const v=document.createElementNS(svg.namespaceURI,'text');
      v.setAttribute('x',x(i)+barW/2); v.setAttribute('y',H-padB-hh-6);
      v.setAttribute('text-anchor','middle'); v.setAttribute('class','label');
      v.textContent=d.count; svg.appendChild(v);

      const px=x(i)+barW/2, py=H-padB+40;
      const name=document.createElementNS(svg.namespaceURI,'text');
      name.setAttribute('x',px); name.setAttribute('y',py);
      name.setAttribute('text-anchor','end'); name.setAttribute('class','label');
      name.setAttribute('transform',`rotate(-45 ${px} ${py})`);
      name.textContent=d.person; svg.appendChild(name);
    });

    scroller.appendChild(svg);
  }

  /* ===== Aplicar ===== */
  const MAX_PESSOAS_SETOR = 50; // deixa generoso; scroll cuida do excesso

  async function applyDashboard(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    ensureChartsGrid();
    clearCharts();

    const regFiltro = (selRegional?.value || '(todas)').trim();
    const { dI, dF } = normalizeDateRange();

    setBusy(true,'Lendo finalizados…');
    try{
      const { text } = await ghGetFile(GH.encPath, GH.branch);
      const rows = csvToObjects(text);

      // regionais
      const regs = [...new Set(rows.map(jobRegionalGroup))].filter(Boolean).sort((a,b)=>a.localeCompare(b,'pt-BR'));
      ensureRegionalFilter(regs);

      // contagem setor -> pessoa
      const perSector = new Map(); // labelSetor -> Map(pessoa -> qt)
      for(const key of Object.values(STEP_LABEL)) perSector.set(key, new Map());

      for(const r of rows){
        const grp = jobRegionalGroup(r);
        if (regFiltro !== '(todas)' && grp !== regFiltro) continue;

        const logs = parseLogs(r.logs);
        for(const k of SECTORS){
          const label = STEP_LABEL[k];
          const evs = logs[k] || [];
          for(const ev of evs){
            if(!inRange(ev.ts, dI, dF)) continue;
            const pessoa = (ev.nome||'—').trim();
            const m = perSector.get(label);
            m.set(pessoa, (m.get(pessoa)||0)+1);
          }
        }
      }

      // render boxes
      for(const k of SECTORS){
        const label = STEP_LABEL[k];
        const m = perSector.get(label) || new Map();
        const arr = [...m.entries()].map(([person,count])=>({person,count}))
                    .sort((a,b)=> b.count - a.count || a.person.localeCompare(b.person,'pt-BR'))
                    .slice(0, MAX_PESSOAS_SETOR);
        renderSectorBox(label, arr);
      }

      if(![...perSector.values()].some(m => m.size)){
        const info=document.createElement('div');
        info.className='empty';
        info.textContent='Sem eventos para o período/filtragem.';
        chartsGrid.appendChild(info);
      }
    }catch(e){
      console.error(e);
      toast('Falha ao gerar dashboard.');
      clearCharts();
      const info=document.createElement('div'); info.className='empty'; info.textContent='Erro ao carregar dados.'; chartsGrid.appendChild(info);
    }finally{
      setBusy(false);
    }
  }

  /* ===== Binds ===== */
  if(btnDash && dlg){
    btnDash.addEventListener('click', async ()=>{
      ensureChartsGrid();
      clearCharts();
      chartsGrid.innerHTML = '<div class="empty">Defina o período e/ou a regional e clique em “Aplicar”.</div>';
      dlg.showModal();

      // carrega regionais na abertura
      try{
        const { text } = await ghGetFile(GH.encPath, GH.branch);
        const rows = csvToObjects(text);
        const regs = [...new Set(rows.map(jobRegionalGroup))].filter(Boolean).sort((a,b)=>a.localeCompare(b,'pt-BR'));
        ensureRegionalFilter(regs);
      }catch{}
    });
  }
  if(btnClose && dlg) btnClose.addEventListener('click',()=> dlg.close());
  if(btnApply) btnApply.addEventListener('click', applyDashboard);

  // re-render ao redimensionar (se o modal estiver aberto)
  window.addEventListener('resize', ()=>{ if(dlg && dlg.open) applyDashboard(); }, { passive:true });

})();
</script>


<!-- // DASHBOARD v3: boxes com rolagem horizontal + modal mais largo FIM -->

<!-- REMOVER FILTRO STATUS DO DASHBOARD -->
<style>
  /* fallback: se o bloco ainda existir, some com ele sem quebrar o grid */
  #dashStatus { display:none !important; }
  #dashStatus { visibility:hidden !important; }
</style>
<script>
(function(){
  // Remove o select e o "col-3" que o envolve, se existir
  function killDashStatus(){
    const sel = document.getElementById('dashStatus');
    if (!sel) return;
    const wrap = sel.closest('.col-3') || sel.parentElement;
    if (wrap && wrap.parentElement) wrap.parentElement.removeChild(wrap);
  }
  // tenta já na carga…
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', killDashStatus);
  } else {
    killDashStatus();
  }
  // …e também quando o modal abrir (caso o HTML seja injetado antes)
  const btnDash = document.getElementById('btnDash');
  const dlg     = document.getElementById('modalDash');
  if (btnDash && dlg){
    btnDash.addEventListener('click', killDashStatus);
  }
})();
</script>

<!-- REMOVER FILTRO STATUS DO DASHBOARD FIM -->

<!-- BOTÃO: Visualizar finalizados (carrega jobs_encerrados.csv e exibe no modal) -->
<script>
(function(){
  /* ====== Config GitHub ====== */
  const GH = { owner:'JPVectorsitem', repo:'LINKS-img', branch:'main', encPath:'jobs_encerrados.csv' };

  /* ====== Elements ====== */
  const btnOpen  = document.getElementById('btnVerFinalizados');
  const dlg      = document.getElementById('modalFinalizados');
  const tbody    = document.getElementById('finzList');
  const btnClose = document.getElementById('finzFechar');
  const btnAll   = document.getElementById('finzSelTodos');
  const btnNone  = document.getElementById('finzSelNenhum');
  // (Se você for usar duplicar depois, o botão já está no HTML: #finzDuplicar)

  /* ====== UX helpers ====== */
  function toast(m){ const d=document.getElementById('toast'); if(!d) return; d.textContent=m; d.style.display='block'; setTimeout(()=>d.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const saved=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||saved.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ====== CSV + GitHub ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;}else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';} else if(c=='\r'){}
      else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){row.push(cur);r.push(row);} return r;
  }
  function csvToObjects(t){ const rows=parseCsv(t); if(!rows.length) return []; const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){ const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue; const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; out.push(o); }
    return out;
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(token)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER,...(token?{'Authorization':`Bearer ${token}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path,branch){ const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)}); if(r.status===404) return {text:'',sha:null};
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); return { text: j && j.content ? b64ToUtf8(j.content) : '', sha: j.sha||null };
  }

  /* ====== Render ====== */
  function renderRows(rows){
    // só status Finalizado
    const onlyFinal = rows.filter(r => (r.status||'').toLowerCase()==='finalizado');
    if(!onlyFinal.length){
      tbody.innerHTML = `<tr><td colspan="12" class="hint">Nada finalizado.</td></tr>`;
      return;
    }
    onlyFinal.sort((a,b)=> (a.ot||'').localeCompare(b.ot, undefined, {numeric:true, sensitivity:'base'}));

    const frag=document.createDocumentFragment();
    onlyFinal.forEach(r=>{
      const tr=document.createElement('tr');
      const id='fz_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
      const filialTxt=(r.filial||'').trim()||'—';
      const filialShort = filialTxt.length>18 ? filialTxt.slice(0,18)+'…' : filialTxt;
      tr.innerHTML = `
        <td><input type="checkbox" data-ot="${r.ot||''}" id="${id}"></td>
        <td>${r.ot||'—'}</td>
        <td>${r.regional||'—'}</td>
        <td>${r.tipoJob||'—'}</td>
        <td>${r.nome||'—'}</td>
        <td>${r.compl||'—'}</td>
        <td>${r.uf||'—'}</td>
        <td><span class="clip" data-field="Filial(s)" data-full="${filialTxt}">${filialShort}</span></td>
        <td>${r.ini||'—'}</td>
        <td>${r.fim||'—'}</td>
        <td>${r.tam||'—'}</td>
        <td>${r.qtd||'—'}</td>`;
      frag.appendChild(tr);
    });
    tbody.innerHTML=''; tbody.appendChild(frag);
  }

  /* ====== Open ====== */
  async function openFinalizados(){
    setBusy(true,'Carregando finalizados…');
    try{
      const { text } = await ghGetFile(GH.encPath, GH.branch);
      renderRows(csvToObjects(text));
      dlg.showModal();
    }catch(e){
      console.error(e);
      tbody.innerHTML = `<tr><td colspan="12" class="hint">Erro ao carregar jobs_encerrados.csv</td></tr>`;
      dlg.showModal();
      toast('Falha ao carregar finalizados.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== Binds ====== */
  if(btnOpen)  btnOpen.addEventListener('click', openFinalizados);
  if(btnClose) btnClose.addEventListener('click', ()=> dlg.close());
  if(btnAll)   btnAll.addEventListener('click', ()=> tbody.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));
  if(btnNone)  btnNone.addEventListener('click', ()=> tbody.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=false));

  // Clique no "..." de Filial(s) abre modal de detalhe (reaproveita #modalCell)
  const cellDlg   = document.getElementById('modalCell');
  const cellTitle = document.getElementById('cellTitle');
  const cellBody  = document.getElementById('cellBody');
  if(tbody){
    tbody.addEventListener('click',(e)=>{
      const clip = e.target.closest('.clip');
      if(clip && cellDlg){
        cellTitle.textContent = clip.getAttribute('data-field') || 'Detalhes';
        cellBody.textContent  = clip.getAttribute('data-full') || '';
        cellDlg.showModal();
      }
    });
  }
})();
</script>

<!-- BOTÃO: Visualizar finalizados (carrega jobs_encerrados.csv e exibe no modal) FIM -->


<!-- // BOTÃO FINALIZAR — mover Site/Cancelado -> jobs_encerrados.csv (status Finalizado) -->
<script>
(function(){
  /* ===== CONFIG ===== */
  const GH = {
    owner: 'JPVectorsitem',
    repo:  'LINKS-img',
    branch:'main',
    jobsPath:'jobs.csv',
    encPath: 'jobs_encerrados.csv'
  };

  /* ===== Helpers UX ===== */
  const toast=(m)=>{ const el=document.getElementById('toast'); if(!el){ alert(m); return; }
    el.textContent=m; el.style.display='block'; setTimeout(()=>el.style.display='none',2200); };
  const setBusy=(v,msg)=>{ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; };
  const getToken=()=>{ try{ const saved=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||saved.token||''; }catch{ return (window.gh&&window.gh.token)||''; } };
  const nowISO=()=> new Date().toISOString();

  /* ===== CSV utils ===== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';} else if(c=='\r'){}
      else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){row.push(cur);r.push(row);} return r;
  }
  function csvToObjsAndHeader(t){
    const rows=parseCsv(t); if(!rows.length) return {header:[], rows:[]};
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return {header:H, rows:out};
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  const toCsvLine=a=>a.map(csvEsc).join(',');

  /* ===== GitHub helpers (com fallback RAW) ===== */
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok, extra={})=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{}) , ...extra});
  const b64ToUtf8=b64=>{ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); };
  const utf8ToB64=str=>{ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); };

  const _mem = new Map(); // path -> { text, sha, etag }
  const cacheGet  = (path)=> _mem.get(path)||null;
  const cachePut  = (path,entry)=>{ _mem.set(path, entry); try{ localStorage.setItem('sha:'+path, entry.sha||''); localStorage.setItem('etag:'+path, entry.etag||''); }catch{} };

  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');

    const cached = cacheGet(path);
    if (cached && typeof cached.text === 'string' && cached.text.length) return cached;

    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await fetch(url, { headers: ghHeaders(token) });

    if (r.status === 404){
      const res = { text:'', sha:null, etag:r.headers.get('ETag')||null }; cachePut(path, res); return res;
    }
    if (!r.ok){ const t=await r.text(); throw new Error('GET '+path+' '+r.status+': '+t); }

    const etag = r.headers.get('ETag') || null;
    const j = await r.json();
    let text = '';

    if (j && typeof j.content === 'string' && j.encoding === 'base64'){
      text = b64ToUtf8(j.content);
    } else if (j && j.download_url){
      const rRaw = await fetch(j.download_url);
      if (!rRaw.ok) throw new Error('RAW download falhou: '+rRaw.status);
      text = await rRaw.text();
    }

    const entry = { text, sha:j?.sha||null, etag };
    cachePut(path, entry);
    return entry;
  }

  async function ghPutFile(path, nextText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const tryPut = async (sha)=> {
      const body = { message: message || ('update: '+path), content: utf8ToB64(nextText), branch: GH.branch, ...(sha?{sha}:{}) };
      const r = await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
      const t = await r.text();
      if(!r.ok) throw new Error('PUT '+path+' '+r.status+': '+t);
      let newSha=null; let etag=null; try{ const j=JSON.parse(t); newSha=j?.content?.sha||null; }catch{}
      try{ etag=r.headers.get('ETag')||null; }catch{}
      cachePut(path, { text: nextText, sha: newSha, etag });
      return newSha;
    };
    try{
      const fresh = await ghGetFile(path, GH.branch);
      return await tryPut(fresh.sha);
    }catch(e){
      if(String(e).includes('409')){
        const fresh=await ghGetFile(path, GH.branch);
        return await tryPut(fresh.sha);
      }
      throw e;
    }
  }

  /* ===== UI refs ===== */
  const btnFinalizar   = document.getElementById('btnFinalizar');
  const dlgFinalizar   = document.getElementById('modalFinalizar');
  const finList        = document.getElementById('finList');
  const btnFinCancelar = document.getElementById('finCancelar');
  const btnFinTodos    = document.getElementById('finTodos');
  const btnFinSalvar   = document.getElementById('finSalvar');

  /* ===== Render da lista (Site/Cancelado) ===== */
  async function renderFinList(){
    setBusy(true,'Lendo jobs…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { header:H, rows } = csvToObjsAndHeader(text);
      // guarda em cache local pro salvar usar sem reler
      renderFinList._H = H;
      renderFinList._rows = rows;

      const arr = rows.filter(r => (r.status||'').toLowerCase()==='site' || (r.status||'').toLowerCase()==='cancelado');
      if(!arr.length){
        finList.innerHTML = `<tr><td colspan="5" class="hint">Nenhum job em Site ou Cancelado.</td></tr>`;
        return;
      }
      arr.sort((a,b)=> (a.ot||'').localeCompare(b.ot||'', undefined, { numeric:true, sensitivity:'base' }));

      const frag = document.createDocumentFragment();
      arr.forEach(r=>{
        const tr=document.createElement('tr');
        const id='fin_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
        tr.innerHTML = `<td><input type="checkbox" data-ot="${r.ot}" id="${id}"></td>
                        <td>${r.ot}</td><td>${r.nome||'—'}</td><td>${r.regional||'—'}</td><td>${r.status||'—'}</td>`;
        frag.appendChild(tr);
      });
      finList.innerHTML=''; finList.appendChild(frag);
    }catch(e){
      console.error(e);
      finList.innerHTML = `<tr><td colspan="5" class="hint">Erro ao carregar jobs.</td></tr>`;
    }finally{ setBusy(false); }
  }

  /* ===== Ação: Abrir modal ===== */
  if (btnFinalizar){
    btnFinalizar.addEventListener('click', async ()=>{
      await renderFinList();
      dlgFinalizar?.showModal();
    });
  }
  if (btnFinCancelar) btnFinCancelar.addEventListener('click', ()=> dlgFinalizar?.close());
  if (btnFinTodos)    btnFinTodos.addEventListener('click', ()=> finList?.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));

  /* ===== Ação: Finalizar (mover p/ jobs_encerrados.csv) ===== */
  if (btnFinSalvar){
    btnFinSalvar.addEventListener('click', async ()=>{
      const sel=[...finList.querySelectorAll('input[type="checkbox"][data-ot]:checked')].map(b=>b.getAttribute('data-ot'));
      if(!sel.length){ toast('Selecione ao menos 1 job.'); return; }
      if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

      const H = renderFinList._H || [];
      const rows = (renderFinList._rows || []).slice();

      // selecionados -> objetos + atualizar campos para Finalizado
      const mapByOT = new Map(rows.map(r=>[r.ot,r]));
      const moving = [];
      sel.forEach(ot=>{
        const r = mapByOT.get(ot);
        if(!r) return;
        const obj = {...r};
        obj.status = 'Finalizado';
        obj.statusStep = 'finalizado';
        obj.atualizado_em = nowISO();
        moving.push(obj);
      });
      if(!moving.length){ toast('Nada para finalizar.'); return; }

      // 1) montar enc.csv atualizado (append em 1 PUT)
      setBusy(true,'Gravando finalizados…');
      try{
        const enc = await ghGetFile(GH.encPath, GH.branch);
        let encText = enc.text || '';
        let encH = [];
        if (!encText.trim()){
          // cria cabeçalho
          encH = H.slice();
          encText = H.join(',') + '\n';
        }else{
          encH = csvToObjsAndHeader(encText).header;
          if (!encH || !encH.length) encH = H.slice();
        }
        const appended = moving.map(o => toCsvLine(encH.map(k => (o[k] ?? '')))).join('\n') + '\n';
        const newEncText = encText.trimEnd() + '\n' + appended;

        await ghPutFile(GH.encPath, newEncText, `chore(csv): finalize -> ${moving.length} job(s)`);

        // 2) montar jobs.csv sem os finalizados (1 PUT)
        const remain = rows.filter(r => !sel.includes(r.ot));
        const newJobsText = H.join(',')+'\n' + remain.map(o=> toCsvLine(H.map(k => (o[k] ?? '')))).join('\n') + '\n';
        await ghPutFile(GH.jobsPath, newJobsText, `chore(csv): remove finalized (${moving.length})`);

        // 3) Atualizar UI principal sem recarregar página
        sel.forEach(ot=>{
          const tr = document.querySelector(`tr[data-ot="${CSS.escape(ot)}"]`);
          if (tr){
            const sub = tr.getAttribute('data-sub');
            tr.remove();
            if (typeof window.cleanupActionIfEmpty === 'function' && sub){
              window.cleanupActionIfEmpty(sub);
            }
          }
          if (window.JOBS instanceof Map) window.JOBS.delete(ot);
        });

        // 4) feedback e fechar modal
        toast(`${moving.length} job(s) finalizados e movidos.`);
        dlgFinalizar?.close();
      }catch(e){
        console.error(e);
        toast('Erro ao finalizar. Tente novamente.');
      }finally{
        setBusy(false);
      }
    });
  }
})();
</script>
<!-- // BOTÃO FINALIZAR — FIM -->

<!-- PLUS na coluna ETAPAS + cores por etapa no modal -->
<style>
  /* garante centralização do botão da última coluna */
  #mainBox tbody td:last-child{ text-align:center }
  #mainBox .etapasBtn{ min-width:34px }

  /* ====== ETAPAS (modal) – layout e cores por etapa ====== */
  .etapasGrid{
    display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:12px;
  }
  .etapaCard{
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px; background:#0d1628;
    overflow:hidden;
  }
  .etapaHead{
    display:flex; align-items:center; justify-content:space-between;
    padding:8px 10px; font-weight:700;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .etapaLogs{ padding:8px 10px; max-height:220px; overflow:auto }
  .etapaLogs .ev{ display:flex; align-items:center; justify-content:space-between;
    padding:6px 0; border-top:1px dashed rgba(255,255,255,.12) }
  .etapaLogs .ev:first-child{ border-top:none }

  /* BARRA colorida por etapa (usa classe k-*) */
  .etapaCard .etapaHead{ border-left:6px solid transparent }
  .etapaCard.k-lista        .etapaHead{ border-left-color:#9cc9ff }  /* Lista */
  .etapaCard.k-layout       .etapaHead{ border-left-color:#9b87f5 }  /* Layout */
  .etapaCard.k-digitacao    .etapaHead{ border-left-color:#7aa7ff }  /* Digitação */
  .etapaCard.k-diagramacao  .etapaHead{ border-left-color:#f59e0b }  /* Diagramação */
  .etapaCard.k-revisao      .etapaHead{ border-left-color:#fbcfe8 }  /* Revisão */
  .etapaCard.k-aprovacao    .etapaHead{ border-left-color:#bbf7d0 }  /* Aprovação */
  .etapaCard.k-encerramento .etapaHead{ border-left-color:#fde68a }  /* Encerramento */
  .etapaCard.k-site         .etapaHead{ border-left-color:#d8b4fe }  /* Site */
  .etapaCard.k-cancelado    .etapaHead{ border-left-color:#ef4444 }  /* Cancelado */
</style>

<script>
(function(){
  /* ============== 1) Garante o botão “+” na coluna de ETAPAS ============== */
  function makeEtapasBtn(ot){
    const b=document.createElement('button');
    b.type='button'; b.className='btn small etapasBtn';
    b.textContent='+'; b.setAttribute('data-etapas', ot);
    b.title='Etapas de produção';
    return b;
  }
  function ensureBtnForRow(tr){
    if(!tr) return;
    const ot=tr.getAttribute('data-ot'); if(!ot) return;
    const td=tr.querySelector('td:last-child'); if(!td) return;
    if(td.querySelector('[data-etapas]')) return; // já tem
    td.textContent=''; td.appendChild(makeEtapasBtn(ot));
  }

  // aplica nas linhas já renderizadas
  document.querySelectorAll('#jobsBody tr[data-ot]').forEach(ensureBtnForRow);

  // hooka inserções futuras (se sua insertJobRow já cria o botão, nada muda)
  if (typeof window.insertJobRow === 'function'){
    const _orig = window.insertJobRow;
    window.insertJobRow = function(d){
      _orig.call(this, d);
      const tr=document.querySelector(`tr[data-ot="${CSS.escape(d.ot)}"]`);
      ensureBtnForRow(tr);
    };
  }

  // delega clique do “+” para abrir o modal de etapas
  document.getElementById('jobsBody')?.addEventListener('click',(e)=>{
    const btn=e.target.closest('[data-etapas]'); if(!btn) return;
    e.preventDefault(); e.stopPropagation();
    const ot=btn.getAttribute('data-etapas');
    if(typeof window.openEtapasModal==='function') window.openEtapasModal(ot);
  });

  /* ============== 2) Cores por etapa dentro do modal de Etapas ============== */
  // Depois que sua função renderEtapas desenhar os cards, colocamos a classe k-<step>
  function colorizeEtapas(containerId){
    const box=document.getElementById(containerId); if(!box) return;
    box.querySelectorAll('.etapaCard').forEach(card=>{
      const btn=card.querySelector('[data-add-step]');
      if(btn){ const step=btn.getAttribute('data-add-step'); card.classList.add('k-'+step); }
    });
  }

  // Se existir renderEtapas, envolvemos pra aplicar as cores sem mexer no seu core
  if (typeof window.renderEtapas === 'function'){
    const _origRender = window.renderEtapas;
    window.renderEtapas = function(containerId, job){
      _origRender(containerId, job);
      colorizeEtapas(containerId);
    };
  } else {
    // caso o render seja chamado depois de definir, expõe um util
    window._colorizeEtapas = colorizeEtapas;
  }

  /* ============== 3) (Já feito por você) salvar evento => muda status e cor ============== */
  // Observação: seu handler de “Adicionar evento” já faz:
  // - push em job.logs[step]
  // - job.status = STEP_META[step].status
  // - updateRowStatus(ot, job.status)  => troca a classe da linha (cor)
  // Não alteramos nada disso aqui.

})();
</script>

<!-- PLUS na coluna ETAPAS + cores por etapa no modal FIM -->

<!//========BOTÃO NOVO=======> 
<script>
(function(){
  /* ================== CONFIG GH ================== */
  const GH = {
    owner:'JPVectorsitem',
    repo:'LINKS-img',
    branch:'main',
    nomesPath:'nome_tabloide.csv',
    jobsPath:'jobs.csv',
    jobsClosedPath:'jobs_encerrados.csv'
  };

  /* ================== UF por Regional ================== */
  const UF_MAP = {
    'REGIONAL BA - SE':        ['BA','SE'],
    'REGIONAL DF - GO - TO':   ['DF','GO','TO'],
    'REGIONAL MG':             ['MG'],
    'REGIONAL MS':             ['MS'],
    'REGIONAL MT - RO - AC':   ['MT','RO','AC'],
    'REGIONAL NORDESTE 1':     ['AL','PB','PE','RN'],
    'REGIONAL NORDESTE 2':     ['CE','PI','MA'],
    'REGIONAL NORTE':          ['AM','AP','PA','RR'],
    'REGIONAL PR':             ['PR'],
    'REGIONAL RJ - ES':        ['RJ','ES'],
    'REGIONAL RS':             ['RS'],
    'REGIONAL SP':             ['SP'],
    'REGIONAL SC':             ['SC']
  };

  /* ================== ELEMENTOS (Novo) ================== */
  const dlgNovo       = document.getElementById('modalNovo');
  const formNovo      = document.getElementById('formNovo');
  const btnNovo       = document.getElementById('btnNovo');
  const btnSalvar     = document.getElementById('btnNovoSalvar');
  const btnCancelar   = document.getElementById('btnNovoCancelar');

  const selRegional   = document.getElementById('novoRegional');
  const selTipoLoja   = document.getElementById('novoTipoLoja');
  const selTipoJob    = document.getElementById('novoTipoJob');

  const selNome       = document.getElementById('novoNomeSel');
  const inputNomeEsp  = document.getElementById('novoNome'); // espelho (hidden)
  const btnNomeNovo   = document.getElementById('btnNomeNovo');

  const dlgNome       = document.getElementById('modalNomeTab');
  const inpNomeNovo   = document.getElementById('nomeTabTexto');
  const btnNomeSave   = document.getElementById('nomeTabSalvar');
  const btnNomeCancel = document.getElementById('nomeTabCancelar');

  const inpCompl      = document.getElementById('novoCompl');

  const selUF         = document.getElementById('novoEstado');
  const inpFilial     = document.getElementById('novoFilial');
  const inpIni        = document.getElementById('novoIni');
  const inpFim        = document.getElementById('novoFim');

  const selTam        = document.getElementById('novoTam');
  const inpQtd        = document.getElementById('novoQtd');
  const inpLink       = document.getElementById('novoLink'); // pode estar oculto

  const radioNao      = document.getElementById('novoAcaoNao');
  const radioSim      = document.getElementById('novoAcaoSim');
  const inpAcaoNome   = document.getElementById('novoAcaoNome');   // usa seu campo já existente
  const btnAcao       = document.getElementById('btnEscolherAcao'); // abre modal de ação

  const btnAddLinha   = document.getElementById('novoAddLinha');
  const listWrap      = document.getElementById('novoBatchList');

  /* ================== ELEMENTOS (Modal Ação nacional) ================== */
  const dlgAcao       = document.getElementById('modalAcao');
  const boxLista      = document.getElementById('acaoLista');
  const inpAcNova     = document.getElementById('acaoNova');
  const btnAcCan      = document.getElementById('acaoCancelar');
  const btnAcOK       = document.getElementById('acaoOk');

  /* ================== UX HELPERS ================== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg||'Aguarde…'; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  function nowISO(){ return new Date().toISOString(); }
  function normalizeCmp(s){ return String(s||'').trim().replace(/\s+/g,' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,''); }

  /* ================== CSV / GH ================== */
  const csvEsc = v => { v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function parseCsv(text){
    if(!text) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<text.length;i++){
      const c=text[i];
      if(q){
        if(c=='"'){ if(text[i+1]=='"'){cur+='"'; i++;} else q=false; } else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){ }
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; out.push(o);
    }
    return { header:H, rows:out };
  }
  function toCsv(H, objs){
    const head = H.join(',')+'\n';
    const body = objs.map(o => H.map(k => csvEsc(o[k] ?? '')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }

  const GH_API_VER='2022-11-28';
  const ghHeaders = (tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)}); if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text = j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message: message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ================== NOMES DO TABLOIDE (mantém seu fluxo) ================== */
  async function loadNomesIntoSelect(){
    if(!selNome) return;
    setBusy(true,'Carregando nomes…');
    try{
      const { text } = await ghGetFile(GH.nomesPath, GH.branch);
      const rows=parseCsv(text);
      let idx=0, start=0;
      if(rows.length){
        const H=rows[0]; const found=H.findIndex(h=>String(h||'').toLowerCase().trim()==='nome');
        if(found>=0){ idx=found; start=1; }
      }
      const list=[];
      for(let i=start;i<rows.length;i++){
        const v=String(rows[i][idx]||'').trim(); if(v) list.push(v);
      }
      const seen=new Set(), out=[];
      list.forEach(n=>{ const k=normalizeCmp(n); if(!seen.has(k)){ seen.add(k); out.push(n); } });
      out.sort((a,b)=>a.localeCompare(b,'pt-BR',{sensitivity:'base'}));
      const cur=selNome.value||'';
      selNome.innerHTML='<option value="">— selecione —</option>'+out.map(n=>`<option>${n.replace(/</g,'&lt;')}</option>`).join('');
      if(cur){ const opt=[...selNome.options].find(o=>normalizeCmp(o.value)===normalizeCmp(cur)); if(opt) opt.selected=true; }
      if(inputNomeEsp) inputNomeEsp.value = selNome.value || '';
    }catch(e){ console.error(e); toast('Não foi possível carregar os nomes.'); }
    finally{ setBusy(false); }
  }
  async function saveNovoNome(){
    const nome=(inpNomeNovo?.value||'').trim().replace(/\s+/g,' '); if(!nome){ toast('Digite um nome.'); return; }
    if(!getToken()){ toast('Configurar GitHub primeiro.'); return; }
    setBusy(true,'Salvando nome…');
    try{
      const { text } = await ghGetFile(GH.nomesPath, GH.branch);
      const rows=parseCsv(text); let H=rows[0]||['nome']; if(rows.length===0) rows.push(H);
      if(!H.map(h=>String(h).toLowerCase()).includes('nome')){ H=['nome']; rows.splice(0,0,H); }
      const all = new Set(rows.slice(1).map(r=>normalizeCmp(r[0]||'')));
      if(!all.has(normalizeCmp(nome))) rows.push([nome]);
      const next = H.join(',')+'\n'+rows.slice(1).map(r=>csvEsc(r[0]||'')).join('\n')+'\n';
      await ghPutFile(GH.nomesPath, next, `chore(csv): add nome_tabloide "${nome}"`);
      await loadNomesIntoSelect();
      const opt=[...selNome.options].find(o=>normalizeCmp(o.value)===normalizeCmp(nome)); if(opt) opt.selected=true;
      if(inputNomeEsp) inputNomeEsp.value=nome;
      dlgNome?.close(); if(inpNomeNovo) inpNomeNovo.value='';
      toast('Nome adicionado.');
    }catch(e){ console.error(e); toast('Falha ao salvar o nome.'); }
    finally{ setBusy(false); }
  }

  /* ================== REGIONAL -> UF ================== */
  function fillUFs(){
    const r=selRegional?.value||''; const list=UF_MAP[r]||[];
    selUF.innerHTML = list.length ? list.map(uf=>`<option>${uf}</option>`).join('') : '<option value="">—</option>';
  }

  /* ================== LOTE (+) ================== */
  const itemCss='display:grid;grid-template-columns:120px 1fr 170px 170px 36px;gap:8px;align-items:center;';
  const baseInputCss='width:100%;padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.16);background:#0b1426;color:#eaf0ff;';
  function makeItem(preset){
    const row=document.createElement('div'); row.className='novo-batch-item'; row.style.cssText=itemCss;
    const uf=document.createElement('select'); uf.style.cssText=baseInputCss; uf.innerHTML=selUF.innerHTML; uf.value=preset?.uf||selUF.value||'';
    const filial=document.createElement('input'); filial.type='text'; filial.placeholder='Ex.: 001, 002'; filial.value=preset?.filial||''; filial.style.cssText=baseInputCss;
    const ini=document.createElement('input'); ini.type='date'; ini.value=preset?.ini||inpIni.value||''; ini.style.cssText=baseInputCss;
    const fim=document.createElement('input'); fim.type='date'; fim.value=preset?.fim||inpFim.value||''; fim.style.cssText=baseInputCss;
    const rm=document.createElement('button'); rm.type='button'; rm.textContent='×'; rm.title='Remover';
    rm.style.cssText='width:36px;height:36px;border-radius:8px;border:1px solid rgba(255,255,255,.16);background:#2b1a1a;color:#ffd1d1;font-weight:900;cursor:pointer;';
    rm.addEventListener('click',()=>row.remove());
    row.append(uf,filial,ini,fim,rm); return row;
  }
  btnAddLinha?.addEventListener('click',()=> listWrap.appendChild(makeItem({ uf:selUF.value, ini:inpIni.value||'', fim:inpFim.value||'' })));
  function collectCombos(includeMain=true){
    const arr=[];
    if(includeMain){
      arr.push({ uf:selUF.value||'', filial:(inpFilial.value||'').trim(), ini:inpIni.value||'', fim:inpFim.value||'' });
    }
    listWrap.querySelectorAll('.novo-batch-item').forEach(row=>{
      const [uf,filial,ini,fim]=row.querySelectorAll('select,input');
      arr.push({ uf:uf?.value||'', filial:(filial?.value||'').trim(), ini:ini?.value||'', fim:fim?.value||'' });
    });
    return arr.filter(x=>x.uf && x.ini && x.fim);
  }

  /* ================== VALIDAÇÕES ================== */
  function required(v){ return String(v||'').trim().length>0; }
  function validFormBase(){
    const regional=selRegional.value, tipoLoja=selTipoLoja.value, tipoJob=selTipoJob.value, nome=selNome.value, tam=selTam.value, qtd=inpQtd.value;
    if(!required(regional)||!required(tipoLoja)||!required(tipoJob)||!required(nome)||!required(tam)||!required(qtd)){
      toast('Preencha Regional, Tipo da loja, Tipo do JOB, Nome, Tamanho e Quantidade.');
      return false;
    }
    const qn=parseInt(qtd,10); if(isNaN(qn)||qn<=0){ toast('Quantidade inválida.'); return false; }
    const ufs=UF_MAP[regional]||[]; const combos=collectCombos(true);
    if(!combos.length){ toast('Adicione ao menos uma linha (UF/Data).'); return false; }
    for(const c of combos){
      if(ufs.length && !ufs.includes(c.uf)){ toast('UF não é permitida para a regional selecionada.'); return false; }
      if(c.ini && c.fim && new Date(c.ini)>new Date(c.fim)){ toast('Período inválido em uma das linhas.'); return false; }
    }
    if(radioSim && radioSim.checked && !required(inpAcaoNome?.value)){ toast('Defina o nome da Ação nacional.'); return false; }
    return true;
  }

  /* ================== OT GLOBAL (OT-x, sem zeros) ================== */
  function extractMaxOT(rows){
    let max=0;
    for(const r of rows){
      const m=String(r.ot||'').match(/(\d+)/);
      if(m){ const n=parseInt(m[1],10); if(n>max) max=n; }
    }
    return max;
  }
  function nextOTFrom(allJobsRows, closedRows){
    const a = extractMaxOT(allJobsRows||[]);
    const b = extractMaxOT(closedRows||[]);
    return 'OT-' + (Math.max(a,b) + 1); // sem zeros à esquerda
  }

  /* ================== AÇÃO NACIONAL: usa SEU modal existente ================== */
  function toggleAcaoUI(){
    const sim = !!(radioSim && radioSim.checked);
    if(btnAcao) btnAcao.disabled = !sim;
    if(!sim && inpAcaoNome) inpAcaoNome.value = '';
  }
  if(radioNao) radioNao.addEventListener('change', toggleAcaoUI);
  if(radioSim) radioSim.addEventListener('change', toggleAcaoUI);
  toggleAcaoUI();

  /* Modal de Ação: popular e escolher/criar */
  async function loadAcoesLista(){
    if(!boxLista) return;
    boxLista.innerHTML = 'Carregando ações…';
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { rows } = csvToObjsAndHeader(text);
      const seen=new Set(), acoes=[];
      rows.forEach(r=>{
        const flag = String(r.isNacional||r.acaoNacional||'').trim().toLowerCase();
        const nome = String(r.acaoNome||'').trim();
        if((flag==='sim'||flag==='true'||flag==='1'||flag==='yes') && nome){
          const k=normalizeCmp(nome); if(!seen.has(k)){ seen.add(k); acoes.push(nome); }
        }
      });
      acoes.sort((a,b)=>a.localeCompare(b,'pt-BR',{sensitivity:'base'}));
      const frag=document.createDocumentFragment();
      if(!acoes.length){
        const d=document.createElement('div'); d.className='hint'; d.textContent='Nenhuma ação existente. Crie uma no campo abaixo.'; frag.appendChild(d);
      }else{
        acoes.forEach((nome,i)=>{
          const id='acao_'+i;
          const wrap=document.createElement('div'); wrap.style.padding='6px 0';
          wrap.innerHTML = `<label style="display:flex;gap:8px;align-items:center;cursor:pointer">
              <input type="radio" name="acaoPick" value="${nome.replace(/"/g,'&quot;')}" id="${id}">
              <span>${nome.replace(/</g,'&lt;')}</span>
            </label>`;
          frag.appendChild(wrap);
        });
      }
      boxLista.innerHTML=''; boxLista.appendChild(frag);
    }catch(e){
      console.error(e);
      boxLista.innerHTML = '<div class="hint">Erro ao carregar ações.</div>';
    }
  }
  if(btnAcao && dlgAcao){
    btnAcao.addEventListener('click', ()=>{
      if(!(radioSim && radioSim.checked)) return;
      if(inpAcNova) inpAcNova.value='';
      loadAcoesLista();
      dlgAcao.showModal();
    });
  }
  if(btnAcCan && dlgAcao){ btnAcCan.addEventListener('click', ()=> dlgAcao.close()); }
  if(btnAcOK && dlgAcao){
    btnAcOK.addEventListener('click', ()=>{
      const radios = dlgAcao.querySelectorAll('input[name="acaoPick"]');
      let picked = ''; radios.forEach(r=>{ if(r.checked) picked = r.value; });
      const novo = (inpAcNova?.value||'').trim().replace(/\s+/g,' ');
      const final = novo || picked;
      if(!final){ toast('Selecione uma ação ou digite uma nova.'); return; }
      if(inpAcaoNome) inpAcaoNome.value = final;
      dlgAcao.close();
    });
  }

  /* ================== AGRUPAMENTO NA TELA (ESPECIAL NACIONAL) ================== */
  function esc(s){ try{ return CSS.escape(String(s)); } catch{ return String(s).replace(/"/g,'\\"'); } }
  function jobsBody(){ return document.getElementById('jobsBody'); }

  function findEspecialHeader(){
    const tbody = jobsBody(); if (!tbody) return null;
    const sep = [...tbody.querySelectorAll('tr.sep-row')].find(tr => (tr.textContent||'').trim().toUpperCase()==='ESPECIAL NACIONAL');
    return sep || null;
  }
  function firstDataColspan(){
    const tbody = jobsBody(); if(!tbody) return 14;
    const anyRow = tbody.querySelector('tr:not(.sep-row):not(.sub-row)');
    return (anyRow && anyRow.children ? anyRow.children.length : 14);
  }
  function ensureSubRow(acaoNome){
    const anchor = findEspecialHeader(); if(!anchor) return null;
    const key = String(acaoNome||'').trim(); if(!key) return null;
    // procura sub-row existente
    let n = anchor.nextElementSibling;
    while(n && !n.classList.contains('sep-row')){
      if(n.classList.contains('sub-row') && (n.getAttribute('data-sub')||'')===key) return n;
      n = n.nextElementSibling;
    }
    // cria se não existir
    const sub = document.createElement('tr');
    sub.className='sub-row';
    sub.setAttribute('data-sub', key);
    const td=document.createElement('td');
    td.colSpan = firstDataColspan();
    td.textContent = 'AÇÃO — ' + key;
    sub.appendChild(td);
    anchor.after(sub);
    return sub;
  }
  function insertAfterGroup(anchorRow, tr){
    let cursor=anchorRow, last=anchorRow;
    while(cursor && (cursor = cursor.nextElementSibling)){
      if(cursor.classList.contains('sep-row')) break;
      if(cursor.classList.contains('sub-row')){
        const a=anchorRow.getAttribute('data-sub')||'';
        const b=cursor.getAttribute('data-sub')||'';
        if(a!==b) break;
      }
      last = cursor;
    }
    last.after(tr);
  }
  function moveRowUnderAction(ot, acaoNome){
    const tbody = jobsBody(); if(!tbody) return;
    const tr = tbody.querySelector(`tr[data-ot="${esc(ot)}"]`); if(!tr) return;
    const sub = ensureSubRow(acaoNome); if(!sub) return;
    tr.setAttribute('data-nacional','1');                    // marca
    tr.querySelectorAll('.btnVerLojas').forEach(b=>b.remove()); // some "Ver lojas" só em nacionais
    insertAfterGroup(sub, tr);
  }

  async function regroupAllNacionais(allNew = []){
    // tenta usar mapa global; se não, faz leitura leve do CSV
    if (window.JOBS instanceof Map){
      window.JOBS.forEach((job, ot)=>{
        const flag = String(job.acaoNacional || job.isNacional || '').toLowerCase();
        const isNac = (flag==='sim'||flag==='true'||flag==='1'||flag==='yes');
        const nome  = (job.acaoNome||'').trim();
        if(isNac && nome) moveRowUnderAction(ot, nome);
      });
      // também garante os recém-criados
      allNew.forEach(n=>{ if(n.acaoNacional==='Sim' && n.acaoNome) moveRowUnderAction(n.ot, n.acaoNome); });
    }else{
      try{
        const { text } = await ghGetFile(GH.jobsPath, GH.branch);
        const { rows } = csvToObjsAndHeader(text);
        rows.forEach(r=>{
          const ot=(r.ot||'').trim();
          const flag=String(r.acaoNacional||r.isNacional||'').toLowerCase();
          const isNac=(flag==='sim'||flag==='true'||flag==='1'||flag==='yes');
          const nome=(r.acaoNome||'').trim();
          if(ot && isNac && nome) moveRowUnderAction(ot, nome);
        });
        // garante os recém-criados
        allNew.forEach(n=>{ if(n.acaoNacional==='Sim' && n.acaoNome) moveRowUnderAction(n.ot, n.acaoNome); });
      }catch(e){ console.warn('regroupAllNacionais:', e); }
    }
  }

  // Hooka loadJobsFromGitHub uma única vez
  (function hookOnce(){
    if(typeof window.loadJobsFromGitHub==='function' && !window.__WV_HOOKED_NAC){
      const _orig = window.loadJobsFromGitHub;
      window.loadJobsFromGitHub = async function(){
        const r = await _orig.apply(this, arguments);
        requestAnimationFrame(()=>regroupAllNacionais());
        return r;
      };
      window.__WV_HOOKED_NAC = true;
    }
  })();

  /* ================== SALVAR (EM LOTE) ================== */
  async function salvarLote(){
    if(!getToken()){ toast('Configurar GitHub primeiro.'); return; }
    if(!validFormBase()) return;

    // Coleta base
    const regional    = selRegional.value;
    const tipoLoja    = selTipoLoja.value;
    const tipoJob     = selTipoJob.value;
    const nome        = selNome.value;
    const compl       = inpCompl.value||'';
    const tam         = selTam.value;
    const qtd         = String(parseInt(inpQtd.value,10));
    const link        = (inpLink && inpLink.value) ? inpLink.value.trim() : '';
    const acaoNacional = (radioSim && radioSim.checked) ? 'Sim' : 'Não';
    const acaoNome     = (radioSim && radioSim.checked) ? (inpAcaoNome?.value||'').trim() : '';
    const combos      = collectCombos(true);

    setBusy(true,'Gravando jobs…');

    try{
      // Lê jobs e encerrados para calcular OT global
      const [curJobs, curClosed] = await Promise.all([
        ghGetFile(GH.jobsPath, GH.branch),
        GH.jobsClosedPath ? ghGetFile(GH.jobsClosedPath, GH.branch) : Promise.resolve({ text:'' })
      ]);
      const pj = csvToObjsAndHeader(curJobs.text);
      const pc = csvToObjsAndHeader(curClosed.text);
      const rows = pj.rows || [];
      const closedRows = pc.rows || [];
      const Hcur = pj.header || [];

      // header desejado (inclui isNacional + acaoNacional)
      const DESIRED = ['ot','regional','tipoLoja','tipoJob','nome','compl','uf','filial','ini','fim','tam','qtd','link','isNacional','acaoNacional','acaoNome','status','statusStep','logs','criado_em','atualizado_em'];
      const H = Hcur.slice(); DESIRED.forEach(k=>{ if(!H.includes(k)) H.push(k); });

      // próximo OT (sem zeros à esquerda)
      let nextNum = Math.max(extractMaxOT(rows), extractMaxOT(closedRows)) + 1;

      const agora = nowISO();
      const resp  = (window.currentUser && window.currentUser.nome) ? String(window.currentUser.nome) : '—';

      // monta novas linhas
      const novos=[];
      for(const c of combos){
        const ot = 'OT-' + nextNum; nextNum += 1;
        const logs = { criado:[{ nome:resp, ts:agora }] };
        const row = {
          ot,
          regional,                  // mantém regional escolhida
          tipoLoja,
          tipoJob,
          nome,
          compl,
          uf: c.uf,
          filial: c.filial || '',
          ini: c.ini,
          fim: c.fim,
          tam,
          qtd,
          link,
          isNacional: (acaoNacional==='Sim') ? 'true' : '', // <- chave para o agrupamento
          acaoNacional,                                   // compatibilidade
          acaoNome,                                       // subparte
          status:'Novo',
          statusStep:'',
          logs: JSON.stringify(logs),
          criado_em:agora,
          atualizado_em:agora
        };
        rows.push(row); novos.push(row);
      }

      const nextCsv = toCsv(H, rows);
      await ghPutFile(GH.jobsPath, nextCsv, `chore(csv): add ${novos.length} job(s) [lote]`);

      // feedback + atualizar UI + reagrupar na tela
      if(formNovo) formNovo.reset();
      if(inpAcaoNome) inpAcaoNome.value='';
      toggleAcaoUI();

      if(typeof window.loadJobsFromGitHub === 'function'){
        setBusy(true,'Atualizando lista…');
        await window.loadJobsFromGitHub();
        requestAnimationFrame(()=>regroupAllNacionais(novos));
      }

      listWrap.innerHTML='';
      dlgNovo?.close();
      toast(`${novos.length} job(s) criado(s) com sucesso.`);
    }catch(e){
      console.error(e);
      toast('Falha ao salvar os jobs.');
    }finally{
      setBusy(false);
    }
  }

  /* ================== BINDS ================== */
  if(btnNovo){
    btnNovo.addEventListener('click', async ()=>{
      fillUFs();
      await loadNomesIntoSelect();
      toggleAcaoUI(); // liga/desliga o botão "Escolher ação" conforme Sim/Não
      dlgNovo.showModal();
    });
  }

  selRegional?.addEventListener('change', fillUFs);
  selNome?.addEventListener('change', ()=>{ if(inputNomeEsp) inputNomeEsp.value = selNome.value || ''; });

  btnNomeNovo?.addEventListener('click', ()=>{ if(inpNomeNovo) inpNomeNovo.value=''; dlgNome?.showModal(); });
  btnNomeCancel?.addEventListener('click', ()=> dlgNome?.close());
  btnNomeSave?.addEventListener('click', saveNovoNome);

  btnCancelar?.addEventListener('click', ()=>{ dlgNovo?.close(); listWrap.innerHTML=''; });
  if(btnSalvar) btnSalvar.addEventListener('click', salvarLote);
})();
</script>
<!//========BOTÃO NOVO=======FIM>

<!-- // NOVO — CANCELAR (fecha modal e reseta campos) -->
<script>
(function(){
  const dlg   = document.getElementById('modalNovo');
  const form  = document.getElementById('formNovo');
  const btn   = document.getElementById('btnNovoCancelar');

  if (btn && dlg) {
    btn.addEventListener('click', () => {
      // reseta o form
      if (form) form.reset();

      // garante que "Ação nacional" volte para "Não" e botão fique desabilitado
      const acaoNao = document.getElementById('novoAcaoNao');
      const acaoNome = document.getElementById('novoAcaoNome');
      const btnAcao = document.getElementById('btnEscolherAcao');
      if (acaoNao) acaoNao.checked = true;
      if (acaoNome) acaoNome.value = '';
      if (btnAcao) btnAcao.disabled = true;

      // limpa UF
      const uf = document.getElementById('novoEstado');
      if (uf) {
        uf.innerHTML = '<option value="">— selecione —</option>';
      }

      // fecha modal
      dlg.close();
    });
  }
})();
</script>

<!-- // NOVO — CANCELAR (fecha modal e reseta campos) FIM -->

<!-- // UF POR REGIONAL — mapeia e preenche #novoEstado (e #editEstado) -->
<script>
(function(){
  // mapeamento informado
  const UF_MAP = {
    'REGIONAL BA - SE':         ['BA','SE'],
    'REGIONAL DF - GO - TO':    ['DF','GO','TO'],
    'REGIONAL MG':              ['MG'],
    'REGIONAL MS':              ['MS'],
    'REGIONAL MT - RO - AC':    ['MT','RO','AC'],
    'REGIONAL NORDESTE 1':      ['AL','PB','PE','RN'],
    'REGIONAL NORDESTE 2':      ['CE','PI','MA'],
    'REGIONAL NORTE':           ['AM','AP','PA','RR'],
    'REGIONAL PR':              ['PR'],
    'REGIONAL RJ - ES':         ['RJ','ES'],
    'REGIONAL RS':              ['RS'],
    'REGIONAL SP':              ['SP'],
    'REGIONAL SC':              ['SC']
  };

  // helpers
  function fillUfOptions(selectEl, ufs, keepValue){
    if (!selectEl) return;
    const prev = keepValue ?? selectEl.value;
    const opts = ['<option value="">— selecione —</option>']
      .concat((ufs||[]).map(uf => `<option value="${uf}">${uf}</option>`));
    selectEl.innerHTML = opts.join('');
    // restaura seleção se continuar válida
    if (prev && (ufs||[]).includes(prev)) {
      selectEl.value = prev;
    }
  }

  function bindRegionalToUf(regionalSelId, ufSelId){
    const reg = document.getElementById(regionalSelId);
    const uf  = document.getElementById(ufSelId);
    if (!reg || !uf) return;

    // inicializa vazio
    fillUfOptions(uf, []);

    // quando trocar regional, atualiza UF
    reg.addEventListener('change', () => {
      const label = (reg.value || '').trim();
      fillUfOptions(uf, UF_MAP[label] || []);
    });
  }

  // Novo
  bindRegionalToUf('novoRegional', 'novoEstado');

  // Editar (se for usar no modal de edição também)
  bindRegionalToUf('editRegional', 'editEstado');

  // ao abrir o modal "Novo", se já houver regional selecionado, aplica o filtro de UF
  const btnNovo  = document.getElementById('btnNovo');
  const dlgNovo  = document.getElementById('modalNovo');
  const regNovo  = document.getElementById('novoRegional');
  const ufNovo   = document.getElementById('novoEstado');

  if (btnNovo && dlgNovo && regNovo && ufNovo) {
    btnNovo.addEventListener('click', () => {
      const label = (regNovo.value || '').trim();
      fillUfOptions(ufNovo, UF_MAP[label] || [], ufNovo.value);
    });
  }
})();
</script>

<!-- // UF POR REGIONAL — mapeia e preenche #novoEstado (e #editEstado) FIM -->

<!-- // FIX: garantir botão "+" na coluna ETAPAS PRODUÇÃO para todas as linhas -->
<script>
(function(){
  const tbody = document.getElementById('jobsBody');

  function makeEtapasBtn(ot){
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'btn small etapasBtn';
    b.textContent = '+';
    b.title = 'Etapas de produção';
    b.setAttribute('data-etapas', ot);
    return b;
  }

  function ensureBtnForRow(tr){
    if (!tr || !tr.hasAttribute('data-ot')) return;
    if (tr.classList.contains('sep-row') || tr.classList.contains('sub-row')) return;

    const td = tr.querySelector('td:last-child');
    if (!td) return;
    // já tem botão?
    if (td.querySelector('[data-etapas]')) return;

    const ot = tr.getAttribute('data-ot') || '';
    td.textContent = '';
    td.appendChild(makeEtapasBtn(ot));
  }

  function ensureAll(){
    if (!tbody) return;
    tbody.querySelectorAll('tr[data-ot]').forEach(ensureBtnForRow);
  }

  // 1) passa nas linhas já existentes
  ensureAll();

  // 2) observa novas linhas adicionadas (ex.: recarregar jobs.csv, TurboJobs, salvar novo)
  if (tbody){
    const mo = new MutationObserver((muts)=>{
      muts.forEach(m=>{
        m.addedNodes.forEach(n=>{
          if (n.nodeType === 1 && n.matches('tr[data-ot]')) ensureBtnForRow(n);
        });
      });
    });
    mo.observe(tbody, { childList: true });
  }

  // 3) wrapper pós-carregamento: se existir loadJobsFromGitHub, reforça
  if (typeof window.loadJobsFromGitHub === 'function'){
    const _origLoad = window.loadJobsFromGitHub;
    window.loadJobsFromGitHub = async function(){
      const r = await _origLoad.apply(this, arguments);
      // dá um microtempo pra linhas entrarem e garante os botões
      setTimeout(ensureAll, 0);
      return r;
    };
  }

  // 4) se existir insertJobRow (fallback antigo), reforça também
  if (typeof window.insertJobRow === 'function'){
    const _origInsert = window.insertJobRow;
    window.insertJobRow = function(d){
      _origInsert.call(this, d);
      const tr = tbody && d && d.ot ? tbody.querySelector(`tr[data-ot="${CSS.escape(d.ot)}"]`) : null;
      ensureBtnForRow(tr);
    };
  }

  // 5) clique delegado do "+"
  if (tbody){
    tbody.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-etapas]');
      if (!btn) return;
      const ot = btn.getAttribute('data-etapas');
      if (typeof window.openEtapasModal === 'function'){
        window.openEtapasModal(ot);
      }
    });
  }
})();
</script>
<!-- // FIX: garantir botão "+" na coluna ETAPAS PRODUÇÃO para todas as linhas FIM -->

<!-- ============ ETAPAS (botão "+"): abrir modal, registrar evento e SALVAR no jobs.csv ============ -->
<script>
(function(){
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:     'JPVectorsitem',
    repo:      'LINKS-img',
    branch:    'main',
    jobsPath:  'jobs.csv',
    usersPath: 'users.csv'
  };

  /* ====== ELEMENTOS (modais já existentes no seu HTML) ====== */
  const dlgEtapas        = document.getElementById('modalEtapas');
  const etapasTitleOT    = document.getElementById('etapasTitleOT');
  const etapasHead       = document.getElementById('etapasHead');
  const etapasList       = document.getElementById('etapasList');
  const btnEtapasFechar  = document.getElementById('btnEtapasFechar');

  const dlgAdd           = document.getElementById('modalAddEvt');
  const addTitle         = document.getElementById('addEvtTitle');
  const addFields        = document.getElementById('addEvtFields');
  const btnAddCancelar   = document.getElementById('btnAddEvtCancelar');
  const btnAddOK         = document.getElementById('btnAddEvtOk');

  /* ====== HELPERS UX ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  function nowISO(){ return new Date().toISOString(); }
  function fmtTS(ts){ const d=new Date(ts); return isNaN(+d)? ts : d.toLocaleString('pt-BR'); }
  const eqi=(a,b)=> String(a||'').trim().toLowerCase()===String(b||'').trim().toLowerCase();
  const normalize = s => String(s||'').trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');

  /* ====== CSV & GITHUB ====== */
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){cur+='"'; i++;} else q=false; } else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }

  const GH_API_VER='2022-11-28';
  const ghHeaders = (tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== MAPA DE ETAPAS ====== */
  const STEP_META = {
    lista:        { label:'Lista',        status:'Lista recebida', input:'text' },
    layout:       { label:'Layout',       status:'Criando layout', input:'role', roles:['Layout'] },
    digitacao:    { label:'Digitação',    status:'Digitando',      input:'role', roles:['Digitador'] },
    diagramacao:  { label:'Diagramação',  status:'Diagramando',    input:'role', roles:['Diagramador'] },
    revisao:      { label:'Revisão',      status:'Revisando',      input:'role', roles:['Revisor'] },
    aprovacao:    { label:'Aprovação',    status:'Aprovado',       input:'text' },
    encerramento: { label:'Encerramento', status:'Encerrando',     input:'role', roles:['Encerramento'] },
    site:         { label:'Site',         status:'Site',           input:'role', roles:['Site'] },
    cancelado:    { label:'Cancelado',    status:'Cancelado',      input:'text' }
  };
  const STEP_ORDER = ['lista','layout','digitacao','diagramacao','revisao','aprovacao','encerramento','site','cancelado'];

  /* ====== ESTADO LOCAL ====== */
  let curOT   = null;
  let curJob  = null;
  let curStep = null;

  /* ====== STATUS -> CLASSE DE LINHA ====== */
  function statusToClass(status){
    const s=normalize(status);
    if(s==='novo') return 'st-novo';
    if(s==='lista recebida') return 'st-lista';
    if(s==='criando layout') return 'st-layout';
    if(s==='digitando') return 'st-digitando';
    if(s==='diagramando') return 'st-diagramando';
    if(s==='revisando') return 'st-revisando';
    if(s==='aprovado') return 'st-aprovado';
    if(s==='encerrando') return 'st-encerrando';
    if(s==='site') return 'st-site';
    if(s==='cancelado') return 'st-cancelado';
    if(s==='finalizado') return 'st-finalizado';
    return '';
  }
  function updateRowStatus(ot, statusText){
    const tr = document.querySelector(`#jobsBody tr[data-ot="${CSS.escape(ot)}"]`);
    if(!tr) return;
    tr.className = tr.className.replace(/\bst-\w+\b/g,'').trim();
    const cls = statusToClass(statusText);
    if(cls) tr.classList.add(cls);
    const tdStatus = tr.children && tr.children[12]; // 13ª coluna é STATUS
    if(tdStatus) tdStatus.textContent = statusText || '—';
  }

  /* ====== LOGS ====== */
  function parseLogs(raw){
    try{
      const j = JSON.parse(raw||'{}');
      Object.keys(STEP_META).forEach(k=>{ if(!Array.isArray(j[k])) j[k]=[]; });
      return j;
    }catch{
      const e={}; Object.keys(STEP_META).forEach(k=> e[k]=[]);
      return e;
    }
  }

  /* ====== GARANTE COLUNAS NO HEADER ====== */
  function ensureHeaderColumns(H, rows, needed){
    const head = H.slice();
    const have = new Set(head.map(h=>String(h)));
    let changed=false;
    needed.forEach(col=>{
      if(!have.has(col)){ head.push(col); changed=true; }
    });
    if(changed){
      rows.forEach(r=>{
        needed.forEach(col=>{ if(r[col]===undefined) r[col]=''; });
      });
    }
    return { head, rows };
  }

  /* ====== USERS POR CARGO ====== */
  async function loadUsersByRoles(roles){
    const normRoles = (roles||[]).map(normalize);
    try{
      const { text } = await ghGetFile(GH.usersPath, GH.branch);
      const { rows } = csvToObjsAndHeader(text);
      const names=new Set();
      rows.forEach(u=>{
        const p=normalize(u.cargo_principal || u.cargo || '');
        const s=normalize(u.cargo_secundaria || '');
        if(normRoles.includes(p) || normRoles.includes(s)){
          const nome=(u.nome||'').trim();
          if(nome) names.add(nome);
        }
      });
      return [...names].sort((a,b)=> a.localeCompare(b,'pt-BR'));
    }catch(e){
      console.error(e);
      return [];
    }
  }

  /* ====== RENDER DO MODAL DE ETAPAS ====== */
  function renderEtapas(containerId, job){
    const box=document.getElementById(containerId);
    if(!box) return;
    box.innerHTML='';

    const logs=parseLogs(job.logs);

    STEP_ORDER.forEach(step=>{
      const meta=STEP_META[step];
      const card=document.createElement('div');
      card.className='etapaCard k-'+step;
      card.innerHTML=`
        <div class="etapaHead">
          <div>${meta.label}</div>
          <div><button class="btn small" type="button" data-add-step="${step}">Adicionar</button></div>
        </div>
        <div class="etapaLogs" data-step="${step}">
          ${
            (logs[step] && logs[step].length)
            ? logs[step].map(ev=>`
                <div class="ev">
                  <span>${(ev.nome||'—').replace(/</g,'&lt;')}</span>
                  <span class="muted">${fmtTS(ev.ts||'')}</span>
                </div>`).join('')
            : '<div class="muted">Sem eventos.</div>'
          }
        </div>
      `;
      box.appendChild(card);
    });

    // Se você tiver um colorizer global, aplica:
    if (typeof window._colorizeEtapas === 'function'){
      window._colorizeEtapas(containerId);
    }
  }

  /* ====== ABRIR MODAL ETAPAS (exposto para o click do "+") ====== */
  async function openEtapasModal(ot){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    setBusy(true,'Carregando etapas…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      const job = parsed.rows.find(r => eqi(r.ot, ot));
      if(!job){ toast('Job não encontrado.'); return; }
      curOT=ot;
      curJob=job;

      if (etapasTitleOT) etapasTitleOT.textContent = ot || '';
      if (etapasHead){
        etapasHead.innerHTML = `
          <div><strong>${(job.nome||'—').replace(/</g,'&lt;')}</strong></div>
          <div class="muted">Regional: ${job.regional||'—'} • UF: ${job.uf||'—'} • Status: ${job.status||'—'}</div>
        `;
      }

      renderEtapas('etapasList', job);
      dlgEtapas && dlgEtapas.showModal();
    }catch(e){
      console.error(e);
      toast('Erro ao abrir etapas.');
    }finally{
      setBusy(false);
    }
  }
  window.openEtapasModal = openEtapasModal;

  if (btnEtapasFechar && dlgEtapas){
    btnEtapasFechar.addEventListener('click', ()=> dlgEtapas.close());
  }

  /* ====== CLIQUE EM "ADICIONAR" EM CADA CARD ====== */
  if (etapasList){
    etapasList.addEventListener('click', async (e)=>{
      const btn=e.target.closest('[data-add-step]');
      if(!btn) return;
      const step=btn.getAttribute('data-add-step');
      if(!STEP_META[step]) return;
      curStep=step;
      const meta=STEP_META[step];

      addTitle && (addTitle.textContent = `Adicionar evento — ${meta.label} (${curOT||''})`);

      if(meta.input==='text'){
        addFields.innerHTML = `
          <div class="field">
            <label>Responsável</label>
            <input id="addNomeTxt" type="text" placeholder="Seu nome" />
          </div>
          <div class="muted">A data e a hora serão registradas automaticamente ao salvar.</div>
        `;
      }else{
        addFields.innerHTML = `
          <div class="field">
            <label>Responsável</label>
            <select id="addNomeSel"><option value="">(carregando…)</option></select>
          </div>
          <div class="muted">A data e a hora serão registradas automaticamente ao salvar.</div>
        `;
        const sel = addFields.querySelector('#addNomeSel');
        const nomes = await loadUsersByRoles(meta.roles||[]);
        sel.innerHTML = `<option value="">— selecione —</option>` + nomes.map(n=>`<option>${n.replace(/</g,'&lt;')}</option>`).join('');
      }

      dlgAdd && dlgAdd.showModal();
    });
  }

  if (btnAddCancelar && dlgAdd){
    btnAddCancelar.addEventListener('click', ()=> dlgAdd.close());
  }

  /* ====== SALVAR EVENTO (GRAVA jobs.csv) ====== */
  async function saveEvent(){
    if(!curOT || !curJob || !curStep || !STEP_META[curStep]){ toast('Seleção inválida.'); return; }
    const meta=STEP_META[curStep];

    let nome='';
    if(meta.input==='text'){
      nome = (document.getElementById('addNomeTxt')?.value || '').trim();
      if(!nome){ toast('Informe o nome do responsável.'); return; }
    }else{
      nome = (document.getElementById('addNomeSel')?.value || '').trim();
      if(!nome){ toast('Selecione o responsável.'); return; }
    }

    setBusy(true,'Gravando evento…');
    const ts = nowISO();

    try{
      // 1) lê jobs.csv
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      let H   = parsed.header || [];
      let rows= parsed.rows   || [];

      // 2) garante colunas: logs/statusStep/atualizado_em/status
      const ensured = ensureHeaderColumns(H, rows, ['logs','statusStep','atualizado_em','status']);
      H    = ensured.head;
      rows = ensured.rows;

      // 3) localiza job
      const idx = rows.findIndex(r => eqi(r.ot, curOT));
      if(idx===-1){ toast('Job não encontrado.'); setBusy(false); return; }

      // 4) atualiza logs + status
      const job=rows[idx];
      let logsObj;
      try{ logsObj = job.logs ? JSON.parse(job.logs) : {}; }catch{ logsObj = {}; }
      Object.keys(STEP_META).forEach(k=>{ if(!Array.isArray(logsObj[k])) logsObj[k]=[]; });

      logsObj[curStep].push({ nome, ts });

      job.logs          = JSON.stringify(logsObj);
      job.status        = meta.status;
      job.statusStep    = curStep;
      job.atualizado_em = ts;

      rows[idx]=job;

      // 5) escreve CSV
      const csv = toCsv(H, rows);
      await ghPutFile(GH.jobsPath, csv, `chore(csv): add ${meta.label} (${curOT})`);

      // 6) atualiza UI
      updateRowStatus(curOT, meta.status);

      const listEl = etapasList.querySelector(`.etapaLogs[data-step="${curStep}"]`);
      if(listEl){
        const ev=document.createElement('div');
        ev.className='ev';
        ev.innerHTML = `<span>${nome.replace(/</g,'&lt;')}</span><span class="muted">${fmtTS(ts)}</span>`;
        const empty=listEl.querySelector('.muted');
        if(empty) empty.remove();
        listEl.appendChild(ev);
      }

      dlgAdd && dlgAdd.close();
      toast('Evento registrado e salvo no jobs.csv.');
    }catch(e){
      console.error(e);
      toast('Erro ao salvar no jobs.csv.');
    }finally{
      setBusy(false);
    }
  }
  if (btnAddOK){
    btnAddOK.addEventListener('click', saveEvent);
  }

  /* ====== (Opcional) Delegado de clique do "+" caso não tenha sido adicionado antes ====== */
  (function ensurePlusClickBindingOnce(){
    const tbody = document.getElementById('jobsBody');
    if(!tbody) return;
    if(tbody._etapasPlusBound) return;
    tbody._etapasPlusBound = true;
    tbody.addEventListener('click',(e)=>{
      const btn=e.target.closest('[data-etapas]');
      if(!btn) return;
      const ot=btn.getAttribute('data-etapas');
      if(ot) openEtapasModal(ot);
    });
  })();

})();
</script>

<!-- ============ ETAPAS (botão "+"): abrir modal, registrar evento e SALVAR no jobs.csv ============ FIM -->

<!// ====== EXCLUIR NOVO =============>

<script>
(function(){
  "use strict";

  /* ===== GH CONFIG ===== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    jobsPath:  'jobs.csv',
    namesPath: 'nome_tabloide.csv' // usado só para preencher o filtro de nomes
  };

  /* ===== ELEMENTOS ===== */
  const btnAbrir   = document.getElementById('btnExcluir'); // seu botão "Excluir" no topo
  const dlg        = document.getElementById('modalExcluir');
  const selReg     = document.getElementById('exReg');
  const selNome    = document.getElementById('exNome');
  const inpIni     = document.getElementById('exIni');
  const inpFim     = document.getElementById('exFim');
  const btnFiltrar = document.getElementById('exFiltrar');
  const btnTodos   = document.getElementById('exSelTodos');
  const btnNenhum  = document.getElementById('exSelNenhum');
  const btnCancelar= document.getElementById('exCancelar');
  const btnExcluir = document.getElementById('exExcluir');
  const listBody   = document.getElementById('exList');
  const jobsBody   = document.getElementById('jobsBody'); // grid principal, p/ atualizar rápido

  /* ===== STATE ===== */
  let _head = [];
  let _rows = []; // TODO: só ativos (carregados do jobs.csv)

  /* ===== UX ===== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=> t.style.display='none', 2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display = v ? 'grid':'none'; if(msg) o.querySelector('.box').textContent = msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ===== CSV / GH HELPERS ===== */
  function parseCsv(t){
    if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else { if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token),'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ===== UTILS ===== */
  function clipHTML(full, max=60){
    const s=String(full||'').trim();
    if(!s) return '—';
    const short = s.length>max ? s.slice(0,max-1)+'…' : s;
    return `<span class="clip" data-full="${s.replace(/"/g,'&quot;')}">${short.replace(/</g,'&lt;')}</span>`;
  }
  function toDate(x){ const d=x?new Date(x):null; return (d && !isNaN(d)) ? d : null; }
  function datesOverlap(jobIni, jobFim, fIni, fFim){
    if(!fIni && !fFim) return true;
    if(fIni && !fFim)  return !jobFim || jobFim >= fIni;
    if(!fIni && fFim)  return !jobIni || jobIni <= fFim;
    return !( (jobFim && jobFim < fIni) || (jobIni && jobIni > fFim) );
  }

  /* ===== NOME_TABLOIDE para filtro ===== */
  async function loadNomeOptions(){
    if(!selNome) return;
    selNome.innerHTML = `<option value="(todos)">(todos)</option>`;
    try{
      const { text } = await ghGetFile(GH.namesPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      let names=[];
      if(parsed.header.length){
        const idx = parsed.header.findIndex(h => String(h||'').trim().toLowerCase()==='nome');
        if(idx>=0) names = parsed.rows.map(r=> r[parsed.header[idx]]).filter(Boolean);
        else {
          const raw=parseCsv(text);
          for(let i=1;i<raw.length;i++){ const v=raw[i][0]; if(v) names.push(v); }
        }
      }
      names = [...new Set(names.map(s=>String(s).trim()))].filter(Boolean)
              .sort((a,b)=> a.localeCompare(b,'pt-BR',{sensitivity:'base'}));
      const frag=document.createDocumentFragment();
      names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; frag.appendChild(o); });
      selNome.appendChild(frag);
    }catch(e){ console.error(e); /* mantém somente (todos) */ }
  }

  /* ===== RENDER ===== */
  function render(list){
    if(!listBody) return;
    if(!list.length){
      listBody.innerHTML = `<tr><td colspan="12" class="hint">Nenhum job com esse filtro.</td></tr>`;
      return;
    }
    // Ordena por OT numérica
    list.sort((a,b)=>{
      const na=parseInt(String(a.ot||'').match(/\d+/)?.[0]||'0',10);
      const nb=parseInt(String(b.ot||'').match(/\d+/)?.[0]||'0',10);
      return (na-nb)|| String(a.ot||'').localeCompare(String(b.ot||''));
    });
    const frag=document.createDocumentFragment();
    list.forEach(r=>{
      const tr=document.createElement('tr');
      const id='ex_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
      tr.innerHTML = `
        <td><input type="checkbox" data-ot="${r.ot||''}" id="${id}"></td>
        <td>${r.ot||'—'}</td>
        <td>${r.regional||'—'}</td>
        <td>${r.tipoJob||'—'}</td>
        <td>${clipHTML(r.nome||'')}</td>
        <td>${r.uf||'—'}</td>
        <td>${clipHTML(r.filial||'')}</td>
        <td>${r.ini||'—'}</td>
        <td>${r.fim||'—'}</td>
        <td>${r.tam||'—'}</td>
        <td>${r.qtd||'—'}</td>
        <td>${r.status||'—'}</td>`;
      frag.appendChild(tr);
    });
    listBody.innerHTML=''; listBody.appendChild(frag);
  }

  /* ===== FILTER ===== */
  function populateRegionaisFromData(rows){
    if(!selReg) return;
    const set=new Set(['(todas)']);
    rows.forEach(r=>{ const v=(r.regional||'').trim(); if(v) set.add(v); });
    selReg.innerHTML = '';
    [...set].sort((a,b)=> a.localeCompare(b,'pt-BR')).forEach(v=>{
      const o=document.createElement('option'); o.value=v; o.textContent=v; selReg.appendChild(o);
    });
  }
  function applyFilter(){
    const reg  = (selReg?.value || '(todas)').trim();
    const nome = (selNome?.value || '(todos)').trim();
    const fIni = toDate(inpIni?.value);
    const fFim = toDate(inpFim?.value);
    const out = _rows.filter(r=>{
      // status: ativos → tudo que está no jobs.csv (você já não lista finalizados aqui)
      const okReg  = reg==='(todas)' || String(r.regional||'')===reg;
      const okNome = nome==='(todos)' || String(r.nome||'')===nome;
      const jIni = toDate(r.ini), jFim = toDate(r.fim);
      const okPer = datesOverlap(jIni, jFim, fIni, fFim);
      return okReg && okNome && okPer;
    });
    render(out);
  }

  /* ===== OPEN ===== */
  async function openExcluir(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    setBusy(true,'Carregando jobs…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      _head = parsed.header || [];
      _rows = parsed.rows   || [];

      // Popula filtros
      populateRegionaisFromData(_rows);
      await loadNomeOptions();

      // limpa datas
      if(inpIni) inpIni.value='';
      if(inpFim) inpFim.value='';

      // render inicial (todos)
      render(_rows);

      dlg?.showModal();
    }catch(e){
      console.error(e);
      toast('Falha ao carregar jobs.');
      listBody.innerHTML = `<tr><td colspan="12" class="hint">Erro ao carregar.</td></tr>`;
      dlg?.showModal();
    }finally{
      setBusy(false);
    }
  }

  /* ===== DELETE ===== */
  async function doDelete(){
    const sel = [...listBody.querySelectorAll('input[type="checkbox"][data-ot]:checked')].map(b=> b.getAttribute('data-ot'));
    if(!sel.length){ toast('Selecione ao menos 1 job.'); return; }
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    // Confirmação rápida
    if(!confirm(`Excluir ${sel.length} job(s) selecionado(s)? Esta ação não pode ser desfeita.`)) return;

    setBusy(true, 'Excluindo…');
    try{
      // Mantém apenas os que NÃO estão selecionados
      const selSet = new Set(sel.map(String));
      const nextRows = _rows.filter(r => !selSet.has(String(r.ot)));

      const csv = toCsv(_head, nextRows);
      await ghPutFile(GH.jobsPath, csv, `chore(csv): delete ${sel.length} job(s)`);

      // Atualiza estado local
      _rows = nextRows;

      // Atualiza UI principal (remover linhas da tabela) — ou recarrega tudo
      if(typeof window.loadJobsFromGitHub === 'function'){
        await window.loadJobsFromGitHub();
      }else if(jobsBody){
        sel.forEach(ot=>{
          const tr = jobsBody.querySelector(`tr[data-ot="${CSS.escape(ot)}"]`);
          if(tr) tr.remove();
        });
      }

      // Reaplica filtro na lista do modal
      applyFilter();

      toast(`${sel.length} job(s) excluídos.`);
    }catch(e){
      console.error(e);
      toast('Erro ao excluir. Tente novamente.');
    }finally{
      setBusy(false);
    }
  }

  /* ===== BINDINGS ===== */
  btnAbrir?.addEventListener('click', openExcluir);
  btnFiltrar?.addEventListener('click', applyFilter);
  btnTodos?.addEventListener('click', ()=> listBody?.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));
  btnNenhum?.addEventListener('click', ()=> listBody?.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=false));
  btnCancelar?.addEventListener('click', ()=> dlg?.close());
  btnExcluir?.addEventListener('click', doDelete);

})();
</script>


<!// ======EXCLUIR NOVO - FIM ========>

<//!-- ============ BOTÃO ENCERRAR ============ -->

<script>
(function(){
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv',
    nomesPath:'nome_tabloide.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnEncerrar  = document.getElementById('btnEncerrar');
  const dlg          = document.getElementById('modalEncerrar');

  const selStatus    = document.getElementById('encStatus');      // "Aprovado" (desabilitado)
  const selNome      = document.getElementById('encNomeSel');     // SELECT de nomes (novo)
  const inpLink      = document.getElementById('encLinkFiltro');  // contém no link (opcional)

  const btnFiltrar   = document.getElementById('encFiltrar');
  const btnSelTodos  = document.getElementById('encSelTodos');
  const btnExecutar  = document.getElementById('encExecutar');
  const btnCancelar  = document.getElementById('encCancelar');
  const listBody     = document.getElementById('encList');
  const jobsBody     = document.getElementById('jobsBody'); // tabela principal

  /* ====== HELPERS UX ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  const eqi=(a,b)=> String(a||'').trim().toLowerCase()===String(b||'').trim().toLowerCase();
  const escHtml = (s)=> String(s||'').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));

  /* ====== CSV ====== */
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){cur+='"'; i++;} else q=false; } else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }

  /* ====== GitHub ====== */
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== STATUS UI ====== */
  function statusToClass(status){
    const s=String(status||'').trim().toLowerCase();
    if(s==='novo') return 'st-novo';
    if(s==='lista recebida') return 'st-lista';
    if(s==='criando layout') return 'st-layout';
    if(s==='digitando') return 'st-digitando';
    if(s==='diagramando') return 'st-diagramando';
    if(s==='revisando') return 'st-revisando';
    if(s==='aprovado') return 'st-aprovado';
    if(s==='encerrando') return 'st-encerrando';
    if(s==='site') return 'st-site';
    if(s==='cancelado') return 'st-cancelado';
    if(s==='finalizado') return 'st-finalizado';
    return '';
  }
  function updateMainRowStatus(ot, statusText){
    const tr = jobsBody && jobsBody.querySelector(`tr[data-ot="${CSS.escape(ot)}"]`);
    if(!tr) return;
    tr.className = tr.className.replace(/\bst-\w+\b/g,'').trim();
    const cls = statusToClass(statusText);
    if(cls) tr.classList.add(cls);
    const tdStatus = tr.children && tr.children[12];
    if(tdStatus) tdStatus.textContent = statusText || '—';
  }

  /* ====== ESTADO ====== */
  let _csvHead = [];
  let _rowsAll = [];
  let _allRows = [];      // só os aprovados (para render)
  let _nomeTabCache = null;

  /* ====== NOMES DO TABLOIDE (popular SELECT) ====== */
  async function loadNomeTabOptions(){
    if(!selNome) return;
    if(_nomeTabCache){ fillNomeSelect(_nomeTabCache); return; }
    try{
      const { text } = await ghGetFile(GH.nomesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      const col = header.find(h => eqi(h,'nome')) || header[0] || 'nome';
      const names = [...new Set(rows.map(r => (r[col]||'').trim()).filter(Boolean))]
        .sort((a,b)=> a.localeCompare(b,'pt-BR'));
      _nomeTabCache = names;
      fillNomeSelect(names);
    }catch(e){
      console.error('Falha ao carregar nome_tabloide.csv', e);
      selNome.innerHTML = `<option>(todos)</option>`;
    }
  }
  function fillNomeSelect(names){
    const cur = selNome.value || '(todos)';
    const opts = ['(todos)', ...names];
    selNome.innerHTML = opts.map(o => `<option${o===cur?' selected':''}>${escHtml(o)}</option>`).join('');
  }

  /* ====== RENDER LISTA ====== */
  function renderList(rows){
    if(!rows.length){
      listBody.innerHTML = `<tr><td colspan="14" class="hint">Nenhum job “Aprovado” com esses filtros.</td></tr>`;
      return;
    }
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      const id='enc_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
      tr.innerHTML = `
        <td><input type="checkbox" data-ot="${escHtml(r.ot||'')}" id="${id}"></td>
        <td>${escHtml(r.ot||'—')}</td>
        <td>${escHtml(r.regional||'—')}</td>
        <td>${escHtml(r.tipoLoja||'—')}</td>
        <td>${escHtml(r.tipoJob||'—')}</td>
        <td>${escHtml(r.nome||'—')}</td>
        <td>${escHtml(r.compl||'—')}</td>
        <td>${escHtml(r.uf||'—')}</td>
        <td><span class="clip" data-full="${escHtml((r.filial||'').trim() || '—')}">…</span></td>
        <td>${escHtml(r.ini||'—')}</td>
        <td>${escHtml(r.fim||'—')}</td>
        <td>${escHtml(r.tam||'—')}</td>
        <td>${escHtml(r.qtd||'—')}</td>
        <td>${escHtml(r.status||'—')}</td>
      `;
      frag.appendChild(tr);
    });
    listBody.innerHTML=''; listBody.appendChild(frag);
  }

  function applyFilters(){
    const nameSel = (selNome?.value || '(todos)').trim();
    const qLink   = (inpLink?.value || '').trim().toLowerCase();

    const out = _allRows.filter(r=>{
      const okNome = nameSel === '(todos)' ? true : eqi(r.nome, nameSel);
      const linkVal = (r.link || r.linkMae || '');
      const okLink = !qLink || String(linkVal).toLowerCase().includes(qLink);
      return okNome && okLink;
    });
    renderList(out);
  }

  /* ====== ABRIR MODAL ====== */
  async function openEncerrar(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    setBusy(true,'Carregando aprovados…');
    try{
      await loadNomeTabOptions();

      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed   = csvToObjsAndHeader(text);
      _csvHead       = parsed.header || [];
      _rowsAll       = parsed.rows   || [];

      // só “Aprovado” para a lista
      _allRows = _rowsAll
        .filter(r => String(r.status||'').trim().toLowerCase() === 'aprovado')
        .map(r => (Object.assign({}, r, { regional: r.regional||r.regionalGrupo||'' })))
        .sort((a,b)=> (a.ot||'').localeCompare(b.ot||'', undefined, {numeric:true, sensitivity:'base'}));

      applyFilters();
      dlg && dlg.showModal();
    }catch(e){
      console.error(e);
      listBody.innerHTML = `<tr><td colspan="14" class="hint">Erro ao carregar jobs.</td></tr>`;
      dlg && dlg.showModal();
      toast('Falha ao carregar.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== EXECUTAR ENCERRAR (sem alterações) ====== */
  async function doEncerrar(){
    const sel = [...listBody.querySelectorAll('input[type="checkbox"][data-ot]:checked')].map(b=> b.getAttribute('data-ot'));
    if(!sel.length){ toast('Selecione ao menos 1 job.'); return; }
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    const resp = (window.currentUser && window.currentUser.nome) ? String(window.currentUser.nome) : '—';
    setBusy(true,'Atualizando status…');
    const ts = new Date().toISOString();

    try{
      const mapSel = new Set(sel);
      for(let i=0;i<_rowsAll.length;i++){
        const r=_rowsAll[i];
        if(mapSel.has(String(r.ot))){
          let logsObj;
          try{ logsObj = r.logs ? JSON.parse(r.logs) : {}; }catch{ logsObj = {}; }
          if(!Array.isArray(logsObj.encerramento)) logsObj.encerramento = [];
          logsObj.encerramento.push({ nome: resp, ts });

          r.logs          = JSON.stringify(logsObj);
          r.status        = 'Encerrando';
          r.statusStep    = 'encerramento';
          r.atualizado_em = ts;
          _rowsAll[i]     = r;
        }
      }
      const csv = toCsv(_csvHead, _rowsAll);
      await ghPutFile(GH.jobsPath, csv, `chore(csv): encerrar ${sel.length} job(s)`);

      sel.forEach(ot=>{
        updateMainRowStatus(ot, 'Encerrando');
        const row = listBody.querySelector(`input[type="checkbox"][data-ot="${CSS.escape(ot)}"]`)?.closest('tr');
        if(row) row.remove();
      });

      if(!listBody.querySelector('tr')) {
        listBody.innerHTML = `<tr><td colspan="14" class="hint">Nenhum job “Aprovado”.</td></tr>`;
      }

      toast(`${sel.length} job(s) movidos para Encerrando.`);
      dlg && dlg.close();
    }catch(e){
      console.error(e);
      toast('Erro ao encerrar. Tente novamente.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== Binds ====== */
  if(btnEncerrar) btnEncerrar.addEventListener('click', openEncerrar);
  if(btnFiltrar)  btnFiltrar.addEventListener('click', applyFilters);
  if(btnSelTodos) btnSelTodos.addEventListener('click', ()=> listBody.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));
  if(btnExecutar) btnExecutar.addEventListener('click', doEncerrar);
  if(btnCancelar) btnCancelar.addEventListener('click', ()=> dlg && dlg.close());
})();
</script>

<!-- ============ BOTÃO EDITAR — v2 (token unificado + filiais reais + erros claros) ============ -->
<style>
  .btn-mini{
    appearance:none;border:1px solid rgba(255,255,255,.16);background:#0d1628;color:#eaf0ff;
    padding:6px 10px;border-radius:8px;cursor:pointer;font-weight:600;font-size:.85rem
  }
  .btn-mini:hover{transform:translateY(-1px);border-color:rgba(255,255,255,.28)}
  dialog#dlgLojasView{ border:none; padding:0; width:min(720px,96vw); background:transparent; }
  dialog#dlgLojasView::backdrop{ background:rgba(0,0,0,.75); }
  #lojasCard{ background:#0e1730; color:#eaf0ff; border:1px solid rgba(255,255,255,.12);
    border-radius:14px; box-shadow:0 24px 80px rgba(0,0,0,.5); overflow:hidden; }
  #lojasCard header{ padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.1); display:flex; justify-content:space-between; gap:10px; align-items:center }
  #lojasCard header h3{ margin:0; font-size:1rem }
  #lojasCard .body{ padding:14px 16px; white-space:pre-wrap; word-break:break-word; max-height:60vh; overflow:auto }
  #lojasCard footer{ padding:12px 16px; border-top:1px solid rgba(255,255,255,.1); display:flex; justify-content:flex-end }
</style>

<dialog id="dlgLojasView">
  <div id="lojasCard">
    <header>
      <h3>Lojas (Filiais)</h3>
      <button type="button" id="closeLojasDlg" class="btn-mini">Fechar</button>
    </header>
    <div class="body" id="lojasBodyText"></div>
    <footer>
      <button type="button" id="copiarLojasBtn" class="btn-mini">Copiar</button>
    </footer>
  </div>
</dialog>

<script>
(function(){
  /* ====== CONFIG ====== */
  const GH = {
    owner:     'JPVectorsitem',
    repo:      'LINKS-img',
    branch:    'main',
    jobsPath:  'jobs.csv',
    namesPath: 'nome_tabloide.csv'
  };

  /* ====== UF x Regional ====== */
  const UF_MAP = {
    'REGIONAL BA - SE':        ['BA','SE'],
    'REGIONAL DF - GO - TO':   ['DF','GO','TO'],
    'REGIONAL MG':             ['MG'],
    'REGIONAL MS':             ['MS'],
    'REGIONAL MT - RO - AC':   ['MT','RO','AC'],
    'REGIONAL NORDESTE 1':     ['AL','PB','PE','RN'],
    'REGIONAL NORDESTE 2':     ['CE','PI','MA'],
    'REGIONAL NORTE':          ['AM','AP','PA','RR'],
    'REGIONAL PR':             ['PR'],
    'REGIONAL RJ - ES':        ['RJ','ES'],
    'REGIONAL RS':             ['RS'],
    'REGIONAL SP':             ['SP'],
    'REGIONAL SC':             ['SC']
  };
  const REGIONAIS = Object.keys(UF_MAP);

  /* ====== ELEMENTOS ====== */
  const btnEditar    = document.getElementById('btnEditar');
  const dlg          = document.getElementById('modalEdit');
  const form         = document.getElementById('formEdit');

  const lblOT        = document.getElementById('editOT');
  const selRegional  = document.getElementById('editRegional');
  const selTipoLoja  = document.getElementById('editTipoLoja');
  const selTipoJob   = document.getElementById('editTipoJob');
  const inpNome      = document.getElementById('editNome');     // será SELECT
  const inpCompl     = document.getElementById('editCompl');
  const selUF        = document.getElementById('editEstado');
  const inpFilial    = document.getElementById('editFilial');   // textarea/input
  const inpIni       = document.getElementById('editIni');
  const inpFim       = document.getElementById('editFim');
  const selTam       = document.getElementById('editTam');
  const inpQtd       = document.getElementById('editQtd');
  const btnCancel    = document.getElementById('btnEditCancelar');
  const btnSave      = document.getElementById('btnEditSalvar');

  // Popup “Ver lojas”
  const dlgLojas     = document.getElementById('dlgLojasView');
  const lojasBody    = document.getElementById('lojasBodyText');
  const closeLojas   = document.getElementById('closeLojasDlg');
  const copiarLojas  = document.getElementById('copiarLojasBtn');

  let selNomeBox     = null;

  /* ====== UX ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }

  /* ====== TOKEN UNIFICADO ====== */
  function getToken(){
    try{
      if (window.GH_TOKEN && typeof window.GH_TOKEN.get==='function'){
        const t = window.GH_TOKEN.get(); if(t) return t.trim();
      }
    }catch{}
    try{
      const a = JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); if(a.token) return String(a.token).trim();
    }catch{}
    try{
      const b = JSON.parse(sessionStorage.getItem('wv_gh_cfg')||'{}'); if(b.token) return String(b.token).trim();
    }catch{}
    if (window.gh && window.gh.token) return String(window.gh.token).trim();
    const c = localStorage.getItem('wv_gh_token') || sessionStorage.getItem('wv_gh_token');
    return c ? String(c).trim() : '';
  }

  /* ====== CSV/GitHub ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }
  function ensureHeaderColumns(H, rows, needed){
    const head=H.slice(); const have=new Set(head.map(h=>String(h)));
    let changed=false; needed.forEach(col=>{ if(!have.has(col)){ head.push(col); changed=true; } });
    if(changed) rows.forEach(r=> needed.forEach(col=>{ if(r[col]===undefined) r[col]=''; }));
    return { head, rows };
  }

  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }

  // Leitura: permite sem token (repo público)
  async function ghGetFile(path, branch){
    const token=getToken();
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token||null)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok){
      const t=await r.text(); console.error('GH GET error:', r.status, t);
      throw new Error('Falha ao ler ('+r.status+')');
    }
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  // Escrita: exige token
  async function ghPutFile(path, newText, message){
    const token=getToken();
    if(!token){ throw new Error('Token ausente. Salve o token antes de salvar.'); }
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch(e){ /* se 404, sha ficará null e cria */ }
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){
      const t=await r.text(); console.error('GH PUT error:', r.status, t);
      let msg='Falha ao salvar ('+r.status+')';
      if(r.status===401) msg+=' — token inválido.';
      if(r.status===403) msg+=' — sem permissão (precisa scope repo:contents).';
      if(r.status===409) msg+=' — conflito de versão; tente novamente.';
      throw new Error(msg);
    }
    return true;
  }

  /* ====== UI helpers ====== */
  function fillSelect(sel, options, current){
    if (!sel) return;
    sel.innerHTML = options.map(o=> `<option${String(o)===String(current)?' selected':''}>${o}</option>`).join('');
  }
  function ensureNomeSelect(){
    if (selNomeBox && selNomeBox.tagName==='SELECT') return selNomeBox;
    const sel = document.createElement('select');
    sel.id = 'editNomeSel';
    sel.style.minWidth = '240px';
    if (inpNome) inpNome.replaceWith(sel);
    selNomeBox = sel;
    return sel;
  }
  async function loadNomeTabloideOptions(selectEl, currentValue){
    if(!selectEl) return;
    selectEl.innerHTML = `<option value="">Carregando…</option>`;
    try{
      const { text } = await ghGetFile(GH.namesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      let names=[];
      if (header.length){
        const idx = header.findIndex(h => String(h||'').trim().toLowerCase()==='nome');
        if (idx>=0) names = rows.map(r=> r[header[idx]]).filter(Boolean);
        else {
          const raw=parseCsv(text);
          for(let i=1;i<raw.length;i++){ const v=raw[i][0]; if(v) names.push(v); }
        }
      }
      names = [...new Set(names.map(s=>String(s).trim()))].filter(Boolean)
               .sort((a,b)=> a.localeCompare(b,'pt-BR'));
      if (currentValue && !names.includes(currentValue)) names.unshift(currentValue);
      selectEl.innerHTML = '';
      const ph = document.createElement('option'); ph.value=''; ph.textContent='— selecione —'; selectEl.appendChild(ph);
      const frag=document.createDocumentFragment();
      names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; if (n===currentValue) o.selected=true; frag.appendChild(o); });
      selectEl.appendChild(frag);
    }catch(e){
      console.error(e);
      selectEl.innerHTML = `<option value="">— selecione —</option>`;
      toast('Falha ao carregar nome_tabloide.csv');
    }
  }
  function populateRegionais(current){ fillSelect(selRegional, Object.keys(UF_MAP), current); }
  function populateUFsForRegional(regional, currentUF){
    const list = UF_MAP[regional] || [];
    selUF.innerHTML = list.map(uf => `<option${uf===currentUF?' selected':''}>${uf}</option>`).join('');
  }

  // filiais na célula (DOM seguro)
  function renderFilialCell(td, fullText){
    if(!td) return;
    td.innerHTML = '';
    const data = String(fullText||'').trim();
    if(!data) return;
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'btn-mini ver-lojas';
    btn.textContent = 'Ver lojas';
    btn.dataset.full = data;
    td.appendChild(btn);
  }
  function decorateFiliaisCellForOT(ot, fullText){
    const tr = document.querySelector(`#jobsBody tr[data-ot="${CSS.escape(ot)}"]`);
    if(!tr) return;
    renderFilialCell(tr.children[7], fullText);
  }
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('.ver-lojas');
    if(!btn) return;
    lojasBody.textContent = btn.dataset.full || '';
    try{ dlgLojas.showModal(); }catch{}
  });
  if(closeLojas) closeLojas.addEventListener('click', ()=> dlgLojas.close());
  if(copiarLojas) copiarLojas.addEventListener('click', async ()=>{
    try{ await navigator.clipboard.writeText(lojasBody.textContent||''); toast('Copiado.'); }catch{ toast('Não foi possível copiar.'); }
  });

  // util: lê linha DOM
  function readRowFromDOMByOT(ot){
    const tr = document.querySelector(`#jobsBody tr[data-ot="${CSS.escape(ot)}"]`);
    if (!tr) return null;
    const td = i => (tr.children[i]?.textContent||'').trim();
    const filialFull = tr.children[7]?.querySelector('[data-full]')?.dataset.full
                    || tr.children[7]?.querySelector('.clip')?.getAttribute('data-full')
                    || td(7);
    return {
      ot: td(0), regional: td(1), tipoLoja: td(2), tipoJob: td(3), nome: td(4),
      compl: td(5), uf: td(6), filial: filialFull, ini: td(8), fim: td(9),
      tam: td(10), qtd: td(11)
    };
  }
  function getSelectedOT(){
    if (typeof window.getSelectedOT === 'function') return window.getSelectedOT();
    const tr = document.querySelector('#jobsBody tr.sel[data-ot]');
    return tr ? tr.getAttribute('data-ot') : null;
  }
  async function fetchFilialFromCSV(ot){
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { rows } = csvToObjsAndHeader(text);
      const r = rows.find(x => (String(x.ot||'').trim().toLowerCase() === String(ot||'').trim().toLowerCase()));
      return (r && r.filial) ? String(r.filial) : '';
    }catch{ return ''; }
  }

  /* ====== ABRIR EDITAR ====== */
  async function openEditar(){
    const ot = getSelectedOT();
    if (!ot){ toast('Selecione um job para editar.'); return; }

    const cur = readRowFromDOMByOT(ot);
    if (!cur){ toast('Não consegui ler os dados do job.'); return; }

    lblOT.textContent = cur.ot || '—';

    populateRegionais(cur.regional || '');
    populateUFsForRegional(cur.regional || '', cur.uf || '');
    selRegional.onchange = ()=> populateUFsForRegional(selRegional.value, '');

    selTipoLoja.value = cur.tipoLoja || '';
    selTipoJob.value  = cur.tipoJob  || '';
    inpCompl.value    = cur.compl    || '';
    inpIni.value      = cur.ini      || '';
    inpFim.value      = cur.fim      || '';
    selTam.value      = cur.tam      || '';
    inpQtd.value      = cur.qtd      || '';

    const sel = ensureNomeSelect();
    await loadNomeTabloideOptions(sel, cur.nome || '');

    let filialReal = cur.filial;
    if(!filialReal || filialReal.toLowerCase()==='ver lojas' || filialReal==='...'){
      filialReal = await fetchFilialFromCSV(ot);
    }
    inpFilial.value = filialReal || '';

    dlg.showModal();
  }

  /* ====== SALVAR ====== */
  async function saveEditar(){
    const ot = (lblOT.textContent||'').trim();
    if (!ot){ toast('OT inválida.'); return; }

    const regional = selRegional.value || '';
    const tipoLoja = selTipoLoja.value || '';
    const tipoJob  = selTipoJob.value  || '';
    const nome     = (selNomeBox && selNomeBox.value) || '';
    const compl    = inpCompl.value || '';
    const uf       = selUF.value || '';
    const filial   = inpFilial.value || '';
    const ini      = inpIni.value || '';
    const fim      = inpFim.value || '';
    const tam      = selTam.value || '';
    const qtd      = (inpQtd.value||'').trim();

    if (!regional || !tipoLoja || !tipoJob || !nome || !uf || !ini || !fim || !tam || !qtd){
      toast('Preencha Regional, Tipo da loja, Tipo do JOB, Nome, UF, Período, Tamanho e Quantidade.');
      return;
    }
    const qn = parseInt(qtd,10);
    if (isNaN(qn) || qn<=0){ toast('Quantidade inválida.'); return; }

    const allowedUFs = UF_MAP[regional] || [];
    if (allowedUFs.length && !allowedUFs.includes(uf)){
      toast('UF não é permitida para a regional selecionada.');
      return;
    }
    if (ini && fim && new Date(ini) > new Date(fim)){
      toast('Período inválido (início > término).');
      return;
    }

    setBusy(true,'Salvando…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      let H = parsed.header || [];
      let rows = parsed.rows   || [];
      if (!H.length) throw new Error('Cabeçalho ausente em jobs.csv');

      ({ head:H, rows } = ensureHeaderColumns(H, rows, [
        'ot','regional','tipoLoja','tipoJob','nome','compl','uf','filial','ini','fim','tam','qtd','status','logs','statusStep','atualizado_em'
      ]));

      const idx = rows.findIndex(r => (String(r.ot||'').trim().toLowerCase() === ot.toLowerCase()));
      if (idx < 0) throw new Error('OT não encontrada em jobs.csv');

      const now = new Date().toISOString();
      const r = rows[idx];
      r.regional = regional;
      r.tipoLoja = tipoLoja;
      r.tipoJob  = tipoJob;
      r.nome     = nome;
      r.compl    = compl;
      r.uf       = uf;
      r.filial   = filial;
      r.ini      = ini;
      r.fim      = fim;
      r.tam      = tam;
      r.qtd      = String(qn);
      r.atualizado_em = now;

      const nextText = toCsv(H, rows);
      await ghPutFile(GH.jobsPath, nextText, `chore(csv): edit job ${ot}`);

      decorateFiliaisCellForOT(ot, filial);
      if (typeof window.loadJobsFromGitHub === 'function') {
        await window.loadJobsFromGitHub();
        decorateFiliaisCellForOT(ot, filial);
      }

      toast('Alterações salvas.');
      dlg.close();
    }catch(e){
      console.error(e);
      toast(e.message || 'Erro ao salvar edição.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== Binds ====== */
  if (btnEditar)   btnEditar.addEventListener('click', openEditar);
  if (btnCancel)   btnCancel.addEventListener('click', ()=> dlg.close());
  if (btnSave)     btnSave.addEventListener('click', saveEditar);

  // expõe decorador
  window.decorateFiliaisCellForOT = window.decorateFiliaisCellForOT || decorateFiliaisCellForOT;

})();
</script>
<!-- ============ BOTÃO EDITAR — FIM ============ -->



<!-- ============ BOTÃO DUPLICAR — IMPLEMENTAÇÃO COMPLETA (passo 1 + passo 2 + ações nacionais + gravação em jobs.csv) =================== -->

<script>
(function(){
  /* ====== CONFIG GITHUB ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv',
    jobsEnc:  'jobs_encerrados.csv',
    namesPath:'nome_tabloide.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnDuplicar  = document.getElementById('btnDuplicar');

  // Passo 1 (seleção)
  const dlgSel       = document.getElementById('modalDup1');
  const selFonte     = document.getElementById('dupFonte');
  const selReg       = document.getElementById('dupReg');
  let   selNomeFiltro= null; // SELECT (substitui #dupNome)
  const btnFiltrar   = document.getElementById('dupFiltrar');
  const btnSelTodos  = document.getElementById('dupSelTodos');
  const btnSelNenhum = document.getElementById('dupSelNenhum');
  const tbodySel     = document.getElementById('dupList');
  const btn1Cancel   = document.getElementById('dup1Cancelar');
  const btn1Avancar  = document.getElementById('dup1Avancar');

  // Passo 2 (parâmetros)
  const dlgPar       = document.getElementById('modalDup2');
  const formPar      = document.getElementById('formDup2');
  const selTipoJob   = document.getElementById('dupTipoJob');
  let   selNomeNovo  = null; // SELECT (substitui #dupNomeNovo)
  const inpIni       = document.getElementById('dupIni');
  const inpFim       = document.getElementById('dupFim');
  const selTam       = document.getElementById('dupTam');
  const inpQtd       = document.getElementById('dupQtd');

  // Ação nacional
  const radNacNao    = document.getElementById('dupAcaoNao');
  const radNacSim    = document.getElementById('dupAcaoSim');
  const inpAcaoNome  = document.getElementById('dupAcaoNome');
  const btnPickAcao  = document.getElementById('btnDupEscolherAcao');
  let   selAcaoExist = null; // SELECT inserido ao lado

  // Modal de ação nacional reutilizado (existente no seu app)
  const dlgAcao      = document.getElementById('modalAcao');
  const boxAcoes     = document.getElementById('acaoLista');
  const inpAcaoNova  = document.getElementById('acaoNova');
  const btnAcaoOk    = document.getElementById('acaoOk');
  const btnAcaoCanc  = document.getElementById('acaoCancelar');

  const jobsBody     = document.getElementById('jobsBody'); // para listar ações existentes do ESPECIAL NACIONAL
  const dupResumo    = document.getElementById('dupResumo');

  /* ====== UX helpers ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ====== CSV/GitHub ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else { if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; out.push(o);
    }
    return { header:H, rows:out };
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== Dados/estado ====== */
  const REGIONALS = [
    'REGIONAL BA - SE','REGIONAL DF - GO - TO','REGIONAL MG','REGIONAL MS','REGIONAL MT - RO - AC',
    'REGIONAL NORDESTE 1','REGIONAL NORDESTE 2','REGIONAL NORTE','REGIONAL PR','REGIONAL RJ - ES',
    'REGIONAL RS','REGIONAL SP','REGIONAL SC'
  ];
  let _head = [];          // header do arquivo carregado no Passo 1 (apenas para render)
  let _rows = [];          // linhas do arquivo escolhido no Passo 1 (jobs.csv ou jobs_encerrados.csv)
  let _selOTs = [];        // OTs selecionadas no Passo 1
  let _acaoPickerBound = false;

  /* ====== Helpers ====== */
  function fillRegFilter(){
    if(!selReg) return;
    if (!selReg.options.length){
      selReg.innerHTML = `<option>(todas)</option>` + REGIONALS.map(r=>`<option>${r}</option>`).join('');
    }
  }
  function ensureSelectReplacingInput(id, minWidthPx){
    const old = document.getElementById(id);
    if (old && old.tagName === 'SELECT') return old;
    const sel = document.createElement('select');
    sel.id = id; if (minWidthPx) sel.style.minWidth = minWidthPx + 'px';
    if (old) old.replaceWith(sel);
    return sel;
  }
  function updateResumo(){
    const parts = [];
    parts.push(`Selecionados: ${_selOTs.length}`);
    if (selTipoJob?.value) parts.push(`Tipo do JOB: ${selTipoJob.value}`);
    if (selNomeNovo && selNomeNovo.value) parts.push(`Nome: ${selNomeNovo.value}`);
    if (inpIni?.value && inpFim?.value) parts.push(`Período: ${inpIni.value} → ${inpFim.value}`);
    if (selTam?.value) parts.push(`Tamanho: ${selTam.value}`);
    if (inpQtd?.value) parts.push(`Páginas: ${inpQtd.value}`);
    if (radNacSim?.checked){
      parts.push('Ação nacional: Sim');
      if (inpAcaoNome?.value.trim()) parts.push(`Ação: ${inpAcaoNome.value.trim()}`);
    } else parts.push('Ação nacional: Não');
    if (dupResumo) dupResumo.textContent = parts.join(' • ');
  }

  // varre número de OT (sem considerar zeros à esquerda) — pega o MAIOR entre jobs + encerrados
  function extractMaxOTNumber(rows){
    let max=0;
    for(const r of rows){
      const m = String(r.ot||'').match(/(\d+)/);
      if(!m) continue;
      const n = parseInt(m[1],10);
      if (!isNaN(n) && n>max) max=n;
    }
    return max;
  }

  async function getAllRowsForOTScope(){
    const a = await ghGetFile(GH.jobsPath);
    const b = await ghGetFile(GH.jobsEnc);
    const A = csvToObjsAndHeader(a.text).rows || [];
    const B = csvToObjsAndHeader(b.text).rows || [];
    return A.concat(B);
  }

  // gera próximo OT SEM zeros: OT-1, OT-2, …
  function nextOTFactoryNoPad(maxInitial){
    let max = maxInitial|0;
    return () => { max += 1; return `OT-${max}`; };
  }

  /* ====== nome_tabloide.csv → OPTIONS (acentos OK) ====== */
  async function loadNomeOptionsIntoSelect(selectEl, includeBlank=true, blankText='— selecione —'){
    if (!selectEl) return;
    selectEl.innerHTML = '';
    if (includeBlank){
      const o = document.createElement('option');
      o.value = ''; o.textContent = blankText;
      selectEl.appendChild(o);
    }
    try{
      const { text } = await ghGetFile(GH.namesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      let names = [];
      if (header.length){
        const idx = header.findIndex(h => String(h||'').trim().toLowerCase() === 'nome');
        if (idx >= 0) names = rows.map(r => r[header[idx]]).filter(Boolean);
        else {
          const raw = parseCsv(text);
          for (let i=1;i<raw.length;i++){ const v=raw[i][0]; if(v) names.push(v); }
        }
      }
      names = [...new Set(names.map(s => String(s).trim()))].filter(Boolean)
              .sort((a,b)=> a.localeCompare(b,'pt-BR'));
      const frag=document.createDocumentFragment();
      names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; frag.appendChild(o); });
      selectEl.appendChild(frag);
    }catch(e){
      console.error(e);
      toast('Não foi possível carregar nome_tabloide.csv');
    }
  }

  /* ====== AÇÕES EXISTENTES (ESPECIAL NACIONAL) ====== */
  function collectExistingActions(){
    const list = [];
    document.querySelectorAll('#jobsBody tr.sub-row[data-sub]').forEach(tr=>{
      const name = (tr.getAttribute('data-sub') || '').trim();
      if (name && !list.includes(name)) list.push(name);
    });
    return list.sort((a,b)=> a.localeCompare(b,'pt-BR'));
  }
  function ensureAcaoSelect(){
    const wrap = document.getElementById('modalDup2')?.querySelector('.col-9');
    if (!wrap) return null;
    const row = wrap.querySelector('div[style*="align-items:center"]') || wrap;
    let sel = row.querySelector('#dupAcaoSel');
    if (sel) return sel;
    sel = document.createElement('select');
    sel.id = 'dupAcaoSel'; sel.style.minWidth='220px'; sel.style.flex='0 0 auto'; sel.style.marginRight='8px';
    const before = btnPickAcao; if (before && before.parentNode) before.parentNode.insertBefore(sel, before); else row.prepend(sel);
    sel.addEventListener('change', ()=>{ inpAcaoNome.value = sel.value || ''; updateResumo(); });
    return sel;
  }
  function populateAcaoSelect(){
    selAcaoExist = ensureAcaoSelect();
    if (!selAcaoExist) return;
    const actions = collectExistingActions();
    selAcaoExist.innerHTML = '';
    const ph = document.createElement('option'); ph.value=''; ph.textContent='(selecionar)'; selAcaoExist.appendChild(ph);
    actions.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; selAcaoExist.appendChild(o); });
    const v = (inpAcaoNome.value||'').trim(); selAcaoExist.value = actions.includes(v) ? v : '';
  }
  function openAcaoPicker(){
    if (!dlgAcao) return;
    const subs = collectExistingActions();
    if (boxAcoes){
      boxAcoes.innerHTML = !subs.length
        ? `<div class="hint">Nenhuma ação existente. Crie uma nova abaixo.</div>`
        : subs.map(n =>
          `<label style="display:flex;gap:8px;align-items:center;padding:6px 4px;cursor:pointer">
             <input type="radio" name="acaoPick" value="${n.replace(/"/g,'&quot;')}"> <span>${n}</span>
           </label>`).join('');
    }
    if (inpAcaoNova) inpAcaoNova.value = '';
    dlgAcao.showModal();

    if(!_acaoPickerBound){
      _acaoPickerBound = true;
      btnAcaoOk?.addEventListener('click', ()=>{
        const sel = dlgAcao.querySelector('input[name="acaoPick"]:checked');
        const chosen = sel ? sel.value : (inpAcaoNova?.value||'').trim();
        if (!chosen){ toast('Escolha ou digite uma ação.'); return; }
        inpAcaoNome.value = chosen;
        populateAcaoSelect();
        if (selAcaoExist) selAcaoExist.value = chosen;
        updateResumo();
        dlgAcao.close();
      });
      btnAcaoCanc?.addEventListener('click', ()=> dlgAcao.close());
    }
  }
  function onToggleNacional(){
    const isSim = radNacSim && radNacSim.checked;
    if (btnPickAcao) { btnPickAcao.disabled = !isSim; btnPickAcao.textContent = 'Nova ação…'; }
    if (!selAcaoExist) selAcaoExist = ensureAcaoSelect();
    if (selAcaoExist) selAcaoExist.disabled = !isSim;
    if (isSim) populateAcaoSelect();
    if (!isSim){ inpAcaoNome.value = ''; if (selAcaoExist) selAcaoExist.value = ''; }
    updateResumo();
  }

  /* ====== PASSO 1 ====== */
  function renderSelList(list){
    if(!tbodySel) return;
    if(!list.length){
      tbodySel.innerHTML = `<tr><td colspan="5" class="hint">Sem resultados. Use os filtros acima.</td></tr>`;
      return;
    }
    list.sort((a,b)=> String(a.ot||'').localeCompare(String(b.ot||''), undefined, {numeric:true, sensitivity:'base'}));
    const frag=document.createDocumentFragment();
    list.forEach(r=>{
      const tr=document.createElement('tr');
      const id='dup_'+String(r.ot||'').replace(/[^a-z0-9]/gi,'_');
      tr.innerHTML = `
        <td><input type="checkbox" data-ot="${r.ot||''}" id="${id}"></td>
        <td>${r.ot||'—'}</td>
        <td>${r.regional||'—'}</td>
        <td>${r.nome||'—'}</td>
        <td>${r.status||'—'}</td>`;
      frag.appendChild(tr);
    });
    tbodySel.innerHTML=''; tbodySel.appendChild(frag);
  }

  function applySelFilter(){
    const reg = (selReg?.value||'(todas)').trim();
    const nomeSelected = (selNomeFiltro?.value||'').trim();
    let list = _rows.slice();
    if (reg !== '(todas)') list = list.filter(r => (r.regional||'') === reg);
    if (nomeSelected)      list = list.filter(r => (r.nome||'') === nomeSelected);
    renderSelList(list);
  }

  async function loadFonteRows(){
    const path = (selFonte?.value || GH.jobsPath);
    const { text } = await ghGetFile(path, GH.branch);
    const parsed = csvToObjsAndHeader(text);
    // padroniza status em “Finalizado” quando vier do encerrados (se não tiver)
    const isEnc = path === GH.jobsEnc;
    const rows = (parsed.rows||[]).map(r=>{
      const o = {...r};
      if (isEnc && !String(o.status||'').trim()) o.status = 'Finalizado';
      return o;
    });
    _head = parsed.header||[];
    _rows = rows;
  }

  async function openStep1(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    fillRegFilter();

    // Nome (filtro) como SELECT
    selNomeFiltro = ensureSelectReplacingInput('dupNome', 220);
    await loadNomeOptionsIntoSelect(selNomeFiltro, true, '(todas)');
    selNomeFiltro.addEventListener('change', applySelFilter);

    // limpa passo 2
    if (formPar) formPar.reset();
    inpAcaoNome.value = '';
    if (!selAcaoExist) selAcaoExist = ensureAcaoSelect();
    if (selAcaoExist){ selAcaoExist.innerHTML = '<option value="">(selecionar)</option>'; selAcaoExist.disabled = true; }
    if (btnPickAcao) btnPickAcao.disabled = true;

    _selOTs = [];

    setBusy(true,'Carregando…');
    try{
      await loadFonteRows();
      renderSelList([]);
      dlgSel && dlgSel.showModal();
    }catch(e){
      console.error(e);
      toast('Falha ao carregar jobs.');
    }finally{
      setBusy(false);
    }
  }

  // troca de fonte recarrega lista
  selFonte?.addEventListener('change', async ()=>{
    setBusy(true,'Carregando…');
    try{
      await loadFonteRows();
      applySelFilter();
    }catch(e){
      console.error(e);
      toast('Erro ao ler a origem selecionada.');
    }finally{
      setBusy(false);
    }
  });

  /* ====== PASSO 2 ====== */
  async function openStep2(){
    if (formPar) formPar.reset();
    inpAcaoNome.value = '';
    if (!selAcaoExist) selAcaoExist = ensureAcaoSelect();
    if (selAcaoExist){ selAcaoExist.innerHTML = '<option value="">(selecionar)</option>'; selAcaoExist.disabled = true; }
    if (btnPickAcao) btnPickAcao.disabled = true;

    // Nome do tabloide (parâmetros) como SELECT
    selNomeNovo = ensureSelectReplacingInput('dupNomeNovo', 240);
    await loadNomeOptionsIntoSelect(selNomeNovo, true, '— selecione —');
    selNomeNovo.addEventListener('change', updateResumo);

    updateResumo();
    dlgPar?.showModal();
  }

  /* ====== Validação / Duplicar ====== */
  function validateDupParams(){
    const tipoJob = (selTipoJob?.value||'').trim();
    const nomeComum = (selNomeNovo && selNomeNovo.value || '').trim();
    const ini = (inpIni?.value||'').trim();
    const fim = (inpFim?.value||'').trim();
    const tam = (selTam?.value||'').trim();
    const qtd = (inpQtd?.value||'').trim();
    const isNac = !!(radNacSim && radNacSim.checked);
    const acao = (inpAcaoNome?.value||'').trim();

    if (!tipoJob || !nomeComum || !ini || !fim || !tam || !qtd){
      toast('Preencha Tipo do JOB, Nome, Período, Tamanho e Quantidade.');
      return null;
    }
    if (isNac && !acao){
      toast('Defina a ação nacional.');
      return null;
    }
    const qn = parseInt(qtd,10);
    if (isNaN(qn) || qn<=0){ toast('Quantidade de páginas inválida.'); return null; }

    return { tipoJob, nomeComum, ini, fim, tam, qtd: String(qn), isNac, acao };
  }
  function findJobsByOTs(ots){
    const set = new Set(ots.map(String));
    return _rows.filter(r => set.has(String(r.ot)));
  }

  async function doDuplicate(){
    if(!_selOTs.length){ toast('Nenhum job selecionado para duplicar.'); return; }
    const params = validateDupParams();
    if(!params) return;
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    const origs = findJobsByOTs(_selOTs);
    if (!origs.length){ toast('Seleção vazia.'); return; }

    setBusy(true,'Duplicando…');
    const now = new Date().toISOString();

    try{
      // 1) Carrega o jobs.csv (alvo) e também todos os jobs (alvo + encerrados) para garantir OT global
      const curJobs   = csvToObjsAndHeader((await ghGetFile(GH.jobsPath)).text);
      const encJobs   = csvToObjsAndHeader((await ghGetFile(GH.jobsEnc)).text);
      const targetH   = curJobs.header || [];
      const targetRws = curJobs.rows   || [];
      const scopeAll  = (curJobs.rows||[]).concat(encJobs.rows||[]);
      const nextOT    = nextOTFactoryNoPad(extractMaxOTNumber(scopeAll));

      // 2) Duplicar
      const newRows=[];
      for (const src of origs){
        const obj = { ...src };
        obj.ot        = nextOT();                 // <-- SEM zeros à esquerda
        obj.tipoJob   = params.tipoJob;
        obj.nome      = params.nomeComum;
        obj.ini       = params.ini;
        obj.fim       = params.fim;
        obj.tam       = params.tam;
        obj.qtd       = params.qtd;

        obj.isNacional = params.isNac ? 'sim' : 'nao';
        obj.acaoNome   = params.isNac ? params.acao : '';

        obj.status       = 'Novo';
        obj.statusStep   = 'novo';
        obj.logs         = '{}';
        obj.criado_em    = now;
        obj.atualizado_em= now;

        newRows.push(obj);
        targetRws.push(obj);
      }

      // 3) Salvar no jobs.csv
      const csv = toCsv(targetH, targetRws);
      await ghPutFile(GH.jobsPath, csv, `chore(csv): duplicate ${newRows.length} job(s)`);

      // 4) Atualiza UI
      if (typeof window.loadJobsFromGitHub === 'function') {
        await window.loadJobsFromGitHub();
      }

      toast(`${newRows.length} job(s) duplicados (OT-x).`);
      dlgPar?.close(); dlgSel?.close();
    }catch(e){
      console.error(e);
      toast('Erro ao duplicar. Tente novamente.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== BINDS ====== */
  if (btnDuplicar){ btnDuplicar.addEventListener('click', openStep1); }
  btnFiltrar?.addEventListener('click', applySelFilter);
  btnSelTodos?.addEventListener('click', ()=> tbodySel?.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=true));
  btnSelNenhum?.addEventListener('click', ()=> tbodySel?.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked=false));
  btn1Cancel?.addEventListener('click', ()=> dlgSel?.close());
  btn1Avancar?.addEventListener('click', async ()=>{
    const sel = [...(tbodySel?.querySelectorAll('input[type="checkbox"][data-ot]:checked')||[])].map(b=> b.getAttribute('data-ot'));
    if(!sel.length){ toast('Selecione ao menos 1 job.'); return; }
    _selOTs = sel;
    await openStep2();
  });

  document.getElementById('dup2Voltar')?.addEventListener('click', ()=>{ dlgPar?.close(); dlgSel?.showModal(); });
  document.getElementById('dup2Limpar')?.addEventListener('click', async ()=>{
    formPar?.reset(); inpAcaoNome.value = '';
    if (!selAcaoExist) selAcaoExist = ensureAcaoSelect();
    if (selAcaoExist){ selAcaoExist.innerHTML = '<option value="">(selecionar)</option>'; selAcaoExist.disabled = true; }
    if (btnPickAcao) btnPickAcao.disabled = true;
    selNomeNovo = ensureSelectReplacingInput('dupNomeNovo', 240);
    await loadNomeOptionsIntoSelect(selNomeNovo, true, '— selecione —');
    updateResumo();
  });
  document.getElementById('dup2Lancar')?.addEventListener('click', doDuplicate);

  [selTipoJob, inpIni, inpFim, selTam, inpQtd].forEach(el=>{ el && el.addEventListener('input', updateResumo); });
  selFonte?.addEventListener('change', ()=>{ /* a lista é recarregada em loadFonteRows() */ });
  selReg?.addEventListener('change', applySelFilter);

  radNacNao?.addEventListener('change', onToggleNacional);
  radNacSim?.addEventListener('change', onToggleNacional);
  btnPickAcao?.addEventListener('click', openAcaoPicker);

})();
</script>

<!-- ============ BOTÃO DUPLICAR — IMPLEMENTAÇÃO COMPLETA (passo 1 + passo 2 + ações nacionais + gravação em jobs.csv) ============ FIM -->

<!-- ============ BOTÃO FILTRAR — corrigido: filtro de REGIONAIS funcionando (lê r.regional OU r.regionalGrupo) ============ -->
<script>
(function(){
  /* ====== CONFIG ====== */
  const GH = {
    owner:    'JPVectorsitem',
    repo:     'LINKS-img',
    branch:   'main',
    jobsPath: 'jobs.csv',
    namesPath:'nome_tabloide.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnOpen   = document.getElementById('btnFiltrar');
  const dlg       = document.getElementById('modalFiltro');
  const btnClose  = document.getElementById('fltFechar');
  const btnClear  = document.getElementById('fltLimpar');
  const btnApply  = document.getElementById('fltAplicar');

  const selRegional = document.getElementById('fltRegional');
  const inpNomeText = document.getElementById('fltNome'); // vira SELECT
  const inpIni      = document.getElementById('fltIni');
  const inpFim      = document.getElementById('fltFim');
  const selStatus   = document.getElementById('fltStatus');
  const selNac      = document.getElementById('fltNac');
  const selAcao     = document.getElementById('fltAcao');

  const tbody       = document.getElementById('fltList');

  let selNomeBox    = null; // <select id="fltNomeSel">

  /* ====== UX helpers ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  const eqi=(a,b)=> (a||'').trim().toLowerCase()===(b||'').trim().toLowerCase();
  const parseBool = v => ['1','true','sim','yes'].includes(String(v||'').trim().toLowerCase());

  /* ====== CSV / GitHub ====== */
  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  function csvToObjects(text){
    const t=csvToObjsAndHeader(text); return t.rows;
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'' };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text = j && j.content ? b64ToUtf8(j.content) : '';
    return { text };
  }

  /* ====== Helpers ====== */
  function fillSelect(sel, options, withAllLabel){
    if (!sel) return;
    const list = withAllLabel ? [withAllLabel, ...options] : options.slice();
    sel.innerHTML = list.map(o=> `<option>${o}</option>`).join('');
  }
  function sortByOT(a,b){
    const na=(String(a.ot||'').match(/(\d+)/)||[])[1];
    const nb=(String(b.ot||'').match(/(\d+)/)||[])[1];
    const ia=na?parseInt(na,10):Number.MAX_SAFE_INTEGER;
    const ib=nb?parseInt(nb,10):Number.MAX_SAFE_INTEGER;
    if (ia!==ib) return ia-ib;
    return String(a.ot||'').localeCompare(String(b.ot||''), undefined, {numeric:true, sensitivity:'base'});
  }
  function inDateRange(jobIni, jobFim, fIni, fFim){
    if (!fIni && !fFim) return true;
    const jI = jobIni ? new Date(jobIni+'T00:00:00') : null;
    const jF = jobFim ? new Date(jobFim+'T23:59:59') : null;
    const dI = fIni   ? new Date(fIni +  'T00:00:00') : null;
    const dF = fFim   ? new Date(fFim +  'T23:59:59') : null;
    if (dI && dF){ return (!jF || jF >= dI) && (!jI || jI <= dF); }
    if (dI){ return (!jF || jF >= dI); }
    if (dF){ return (!jI || jI <= dF); }
    return true;
  }
  function updateAcaoEnabled(){
    if (!selAcao || !selNac) return;
    const on = (selNac.value === 'Sim');
    selAcao.disabled = !on;
    selAcao.style.opacity = on ? '1' : '.6';
  }
  function ensureNomeSelect(){
    if (selNomeBox && selNomeBox.tagName==='SELECT') return selNomeBox;
    const sel = document.createElement('select');
    sel.id = 'fltNomeSel';
    sel.style.minWidth = '240px';
    if (inpNomeText) {
      inpNomeText.replaceWith(sel);
    } else {
      const grid = dlg?.querySelector('.grid');
      if (grid) {
        const wrap = document.createElement('div');
        wrap.className = 'col-4';
        wrap.innerHTML = `<label>Nome do tabloide</label>`;
        wrap.appendChild(sel);
        grid.insertBefore(wrap, grid.children[1] || null);
      }
    }
    selNomeBox = sel;
    return sel;
  }
  async function loadNomeTabloideOptions(selectEl, current='(todas)'){
    if (!selectEl) return;
    selectEl.innerHTML = `<option>Carregando…</option>`;
    try{
      const { text } = await ghGetFile(GH.namesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      let names=[];
      if (header.length){
        let idx = header.findIndex(h => String(h||'').trim().toLowerCase()==='nome');
        if (idx<0) idx = 0;
        names = rows.map(r => r[header[idx]] || r[0] || '').map(s=>String(s).trim());
      }
      names = [...new Set(names)].filter(Boolean).sort((a,b)=> a.localeCompare(b,'pt-BR'));
      const all = ['(todas)', ...names];
      selectEl.innerHTML = all.map(n => `<option${n===current?' selected':''}>${n}</option>`).join('');
    }catch(e){
      console.error(e);
      selectEl.innerHTML = `<option>(todas)</option>`;
      toast('Falha ao carregar nome_tabloide.csv');
    }
  }
  async function loadAcoesToSelect(current){
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const rows = csvToObjects(text);
      const acoes = [...new Set(
        rows
          .filter(r => parseBool(r.isNacional) && (r.acaoNome||'').trim())
          .map(r => String(r.acaoNome).trim())
      )].sort((a,b)=> a.localeCompare(b,'pt-BR'));
      selAcao.innerHTML = ['(todas)', ...acoes].map(a => `<option${a===current?' selected':''}>${a}</option>`).join('');
    }catch(e){
      console.error(e);
      selAcao.innerHTML = `<option>(todas)</option>`;
    }
  }

  // NOVO: carrega as REGIONAIS existentes a partir do jobs.csv,
  // mantendo "(todas)" no topo.
  async function loadRegionaisToSelect(){
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const rows = csvToObjects(text);
      const regs = [...new Set(rows.map(r => (r.regional || r.regionalGrupo || '').trim()).filter(Boolean))]
                    .sort((a,b)=> a.localeCompare(b,'pt-BR'));
      fillSelect(selRegional, regs, '(todas)');
    }catch{
      // Se falhar, mantém o que já tiver no HTML
      if (!selRegional.options.length) selRegional.innerHTML = `<option>(todas)</option>`;
    }
  }

  function getRowRegional(r){ return (r.regional || r.regionalGrupo || ''); }

  function renderHint(){
    if (!tbody) return;
    tbody.innerHTML = `<tr><td colspan="13" class="hint">Defina os filtros e clique em “Aplicar”.</td></tr>`;
  }
  function renderRows(rows){
    if (!tbody) return;
    if (!rows.length){
      tbody.innerHTML = `<tr><td colspan="13" class="hint">Sem resultados para este filtro.</td></tr>`;
      return;
    }
    rows.sort(sortByOT);
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      const filialTxt=(r.filial||'').trim()||'—';
      const filialShort = filialTxt.length>18 ? filialTxt.slice(0,18)+'…' : filialTxt;
      const reg = getRowRegional(r);
      tr.innerHTML = `
        <td>${r.ot||'—'}</td>
        <td>${reg||'—'}</td>
        <td>${r.tipoLoja||'—'}</td>
        <td>${r.tipoJob||'—'}</td>
        <td>${r.nome||'—'}</td>
        <td>${r.compl||'—'}</td>
        <td>${r.uf||'—'}</td>
        <td><span class="clip" data-field="Filial(s)" data-full="${filialTxt}">${filialShort}</span></td>
        <td>${r.ini||'—'}</td>
        <td>${r.fim||'—'}</td>
        <td>${r.tam||'—'}</td>
        <td>${r.qtd||'—'}</td>
        <td>${r.status||'—'}</td>
      `;
      frag.appendChild(tr);
    });
    tbody.innerHTML=''; tbody.appendChild(frag);
  }

  // CORRIGIDO: aplica filtro de Regional usando r.regional OU r.regionalGrupo
  async function applyFilters(){
    if (!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

    const fRegional = (selRegional?.value || '(todas)').trim();
    const fNome     = (selNomeBox?.value || '(todas)').trim();
    const fIni      = (inpIni?.value  || '').trim();
    const fFim      = (inpFim?.value  || '').trim();
    const fStatus   = (selStatus?.value || '(todos)').trim();
    const fNac      = (selNac?.value || '(ambos)').trim();
    const fAcao     = (selAcao?.value || '(todas)').trim();

    setBusy(true,'Aplicando filtros…');
    try{
      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const rows = csvToObjects(text);

      const filtered = rows.filter(r=>{
        const rReg = getRowRegional(r);
        if (fRegional !== '(todas)' && rReg !== fRegional) return false;

        if (fNome !== '(todas)' && (r.nome||'') !== fNome) return false;

        if (fStatus !== '(todos)' && !eqi(r.status||'', fStatus)) return false;

        const isNac = parseBool(r.isNacional);
        if (fNac === 'Sim' && !isNac) return false;
        if (fNac === 'Não' && isNac) return false;

        if (fNac === 'Sim' && fAcao !== '(todas)' && !eqi(r.acaoNome||'', fAcao)) return false;

        if (!inDateRange(r.ini||'', r.fim||'', fIni||'', fFim||'')) return false;

        return true;
      });

      renderRows(filtered);
    }catch(e){
      console.error(e);
      tbody.innerHTML = `<tr><td colspan="13" class="hint">Erro ao filtrar.</td></tr>`;
    }finally{
      setBusy(false);
    }
  }

  function clearFilters(){
    if (selRegional) selRegional.value = '(todas)';
    if (selNomeBox)  selNomeBox.value  = '(todas)';
    if (inpIni)      inpIni.value      = '';
    if (inpFim)      inpFim.value      = '';
    if (selStatus)   selStatus.value   = '(todos)';
    if (selNac)      selNac.value      = '(ambos)';
    if (selAcao)     selAcao.value     = '(todas)';
    updateAcaoEnabled();
    renderHint();
  }

  // Abre o modal e prepara selects
  async function openFiltro(){
    // Regionais (agora carregadas do jobs.csv)
    await loadRegionaisToSelect();

    // Nome do tabloide (SELECT com acentos OK)
    const nomeSel = ensureNomeSelect();
    await loadNomeTabloideOptions(nomeSel, '(todas)');

    // Ações nacionais
    await loadAcoesToSelect('(todas)');

    updateAcaoEnabled();
    renderHint();
    dlg?.showModal();
  }

  /* ====== Binds ====== */
  if (btnOpen)  btnOpen.addEventListener('click', openFiltro);
  if (btnClose) btnClose.addEventListener('click', ()=> dlg?.close());
  if (btnClear) btnClear.addEventListener('click', clearFilters);
  if (btnApply) btnApply.addEventListener('click', applyFilters);
  if (selNac)   selNac.addEventListener('change', updateAcaoEnabled);

  // Clique no "..." de Filial(s) abre o modal de detalhe (reaproveita #modalCell)
  (function wireCellModal(){
    const cellDlg   = document.getElementById('modalCell');
    const cellTitle = document.getElementById('cellTitle');
    const cellBody  = document.getElementById('cellBody');
    if (!tbody || !cellDlg) return;
    tbody.addEventListener('click',(e)=>{
      const clip = e.target.closest('.clip');
      if(!clip) return;
      cellTitle.textContent = clip.getAttribute('data-field') || 'Detalhes';
      cellBody.textContent  = clip.getAttribute('data-full') || '';
      cellDlg.showModal();
    });
  })();

})();
</script>

<!-- ============ BOTÃO FILTRAR — configuração completa (abre modal, lista ações, aplica filtros) ============ FIM -->




<// ARTE + MODAL + BOTAO STATUS EM MASSA ---------------------------------- INICIO>

<!-- ==================== ETAPAS EM MASSA (botão + modal + status + lógica completa) ==================== -->
<dialog id="modalEtapasMassa">
  <form method="dialog" class="modal" id="formEtapasMassa">
    <h3>Etapas em massa</h3>

    <div class="grid" style="margin-bottom:8px">
      <div class="col-4">
        <label>Regional</label>
        <select id="emRegional">
          <option value="(todas)">(todas)</option>
          <option>REGIONAL BA - SE</option>
          <option>REGIONAL DF - GO - TO</option>
          <option>REGIONAL MG</option>
          <option>REGIONAL MS</option>
          <option>REGIONAL MT - RO - AC</option>
          <option>REGIONAL NORDESTE 1</option>
          <option>REGIONAL NORDESTE 2</option>
          <option>REGIONAL NORTE</option>
          <option>REGIONAL PR</option>
          <option>REGIONAL RJ - ES</option>
          <option>REGIONAL RS</option>
          <option>REGIONAL SP</option>
          <option>REGIONAL SC</option>
        </select>
      </div>
      <div class="col-5">
        <label>Nome do tabloide</label>
        <select id="emNome">
          <option value="(todos)">(todos)</option>
        </select>
        <div class="muted">Nomes carregados de <strong>nome_tabloide.csv</strong>.</div>
      </div>
      <div class="col-3">
        <label>Status</label>
        <select id="emStatus">
          <option value="(todos)">(todos)</option>
          <option>Novo</option>
          <option>Lista recebida</option>
          <option>Criando layout</option>
          <option>Digitando</option>
          <option>Diagramando</option>
          <option>Revisando</option>
          <option>Aprovado</option>
          <option>Encerrando</option>
          <option>Site</option>
          <option>Cancelado</option>
          <option>Finalizado</option>
        </select>
      </div>
    </div>

    <div class="frow" style="justify-content:flex-end">
      <button class="btn" type="button" id="emAplicar">Aplicar filtros</button>
      <button class="btn" type="button" id="emSelTodos">Selecionar todos</button>
      <button class="btn" type="button" id="emSelNenhum">Limpar seleção</button>
      <button class="btn primary" type="button" id="emAvancar" disabled>Avançar etapa</button>
    </div>

    <div class="list" style="margin-top:8px; max-height:55vh; overflow:auto">
      <table>
        <thead>
          <tr>
            <th style="width:36px"></th>
            <th>OT</th>
            <th>Regional</th>
            <th>Nome do tabloide</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="emList">
          <tr><td colspan="5" class="hint">Aplique os filtros para listar os jobs.</td></tr>
        </tbody>
      </table>
    </div>

    <div class="actions">
      <button class="btn" type="button" id="emFechar">Fechar</button>
    </div>
  </form>
</dialog>

<script>
(function(){
  /* ====== injeta botão ao lado do Dashboard ====== */
  (function ensureBtn(){
    const actions = document.getElementById('actions');
    if(!actions) return;
    if(document.getElementById('btnEtapasMassa')) return;
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.id = 'btnEtapasMassa';
    btn.textContent = 'Etapas em massa';
    const ref = document.getElementById('btnDash') || actions.lastElementChild;
    ref ? ref.after(btn) : actions.appendChild(btn);
  })();

  /* ====== Config GitHub ====== */
  const GH = {
    owner:'JPVectorsitem',
    repo:'LINKS-img',
    branch:'main',
    jobsPath:'jobs.csv',
    nomesPath:'nome_tabloide.csv',
    usersPath:'users.csv'
  };

  /* ====== Helpers UI/CSV/GitHub ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  function parseCsv(t){ if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){ const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr||(rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json();
    return { text: j && j.content ? b64ToUtf8(j.content) : '', sha: j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    // get current sha
    let sha=null;
    try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message: message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token), 'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== DOM Refs ====== */
  const btnOpen  = document.getElementById('btnEtapasMassa');
  const dlg      = document.getElementById('modalEtapasMassa');
  const btnClose = document.getElementById('emFechar');
  const btnApply = document.getElementById('emAplicar');
  const btnAll   = document.getElementById('emSelTodos');
  const btnNone  = document.getElementById('emSelNenhum');
  const btnNext  = document.getElementById('emAvancar');

  const selRegional = document.getElementById('emRegional');
  const selNome     = document.getElementById('emNome');
  const selStatus   = document.getElementById('emStatus');
  const tbody       = document.getElementById('emList');

  /* ====== seleção: util ====== */
  function getSelectedOTs(){
    return [...tbody.querySelectorAll('input[type="checkbox"][data-ot]:checked')]
      .map(b => (b.getAttribute('data-ot')||'').trim())
      .filter(v => v.length > 0);
  }
  function refreshSelectionState(){
    const n = getSelectedOTs().length;
    if(btnNext){
      btnNext.disabled = n === 0;
      btnNext.title = n ? '' : 'Selecione ao menos 1 job';
    }
  }

  /* ====== Nomes (nome_tabloide.csv) com acento OK ====== */
  async function loadNomesTabloide(){
    try{
      const { text } = await ghGetFile(GH.nomesPath, GH.branch);
      const { header, rows } = csvToObjsAndHeader(text);
      const key = (header.find(h => h.toLowerCase().includes('nome')) || header[0] || 'nome');
      const nomes = [...new Set(rows.map(r => (r[key]||'').trim()).filter(Boolean))]
        .sort((a,b)=> a.localeCompare(b, 'pt-BR'));
      selNome.innerHTML = '';
      const optAll = document.createElement('option'); optAll.value='(todos)'; optAll.textContent='(todos)'; selNome.appendChild(optAll);
      nomes.forEach(n=>{
        const o=document.createElement('option');
        o.value=n; o.textContent=n; selNome.appendChild(o);
      });
    }catch(e){
      console.error(e);
      selNome.innerHTML = '<option value="(todos)">(todos)</option>';
    }
  }

  /* ====== Filtro + Lista ====== */
  async function applyFilters(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    setBusy(true, 'Carregando jobs…');
    try{
      const reg = (selRegional?.value||'(todas)').trim();
      const nomeSel = (selNome?.value||'(todos)').trim();
      const statusSel = (selStatus?.value||'(todos)').trim().toLowerCase();

      const { text } = await ghGetFile(GH.jobsPath, GH.branch);
      const { header:H, rows } = csvToObjsAndHeader(text);

      const out = rows.filter(r=>{
        const okReg = (reg==='(todas)') || ((r.regional||'').trim()===reg);
        const okNom = (nomeSel==='(todos)') || ((r.nome||'').trim()===nomeSel);
        const okSta = (statusSel==='(todos)') || ((r.status||'').trim().toLowerCase()===statusSel);
        return okReg && okNom && okSta;
      }).sort((a,b)=> (a.ot||'').localeCompare(b.ot||'', undefined, {numeric:true, sensitivity:'base'}));

      if(!out.length){
        tbody.innerHTML = `<tr><td colspan="5" class="hint">Nenhum job encontrado com esses filtros.</td></tr>`;
        refreshSelectionState();
        return;
      }

      const frag = document.createDocumentFragment();
      out.forEach(r=>{
        const ot = (r.ot||'').trim();
        const hasOT = ot.length > 0;
        const id = 'em_'+(ot ? ot.replace(/[^a-z0-9]/gi,'_') : Math.random().toString(36).slice(2));
        const tr = document.createElement('tr');
        const td0 = document.createElement('td');
        const cb  = document.createElement('input');
        cb.type='checkbox';
        cb.setAttribute('data-ot', hasOT ? ot : '');
        if(!hasOT) cb.disabled = true;
        cb.id = id;
        td0.appendChild(cb);

        const td1 = document.createElement('td'); td1.textContent = ot || '—';
        const td2 = document.createElement('td'); td2.textContent = r.regional||'—';
        const td3 = document.createElement('td'); td3.textContent = r.nome||'—';
        const td4 = document.createElement('td'); td4.textContent = r.status||'—';

        tr.appendChild(td0); tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4);
        frag.appendChild(tr);
      });
      tbody.innerHTML = '';
      tbody.appendChild(frag);

      refreshSelectionState();
    }catch(e){
      console.error(e);
      tbody.innerHTML = `<tr><td colspan="5" class="hint">Erro ao carregar jobs.</td></tr>`;
      refreshSelectionState();
    }finally{
      setBusy(false);
    }
  }

  /* ====== Batch: abre modal do "+" já preparado ====== */
  async function openBatchEvtForTargets(ots){
    if(!ots.length){ toast('Seleção inválida. Marque ao menos um job.'); return; }

    async function loadUsersByRole(){
      const { text } = await ghGetFile(GH.usersPath, GH.branch);
      const { rows } = csvToObjsAndHeader(text);
      const roles = ['Layout','Digitador','Diagramador','Revisor','Encerramento','Site'];
      const by = {}; roles.forEach(r=> by[r]=[]);
      rows.forEach(u=>{
        const p=(u.cargo_principal||u.cargo||'').trim();
        const s=(u.cargo_secundaria||'').trim();
        roles.forEach(r=>{
          if (p.toLowerCase()===r.toLowerCase() || s.toLowerCase()===r.toLowerCase()){
            by[r].push(u.nome||'');
          }
        });
      });
      roles.forEach(r=> by[r] = [...new Set(by[r])].filter(Boolean).sort((a,b)=>a.localeCompare(b,'pt-BR')));
      return by;
    }

    function renderEvtFields(byRole, count){
      const addFields = document.getElementById('addEvtFields');
      const addTitle  = document.getElementById('addEvtTitle');
      if(addTitle) addTitle.textContent = count>1 ? `Adicionar evento (+) — ${count} selecionados` : 'Adicionar evento (+)';
      if(!addFields) return;

      const stepOpts = [
        ['lista','Lista'],
        ['aprovacao','Aprovação'],
        ['cancelado','Cancelado'],
        ['layout','Layout'],
        ['digitacao','Digitação'],
        ['diagramacao','Diagramação'],
        ['revisao','Revisão'],
        ['encerramento','Encerramento'],
        ['site','Site']
      ].map(([v,l])=> `<option value="${v}">${l}</option>`).join('');

      addFields.innerHTML = `
        <div class="field">
          <label>Etapa</label>
          <select id="evtStep">${stepOpts}</select>
          <div class="muted">${count>1 ? `Esta ação será aplicada em <strong>${count}</strong> job(s).` : ''}</div>
        </div>
        <div id="evtWhoWrap" class="field">
          <label>Responsável</label>
          <input id="evtWhoText" type="text" placeholder="Nome do responsável" />
          <select id="evtWhoSel" style="display:none"></select>
          <div class="muted" id="evtHint"></div>
        </div>
      `;

      const selStep = addFields.querySelector('#evtStep');
      const inpText = addFields.querySelector('#evtWhoText');
      const selWho  = addFields.querySelector('#evtWhoSel');
      const hint    = addFields.querySelector('#evtHint');

      function applyRoleUI(stepKey){
        const mapRole = {
          layout:'Layout', digitacao:'Digitador', diagramacao:'Diagramador',
          revisao:'Revisor', encerramento:'Encerramento', site:'Site'
        };
        const role = mapRole[stepKey] || null;
        if (!role){
          selWho.style.display='none';
          inpText.style.display='block';
          inpText.value='';
          hint.textContent = 'Digite o nome manualmente.';
        } else {
          const list = byRole[role] || [];
          selWho.innerHTML = list.length ? list.map(n=>`<option>${n.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</option>`).join('') : '<option>(sem nomes para este cargo)</option>';
          selWho.style.display='block';
          inpText.style.display='none';
          hint.innerHTML = `Selecione alguém do cargo <strong>${role}</strong>.`;
        }
      }
      selStep.addEventListener('change', ()=> applyRoleUI(selStep.value));
      applyRoleUI(selStep.value);
    }

    try{
      setBusy(true,'Preparando…');
      const byRole = await loadUsersByRole();
      window.__evtBatchTargets = ots.slice(); // alvos da ação em massa
      renderEvtFields(byRole, ots.length);
      document.getElementById('modalAddEvt')?.showModal();
    }catch(e){
      console.error(e);
      toast('Falha ao abrir a etapa em massa.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== Aplica SALVAR do modal "+" em lote (sem quebrar comportamento atual) ====== */
  (function hookBatchOk(){
    const ok = document.getElementById('btnAddEvtOk');
    if(!ok) return; // modal ainda não no DOM, mas no seu HTML original ele existe

    // evita duplicar
    if(ok.__batchHookAttached) return;
    ok.__batchHookAttached = true;

    ok.addEventListener('click', async (e)=>{
      const targets = Array.isArray(window.__evtBatchTargets) ? window.__evtBatchTargets : [];
      if(!targets.length) return; // deixa o handler original tratar o modo single

      e.stopImmediatePropagation();
      e.preventDefault();

      const fields = document.getElementById('addEvtFields');
      const step = fields?.querySelector('#evtStep')?.value || 'lista';
      const whoText = fields?.querySelector('#evtWhoText');
      const whoSel  = fields?.querySelector('#evtWhoSel');
      let nomeResp = '';
      // se select visível, usa select; senão usa texto
      if(whoSel && whoSel.style.display !== 'none') nomeResp = (whoSel.value||'').trim();
      else nomeResp = (whoText?.value||'').trim();
      if(!nomeResp){ toast('Informe o responsável.'); return; }

      // mapeia step -> status
      const STEP_STATUS = {
        lista:'Lista recebida',
        aprovacao:'Aprovado',
        cancelado:'Cancelado',
        layout:'Criando layout',
        digitacao:'Digitando',
        diagramacao:'Diagramando',
        revisao:'Revisando',
        encerramento:'Encerrando',
        site:'Site'
      };

      function nowISO(){ return new Date().toISOString(); }
      function statusToClass(status){
        const s=(status||'').toLowerCase();
        if(s==='novo') return 'st-novo';
        if(s==='lista recebida') return 'st-lista';
        if(s==='criando layout') return 'st-layout';
        if(s==='digitando') return 'st-digitando';
        if(s==='diagramando') return 'st-diagramando';
        if(s==='revisando') return 'st-revisando';
        if(s==='aprovado') return 'st-aprovado';
        if(s==='encerrando') return 'st-encerrando';
        if(s==='site') return 'st-site';
        if(s==='cancelado') return 'st-cancelado';
        if(s==='finalizado') return 'st-finalizado';
        return '';
      }
      function parseLogs(raw){
        try{ const j=JSON.parse(raw||'{}'); return j && typeof j==='object' ? j : {}; }catch{ return {}; }
      }

      if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }

      setBusy(true, 'Salvando…');
      try{
        const { text } = await ghGetFile(GH.jobsPath, GH.branch);
        const { header:H, rows } = csvToObjsAndHeader(text);
        if(!H.length){ toast('Estrutura de jobs.csv inválida.'); setBusy(false); return; }

        const byOT = new Map(rows.map(r=>[String(r.ot||'').trim(), r]));
        const ev = { nome:nomeResp, ts: nowISO() };
        const newStatus = STEP_STATUS[step] || 'Novo';

        // atualiza objetos em memória
        targets.forEach(ot=>{
          const r = byOT.get(String(ot).trim());
          if(!r) return;
          const logs = parseLogs(r.logs);
          if(!Array.isArray(logs[step])) logs[step] = [];
          logs[step].push(ev);
          r.logs = JSON.stringify(logs);
          r.status = newStatus;
          r.statusStep = step;
          r.atualizado_em = nowISO();
        });

        // re-monta CSV
        const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
        const toCsvLine=o=> H.map(k=> csvEsc(o[k] ?? '')).join(',');
        const newText = H.join(',')+'\n'+rows.map(toCsvLine).join('\n')+'\n';
        await ghPutFile(GH.jobsPath, newText, `chore(csv): batch etapa (${targets.length})`);

        // atualiza UI (cores e texto do status)
        targets.forEach(ot=>{
          const tr = document.querySelector(`#jobsBody tr[data-ot="${CSS.escape(ot)}"]`);
          if(!tr) return;
          // limpa classes status antigas
          tr.className = tr.className.replace(/\bst\-[a-z]+/g,'').trim();
          tr.classList.add(statusToClass(newStatus));
          // coluna STATUS é a 13ª (0-index 12)
          const tdStatus = tr.children && tr.children[12];
          if(tdStatus) tdStatus.textContent = newStatus;
        });

        // fecha modal +
        document.getElementById('modalAddEvt')?.close();
        window.__evtBatchTargets = []; // limpa
        toast(`Etapa aplicada em ${targets.length} job(s).`);
      }catch(err){
        console.error(err);
        toast('Erro ao salvar alteração em lote.');
      }finally{
        setBusy(false);
      }
    });
  })();

  /* ====== binds ====== */
  if(btnOpen && dlg){
    btnOpen.addEventListener('click', async ()=>{
      try{ await loadNomesTabloide(); }catch{}
      tbody.innerHTML = `<tr><td colspan="5" class="hint">Aplique os filtros para listar os jobs.</td></tr>`;
      refreshSelectionState();
      dlg.showModal();
    });
  }
  if(btnClose && dlg) btnClose.addEventListener('click', ()=> dlg.close());
  if(btnApply) btnApply.addEventListener('click', applyFilters);

  // seleção
  if(btnAll)  btnAll.addEventListener('click', ()=>{
    tbody.querySelectorAll('input[type="checkbox"][data-ot]:not(:disabled)').forEach(b=> b.checked = true);
    refreshSelectionState();
  });
  if(btnNone) btnNone.addEventListener('click', ()=>{
    tbody.querySelectorAll('input[type="checkbox"][data-ot]').forEach(b=> b.checked = false);
    refreshSelectionState();
  });
  tbody.addEventListener('change', (e)=>{
    if(e.target && e.target.matches('input[type="checkbox"][data-ot]')) refreshSelectionState();
  });

  if(btnNext){
    btnNext.addEventListener('click', ()=>{
      const sel = getSelectedOTs();
      if(!sel.length){
        toast('Seleção inválida. Marque ao menos um job.');
        refreshSelectionState();
        return;
      }
      openBatchEvtForTargets(sel);
    });
    refreshSelectionState();
  }
})();
</script>

<!-- ==================== /ETAPAS EM MASSA ==================== FIM -->

<//!OTIMIZAÇÃO LEITURA + GRAVAÇÃO ------>

<script>
(function(){
  "use strict";

  // Namespace único
  window.WV = window.WV || {};
  const GH = (WV.cfg && WV.cfg.GH) || {
    owner: 'JPVectorsitem',
    repo:  'LINKS-img',
    branch:'main',
    jobsPath: 'jobs.csv'
  };

  /* ===================== Utils ===================== */
  function getToken(){
    try{
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}');
      return (window.gh && window.gh.token) || saved.token || '';
    }catch{ return (window.gh && window.gh.token) || ''; }
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  function b64ToUtf8(b64){
    const bin=atob(b64); const bytes=new Uint8Array(bin.length);
    for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});

  // CSV helpers pra quem quiser usar WV.sync.pushCsv(head, rows)
  const csvEsc = v => {
    v = v==null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  const toCsv   = (H, rows) => H.join(',')+'\n' + rows.map(o => H.map(k=>csvEsc(o[k]??'')).join(',')).join('\n') + '\n';
  WV.csv = WV.csv || { toCsv, csvEsc };

  /* =================== Sync Engine ================== */
  WV.sync = (function(){
    let readTimer=null, writeTimer=null;
    let readEvery=1000, writeEvery=1000;

    let jobsEtag=null, jobsSha=null, lastText=null;
    let reading=false, writing=false;
    let started=false;

    // Backoff (auto-ajuste de intervalo quando der erro/limite)
    let readBackoff=1, writeBackoff=1;          // multiplicadores
    const BMIN=1, BMAX=15;                      // 1x..15x
    const BASE_READ=1000, BASE_WRITE=1000;      // ms base
    const HIDDEN_READ=3500;                     // quando aba oculta

    const writeQueue=[]; // coalesce (sempre usa o último CSV enfileirado)

    async function ghGetFileWithETag(path){
      const token = getToken();
      if(!token) throw new Error('Token GitHub não configurado.');

      const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(GH.branch)}`;
      const headers = ghHeaders(token);
      if(jobsEtag) headers['If-None-Match'] = jobsEtag;

      const r = await fetch(url, { headers });
      if(r.status === 304) return { notModified:true }; // rápido

      if(!r.ok){
        const t = await r.text();
        throw new Error('GET '+r.status+': '+t);
      }

      const etag = r.headers.get('ETag') || null;
      const j = await r.json();
      // /contents => base64
      const text = j && j.content ? b64ToUtf8(j.content) : '';
      return { text, sha: j.sha || null, etag };
    }

    async function ghPutFile(path, newText){
      const token = getToken();
      if(!token) throw new Error('Token GitHub não configurado.');

      if(!jobsSha){
        const fresh = await ghGetFileWithETag(path);
        if(!fresh.notModified){
          jobsSha = fresh.sha || jobsSha;
          jobsEtag = fresh.etag || jobsEtag;
          lastText = (fresh.text!=null?fresh.text:lastText);
        }
      }

      const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
      const body = {
        message: `chore(csv): update ${path}`,
        content: utf8ToB64(newText),
        branch: GH.branch,
        ...(jobsSha ? { sha: jobsSha } : {})
      };
      const r = await fetch(url, { method:'PUT', headers:{...ghHeaders(token),'Content-Type':'application/json'}, body: JSON.stringify(body) });
      const txt = await r.text();
      if(!r.ok) throw new Error('PUT '+r.status+': '+txt);

      let newSha=null;
      try{ const j=JSON.parse(txt); newSha=j?.content?.sha||null; }catch{}
      return { sha:newSha };
    }

    function scheduleLoops(){
      clearInterval(readTimer); clearInterval(writeTimer);
      const isHidden = document.hidden;
      const re = Math.max(250, (isHidden? HIDDEN_READ : BASE_READ) * readBackoff);
      const we = Math.max(250, BASE_WRITE * writeBackoff);
      readEvery = re; writeEvery = we;

      readTimer  = setInterval(readTick,  re);
      writeTimer = setInterval(writeTick, we);
    }

    async function readTick(){
      if(reading) return;
      reading = true;
      try{
        const res = await ghGetFileWithETag(GH.jobsPath);
        if(res.notModified){ readBackoff = Math.max(BMIN, readBackoff * 0.9); return; } // estabiliza para 304
        // Mudou:
        lastText = res.text;
        if(res.sha)  jobsSha  = res.sha;
        if(res.etag) jobsEtag = res.etag;

        // dispara atualização de UI (usa seu loader existente)
        if(typeof WV.onJobsFileUpdate === 'function'){
          WV.onJobsFileUpdate(lastText);
        }else if(typeof window.loadJobsFromGitHub === 'function'){
          window.loadJobsFromGitHub();
        }
        readBackoff = Math.max(BMIN, readBackoff * 0.8);
      }catch(e){
        // 403/429 -> aumenta backoff (evita rate limit)
        if(String(e).includes('403') || String(e).includes('429')) readBackoff = Math.min(BMAX, readBackoff*1.75);
        else readBackoff = Math.min(BMAX, readBackoff*1.35);
        scheduleLoops();
        // console.warn('[sync] read error', e);
      }finally{ reading=false; }
    }

    async function writeTick(){
      if(writing) return;
      if(writeQueue.length===0) return;
      writing = true;

      // coalesce: pega o último CSV
      const item = writeQueue.splice(0, writeQueue.length).pop();

      try{
        const { sha } = await ghPutFile(GH.jobsPath, item.text);
        if(sha) jobsSha = sha;
        writeBackoff = Math.max(BMIN, writeBackoff * 0.8);
        // leitura imediata pra alinhar ETag/sha/UI
        await readTick();
      }catch(err){
        const msg = String(err||'');
        if(msg.includes('409')){ // conflito: refaz SHA e tenta 1x
          try{
            const fresh = await ghGetFileWithETag(GH.jobsPath);
            if(!fresh.notModified){
              jobsSha = fresh.sha || jobsSha;
              jobsEtag = fresh.etag || jobsEtag;
              lastText = (fresh.text!=null?fresh.text:lastText);
            }
            const { sha } = await ghPutFile(GH.jobsPath, item.text);
            if(sha) jobsSha = sha;
            writeBackoff = Math.max(BMIN, writeBackoff * 0.9);
            await readTick();
          }catch(e2){
            writeBackoff = Math.min(BMAX, writeBackoff*1.5);
          }
        }else{
          // 403/429 = limite -> aumenta backoff
          if(msg.includes('403') || msg.includes('429')) writeBackoff = Math.min(BMAX, writeBackoff*1.8);
          else writeBackoff = Math.min(BMAX, writeBackoff*1.3);
        }
        scheduleLoops();
      }finally{ writing=false; }
    }

    function enqueueWrite(csvText){
      if(typeof csvText==='string'){
        writeQueue.push({ text: csvText });
      }
    }

    function start(opts={}){
      if(started) return;
      started=true;
      // quando token surgir (depois que o usuário salvar no modal ⚙), inicia
      const boot = () => {
        if(!getToken()){ setTimeout(boot, 400); return; }
        // Primeira leitura imediata e loops
        readTick().finally(scheduleLoops);
      };
      boot();

      // Ajustes live se o tab ficar oculto/visível
      document.addEventListener('visibilitychange', scheduleLoops);
      // Se alguém mudar o token em outra aba
      window.addEventListener('storage', (e)=>{ if(e.key==='wv_gh_cfg') scheduleLoops(); });

      // ajustes opcionais do usuário
      if(opts.readEveryMs)  { /* mantemos base e o backoff cuida */ }
      if(opts.writeEveryMs) { /* idem */ }
    }

    function stop(){
      clearInterval(readTimer); clearInterval(writeTimer);
      readTimer=writeTimer=null; started=false;
    }

    return { start, stop, enqueueWrite, toCsv };
  })();

  /* =========== Auto-start: liga sozinho =========== */
  // Vai iniciar assim que o token existir.
  WV.sync.start();

  // OPCIONAL: se você, em algum lugar, montar o CSV e quiser salvar via fila rápida:
  // WV.sync.enqueueWrite(WV.csv.toCsv(head, rows));

})();
</script>
<//!OTIMIZAÇÃO LEITURA + GRAVAÇÃO ---- FIM>

<//! PERSISTENCIA LOGIN 20 min ---->

<script>
(function(){
  "use strict";

  // ======= Config =======
  const IDLE_MS = 20 * 60 * 1000; // 20 minutos

  // ======= Elementos =======
  const loginView = document.getElementById('loginView');
  const jobsApp   = document.getElementById('jobsApp');
  const elUserName= document.getElementById('userName');
  const chip1     = document.getElementById('cargo1');
  const chip2     = document.getElementById('cargo2');
  const btnSair   = document.getElementById('btnSair');
  const inpEmail  = document.getElementById('email');
  const inpSenha  = document.getElementById('senha');
  const toastEl   = document.getElementById('toast');

  // ======= Helpers UI =======
  function toast(msg){
    if(!toastEl) return;
    toastEl.textContent = msg;
    toastEl.style.display = 'block';
    setTimeout(()=> toastEl.style.display='none', 2200);
  }
  function roleKey(c){
    const k=(c||'').trim().toLowerCase();
    if(['administrador','administrator','diretor','gerente'].includes(k)) return 'prata';
    if(k==='trafego') return 'verde';
    if(k==='layout') return 'roxo';
    if(k==='digitador') return 'azul';
    if(k==='diagramador') return 'laranja';
    if(k==='revisor') return 'rosa';
    if(k==='encerramento') return 'amarelo';
    if(k==='site') return 'roxoclaro';
    return 'prata';
  }

  function showJobsUI(user){
    if (elUserName) elUserName.textContent = user?.nome || '—';

    if (chip1) {
      const c1 = user?.cargo_principal || user?.cargo || '';
      if (c1) {
        chip1.textContent = c1;
        chip1.className = 'role-chip role-' + roleKey(c1);
        chip1.style.display = 'inline-block';
      } else chip1.style.display = 'none';
    }
    if (chip2) {
      const c2 = user?.cargo_secundaria || '';
      if (c2) {
        chip2.textContent = c2;
        chip2.className = 'role-chip role-' + roleKey(c2);
        chip2.style.display = 'inline-block';
      } else chip2.style.display = 'none';
    }

    if (loginView) { loginView.classList.add('hide'); loginView.setAttribute('aria-hidden','true'); }
    if (jobsApp)   { jobsApp.classList.remove('hide'); jobsApp.setAttribute('aria-hidden','false'); }

    if (typeof window.applyPermissions === 'function') window.applyPermissions();
    // dispara seus carregadores, se precisar
    if (typeof window.TurboJobs?.mount === 'function') {
      window.TurboJobs.mount().catch(()=>{});
    } else if (typeof window.loadJobsFromGitHub === 'function' && typeof window.insertJobRow === 'function') {
      window.loadJobsFromGitHub();
    }
  }

  function showLoginUI(reason){
    // reseta cabeçalho do usuário
    if (elUserName) elUserName.textContent = '—';
    if (chip1) { chip1.style.display = 'none'; chip1.textContent = ''; }
    if (chip2) { chip2.style.display = 'none'; chip2.textContent = ''; }

    if (jobsApp)   { jobsApp.classList.add('hide'); jobsApp.setAttribute('aria-hidden','true'); }
    if (loginView) { loginView.classList.remove('hide'); loginView.setAttribute('aria-hidden','false'); }

    if (inpSenha) inpSenha.value = '';
    if (inpEmail) inpEmail.focus();

    if (reason === 'idle') toast('Sessão expirada por inatividade (20 min).');
  }

  // ======= Persistência =======
  const SKEY = 'wv_session';
  function saveSession(user){
    const data = {
      isLoggedIn: true,
      user: {
        nome: user?.nome || '',
        cargo_principal: user?.cargo_principal || user?.cargo || '',
        cargo_secundaria: user?.cargo_secundaria || ''
      },
      lastActivity: Date.now(),
      loggedInAt: Date.now()
    };
    localStorage.setItem(SKEY, JSON.stringify(data));
  }
  function loadSession(){
    try{
      const j = JSON.parse(localStorage.getItem(SKEY) || '{}');
      if(j && j.isLoggedIn && j.user) return j;
    }catch{}
    return null;
  }
  function clearSession(){
    localStorage.removeItem(SKEY);
  }
  function touchActivity(){
    const s = loadSession();
    if(!s) return;
    s.lastActivity = Date.now();
    localStorage.setItem(SKEY, JSON.stringify(s));
  }

  // ======= Idle Timer =======
  let idleTimer = null;
  function scheduleIdleCheck(){
    clearTimeout(idleTimer);
    const s = loadSession();
    if(!s || !s.isLoggedIn) return;
    const remain = Math.max(0, IDLE_MS - (Date.now() - (s.lastActivity||Date.now())));
    idleTimer = setTimeout(()=> doLogout('idle'), remain || 0);
  }

  // ======= Login/Logout de verdade =======
  function doLoginFromCurrentUser(){
    // usa o que seu fluxo já definiu
    const u = window.currentUser;
    if(!u) return;
    window.currentUser = {
      nome: u.nome || '',
      cargo_principal: u.cargo_principal || u.cargo || '',
      cargo_secundaria: u.cargo_secundaria || ''
    };
    saveSession(window.currentUser);
    showJobsUI(window.currentUser);
    touchActivity();
    scheduleIdleCheck();
  }

  function doLoginFromStored(){
    const s = loadSession();
    if(!s || !s.isLoggedIn) return false;
    window.currentUser = {
      nome: s.user?.nome || '',
      cargo_principal: s.user?.cargo_principal || '',
      cargo_secundaria: s.user?.cargo_secundaria || ''
    };
    showJobsUI(window.currentUser);
    touchActivity();           // ao entrar/refresh, reseta o cronômetro
    scheduleIdleCheck();
    return true;
    }

  function doLogout(reason){
    clearSession();
    window.currentUser = null;
    showLoginUI(reason);
  }

  // ======= Observa o momento do login do seu fluxo =======
  // Quando #jobsApp ficar visível e houver window.currentUser,
  // persistimos a sessão (útil quando o login acontece pelo botão).
  if (jobsApp){
    const mo = new MutationObserver(() => {
      const visible = !jobsApp.classList.contains('hide') && jobsApp.getAttribute('aria-hidden') !== 'true';
      if (visible && window.currentUser && loadSession()?.isLoggedIn !== true){
        doLoginFromCurrentUser();
      }
    });
    mo.observe(jobsApp, { attributes: true, attributeFilter: ['class','aria-hidden'] });
  }

  // ======= Captura atividades do usuário =======
  const ACT_EVENTS = ['pointerdown','keydown','mousemove','scroll','touchstart','wheel'];
  const onAct = () => { touchActivity(); scheduleIdleCheck(); };
  ACT_EVENTS.forEach(ev => window.addEventListener(ev, onAct, { passive:true }));
  document.addEventListener('visibilitychange', () => {
    // se voltou pra aba depois de muito tempo, checa expiração
    const s = loadSession();
    if(!s || !s.isLoggedIn) return;
    if (document.visibilityState === 'visible') {
      const passed = Date.now() - (s.lastActivity || 0);
      if (passed >= IDLE_MS) {
        doLogout('idle');
      } else {
        onAct();
      }
    }
  });

  // ======= Sincroniza entre abas =======
  window.addEventListener('storage', (e)=>{
    if(e.key !== SKEY) return;
    const s = loadSession();
    if(!s || !s.isLoggedIn){
      // logout em outra aba
      showLoginUI();
      window.currentUser = null;
      clearTimeout(idleTimer);
    }else{
      // login/refresh em outra aba
      window.currentUser = {
        nome: s.user?.nome || '',
        cargo_principal: s.user?.cargo_principal || '',
        cargo_secundaria: s.user?.cargo_secundaria || ''
      };
      showJobsUI(window.currentUser);
      scheduleIdleCheck();
    }
  });

  // ======= Integra com seu botão "Sair" (garante limpar storage) =======
  if (btnSair){
    btnSair.addEventListener('click', () => {
      // deixa seu handler atual cuidar da UI; nós só limpamos a sessão
      clearSession();
    }, { passive:true });
  }

  // ======= Bootstrap: tenta restaurar sessão ao abrir/atualizar =======
  // se existir sessão salva, entra direto e reseta o timer
  doLoginFromStored();

  // expõe um mini-API opcional
  window.WV = window.WV || {};
  window.WV.session = {
    logout: () => doLogout('manual'),
    touch:  onAct,
    isLogged: () => !!(loadSession() && loadSession().isLoggedIn),
    getUser: () => (loadSession()?.user || null),
    IDLE_MS
  };
})();
</script>

<//! PERSISTENCIA LOGIN 20 min FIM ---->

<//!PREMISSÕES SEPARADOS POR CARGOS ---->

<script>
(function(){
  "use strict";

  // ========= util: normalização de cargos =========
  const ACCENT = (s)=> String(s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().trim();
  const ROLE_ALIAS = new Map([
    ['administrador','administrador'], ['adminstrador','administrador'], ['administrator','administrador'],
    ['diretor','diretor'], ['gerente','gerente'],
    ['trafego','trafego'], ['tráfego','trafego'],
    ['layout','layout'], ['digitador','digitador'],
    ['diagramador','diagramador'], ['diagramação','diagramador'], ['diagramacao','diagramador'],
    ['revisor','revisor'], ['encerramento','encerramento'], ['site','site']
  ]);
  const canonRole = (name)=> ROLE_ALIAS.get(ACCENT(name)) || ACCENT(name);

  function getUserRoles(){
    const u = (window.currentUser || {});
    const r1 = canonRole(u.cargo_principal || u.cargo || '');
    const r2 = canonRole(u.cargo_secundaria || '');
    const roles = [r1, r2].filter(Boolean);
    return Array.from(new Set(roles));
  }

  // ========= conjuntos =========
  const ROLESETS = {
    TOTAL: ['administrador','diretor','gerente','trafego'], // "permissão total"
  };

  // ========= botões (IDs) -> quem pode =========
  const ACTIONS = {
    btnNovo:            [...ROLESETS.TOTAL, 'layout'],
    btnDuplicar:        [...ROLESETS.TOTAL, 'layout'],
    btnEditar:          [...ROLESETS.TOTAL, 'layout'],
    btnFiltrar:         'ALL',
    btnDash:            'ALL',
    btnVerFinalizados:  [...ROLESETS.TOTAL, 'layout'],
    btnEtapasMassa:     [...ROLESETS.TOTAL],            // se o botão não existir, ignora
    btnFinalizar:       [...ROLESETS.TOTAL, 'site'],
    btnExcluir:         [...ROLESETS.TOTAL, 'layout'],
    btnEncerrar:        [...ROLESETS.TOTAL, 'encerramento'],
  };

  // ========= etapas por cargo (para quem NÃO é TOTAL) =========
  // IMPORTANTÍSSIMO: estas etapas de sistema são SOMENTE para TOTAL:
  const SYSTEM_ONLY_STEPS = new Set(['lista','aprovacao','cancelado']);

  const ROLE_TO_STEPS = {
    layout:       ['layout'],
    digitador:    ['digitacao'],
    diagramador:  ['diagramacao'],
    revisor:      ['revisao'],
    encerramento: ['encerramento'],
    site:         ['site'],
  };

  // ========= helpers perm =========
  function hasAny(required){
    const have = new Set(getUserRoles());
    return required.some(r => have.has(r));
  }
  function canAction(id){
    const rule = ACTIONS[id];
    if (!rule) return true;
    if (rule === 'ALL') return true;
    return hasAny(rule.map(canonRole));
  }
  function hasFullEtapas(){
    return hasAny(ROLESETS.TOTAL);
  }
  function allowedSteps(){
    if (hasFullEtapas()) {
      // TOTAL: tudo
      return new Set(['lista','aprovacao','cancelado','layout','digitacao','diagramacao','revisao','encerramento','site']);
    }
    // demais: apenas o(s) do(s) cargo(s) 1/2; NUNCA as de sistema
    const roles = getUserRoles();
    const allow = new Set();
    roles.forEach(r => (ROLE_TO_STEPS[r]||[]).forEach(s => allow.add(s)));
    // garante que as de sistema nunca entrem
    SYSTEM_ONLY_STEPS.forEach(s => allow.delete(s));
    return allow;
  }

  // expõe
  window.WV = window.WV || {};
  window.WV.perms = { rolesOf:getUserRoles, canAction, hasFullEtapas, allowedSteps };

  // ========= esconder botões sem permissão =========
  const BTN_IDS = [
    'btnNovo','btnDuplicar','btnEditar','btnFiltrar','btnDash','btnVerFinalizados',
    'btnEtapasMassa','btnFinalizar','btnExcluir','btnEncerrar'
  ];
  function hideEl(el, hide){
    if (!el) return;
    if (hide){
      if (el.style.display !== 'none'){
        el.dataset.prevDisplay = el.style.display || '';
        el.style.display = 'none';
      }
    } else {
      el.style.display = el.dataset.prevDisplay || '';
    }
  }
  function applyPermissions(){
    BTN_IDS.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      hideEl(el, !canAction(id));
    });
  }
  window.applyPermissions = applyPermissions;

  // aplica ao carregar / login
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyPermissions, { once:true });
  } else {
    applyPermissions();
  }

  // ========= controle do modal de ETAPAS (“+”) =========
  // bloqueio hard de clique em etapas não permitidas
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#etapasList [data-add-step]');
    if (!btn) return;
    const step = String(btn.getAttribute('data-add-step')||'').toLowerCase();

    const full = hasFullEtapas();
    const allow = allowedSteps();

    // sistema (lista/aprovacao/cancelado) só TOTAL
    if (SYSTEM_ONLY_STEPS.has(step) && !full){
      e.preventDefault(); e.stopPropagation();
      const t=document.getElementById('toast'); if(t){ t.textContent='Sem permissão para esta etapa.'; t.style.display='block'; setTimeout(()=>t.style.display='none',1600); }
      return;
    }
    // demais: precisa estar no allow
    if (!full && !allow.has(step)){
      e.preventDefault(); e.stopPropagation();
      const t=document.getElementById('toast'); if(t){ t.textContent='Sem permissão para esta etapa.'; t.style.display='block'; setTimeout(()=>t.style.display='none',1600); }
      return;
    }
  }, true);

  // ao abrir o modal, ESCONDER cartões de etapas sem permissão
  function restrictEtapasModalUI(){
    const dlg  = document.getElementById('modalEtapas');
    const list = document.getElementById('etapasList');
    if (!dlg || !dlg.open || !list) return;

    const full = hasFullEtapas();
    const allow = allowedSteps();

    list.querySelectorAll('.etapaCard').forEach(card => {
      const addBtn = card.querySelector('[data-add-step]');
      if (!addBtn) { hideEl(card, true); return; }
      const step = String(addBtn.getAttribute('data-add-step')||'').toLowerCase();

      let can = true;
      if (SYSTEM_ONLY_STEPS.has(step)) can = full; // sistema => só TOTAL
      else if (!full) can = allow.has(step);       // demais => conforme cargo

      hideEl(card, !can);
    });
  }

  // empacota openEtapasModal para aplicar quando abrir
  (function wrapOpenEtapas(){
    const tryWrap = () => {
      if (typeof window.openEtapasModal === 'function' && !window.openEtapasModal._wrapped){
        const orig = window.openEtapasModal;
        window.openEtapasModal = function(ot){
          const r = orig.call(this, ot);
          setTimeout(restrictEtapasModalUI, 0);
          return r;
        };
        window.openEtapasModal._wrapped = true;
      }
    };
    tryWrap();
    const obs = new MutationObserver(tryWrap);
    obs.observe(document.documentElement, { childList:true, subtree:true });
  })();

  // fallback: observar atributo open do dialog
  const dlgEtapas = document.getElementById('modalEtapas');
  if (dlgEtapas){
    const mo = new MutationObserver(restrictEtapasModalUI);
    mo.observe(dlgEtapas, { attributes:true, attributeFilter:['open'] });
  }

  // re-aplica se trocar usuário/sessão em localStorage
  window.addEventListener('storage', (e)=>{
    if (e.key === 'wv_session') setTimeout(()=>{ applyPermissions(); restrictEtapasModalUI(); }, 0);
  });

})();
</script>

<//!PREMISSÕES SEPARADOS POR CARGOS - FIM ---->

<!-- AJUSTES — Ver Lojas + Duplicar selecionados + Normalizador de OT (OT-x) -->
<script>
(function(){
  "use strict";

  /* =========================================================
   * 1) COLUNA "FILIAL(S)" => BOTÃO "VER LOJAS" (+ modal)
   * ========================================================= */
  function makeVerLojasButton(full){
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'btn small btnVerLojas';
    b.textContent = 'Ver lojas';
    b.setAttribute('data-full', (full||'').trim());
    b.title = 'Clique para ver todas as filiais';
    return b;
  }
  function decorateFiliaisTD(td){
    if (!td) return;
    if (td.querySelector('.btnVerLojas')) return;
    let full = '';
    const clip = td.querySelector('.clip[data-full]');
    if (clip) full = clip.getAttribute('data-full') || '';
    else full = (td.textContent || '').trim();
    if (!full || full === '—') return;
    td.textContent = '';
    td.appendChild(makeVerLojasButton(full));
  }
  function decorateAllFiliaisMain(){
    const tbody = document.getElementById('jobsBody');
    if (!tbody) return;
    tbody.querySelectorAll('tr[data-ot]').forEach(tr=>{
      const td = tr.children && tr.children[7];
      if (td) decorateFiliaisTD(td);
    });
  }
  (function observeMainFiliais(){
    const tbody = document.getElementById('jobsBody');
    if (!tbody) return;
    const mo = new MutationObserver(muts=>{
      muts.forEach(m=>{
        m.addedNodes.forEach(n=>{
          if (n.nodeType===1 && n.matches('tr[data-ot]')) {
            const td = n.children && n.children[7];
            if (td) decorateFiliaisTD(td);
          }
        });
      });
    });
    mo.observe(tbody, { childList:true });
    decorateAllFiliaisMain();
  })();
  function decorateAllFiliaisFinalizados(){
    const tbody = document.getElementById('finzList');
    if (!tbody) return;
    tbody.querySelectorAll('tr').forEach(tr=>{
      const td = tr.children && tr.children[7];
      if (!td) return;
      const clip = td.querySelector('.clip[data-full]');
      if (clip) {
        const full = clip.getAttribute('data-full')||'';
        td.textContent = '';
        td.appendChild(makeVerLojasButton(full));
      } else {
        decorateFiliaisTD(td);
      }
    });
  }
  (function hookFinalizadosOpen(){
    const btn = document.getElementById('btnVerFinalizados');
    const dlg = document.getElementById('modalFinalizados');
    if (!btn || !dlg) return;
    btn.addEventListener('click', ()=>{
      setTimeout(decorateAllFiliaisFinalizados, 120);
    });
  })();
  document.addEventListener('click', (e)=>{
    const b = e.target.closest('.btnVerLojas');
    if (!b) return;
    const full = b.getAttribute('data-full') || '';
    const dlg  = document.getElementById('modalCell');
    const ttl  = document.getElementById('cellTitle');
    const body = document.getElementById('cellBody');
    if (!dlg || !ttl || !body) return;
    const items = full.split(',').map(s=>s.trim()).filter(Boolean);
    ttl.textContent = 'Filial(s)';
    body.style.whiteSpace = 'pre-wrap';
    body.textContent = items.length ? items.join('\n') : (full || '—');
    dlg.showModal();
  });


  /* =====================================================================
   * 2) “DUPLICAR SELECIONADOS” (Finalizados) + chooser de AÇÃO NACIONAL
   * ===================================================================== */
  function getExistingAcoes(){
    const body = document.getElementById('jobsBody');
    const set = new Set();
    if (body) {
      body.querySelectorAll('tr.sub-row[data-sub]').forEach(tr=>{
        const nm = tr.getAttribute('data-sub')||'';
        const name = nm.trim();
        if (name) set.add(name);
      });
    }
    if (!set.size && window.JOBS instanceof Map) {
      for (const [,j] of window.JOBS.entries()){
        if (String(j.isNacional).toLowerCase()==='true' && j.acaoNome) {
          set.add(String(j.acaoNome).trim());
        }
      }
    }
    return Array.from(set).sort((a,b)=> a.localeCompare(b,'pt-BR'));
  }
  function setDupAcaoUIEnabled(enabled){
    const btn = document.getElementById('btnDupEscolherAcao');
    const inp = document.getElementById('dupAcaoNome');
    if (btn) btn.disabled = !enabled;
    if (inp) { inp.readOnly = true; if (!enabled) inp.value = ''; }
  }
  function wireDupAcaoToggles(){
    const rSim = document.getElementById('dupAcaoSim');
    const rNao = document.getElementById('dupAcaoNao');
    const onChange = ()=> setDupAcaoUIEnabled(!!(rSim && rSim.checked));
    if (rSim) rSim.addEventListener('change', onChange);
    if (rNao) rNao.addEventListener('change', onChange);
    onChange();
  }
  function openAcaoChooser(targetInputId){
    const dlg = document.getElementById('modalAcao');
    const box = document.getElementById('acaoLista');
    const inp = document.getElementById('acaoNova');
    const btnOk = document.getElementById('acaoOk');
    const btnCancel = document.getElementById('acaoCancelar');
    if (!dlg || !box || !btnOk) return;

    const actions = getExistingAcoes();
    let sel = null;
    box.innerHTML = actions.length
      ? actions.map(a=>`<div class="acaoItem" data-name="${a.replace(/"/g,'&quot;')}"
           style="padding:6px 8px;border-bottom:1px dashed rgba(255,255,255,.12);cursor:pointer">${a}</div>`).join('')
      : '<div class="muted">Nenhuma ação existente encontrada.</div>';

    box.querySelectorAll('.acaoItem').forEach(div=>{
      div.addEventListener('click', ()=>{
        box.querySelectorAll('.acaoItem').forEach(d=> d.style.background='transparent');
        div.style.background = 'rgba(255,255,255,.06)';
        sel = div.getAttribute('data-name') || '';
        if (inp) inp.value = '';
      });
    });
    if (inp) inp.value = '';

    function close(){
      try { btnOk.removeEventListener('click', onOk); } catch {}
      try { btnCancel && btnCancel.removeEventListener('click', onCancel); } catch {}
      dlg.close();
    }
    function onCancel(){ close(); }
    function onOk(){
      const target = document.getElementById(targetInputId);
      const viaNew = inp ? (inp.value||'').trim() : '';
      const chosen = viaNew || (sel||'');
      if (!chosen){
        const t=document.getElementById('toast'); if(t){ t.textContent='Selecione ou crie uma Ação.'; t.style.display='block'; setTimeout(()=>t.style.display='none',1500); }
        return;
      }
      if (target) target.value = chosen;
      window.WV = window.WV || {};
      window.WV._dupActionName = chosen;
      close();
    }

    btnOk.addEventListener('click', onOk);
    btnCancel && btnCancel.addEventListener('click', onCancel);
    dlg.showModal();
  }
  (function wireDupAcaoChooser(){
    const btn = document.getElementById('btnDupEscolherAcao');
    if (!btn) return;
    btn.addEventListener('click', ()=>{
      const rSim = document.getElementById('dupAcaoSim');
      if (!rSim || !rSim.checked) return;
      openAcaoChooser('dupAcaoNome');
    });
  })();
  (function hookFinalizadosDuplicate(){
    const btnDupSel = document.getElementById('finzDuplicar');
    const dlgDup2   = document.getElementById('modalDup2');
    const resumen   = document.getElementById('dupResumo');
    const list      = document.getElementById('finzList');
    if (!btnDupSel || !dlgDup2 || !list) return;

    btnDupSel.addEventListener('click', ()=>{
      const sel = [...list.querySelectorAll('input[type="checkbox"][data-ot]:checked')].map(b=> b.getAttribute('data-ot'));
      if (!sel.length){
        const t=document.getElementById('toast'); if(t){ t.textContent='Selecione pelo menos 1 job para duplicar.'; t.style.display='block'; setTimeout(()=>t.style.display='none',1500); }
        return;
      }
      window.WV = window.WV || {};
      window.WV._dupContext = { from:'finalizados', ots: sel };

      const rNao = document.getElementById('dupAcaoNao');
      const rSim = document.getElementById('dupAcaoSim');
      const inpAcao = document.getElementById('dupAcaoNome');
      if (rNao) rNao.checked = true;
      if (rSim) rSim.checked = false;
      if (inpAcao) inpAcao.value = '';
      setDupAcaoUIEnabled(false);
      wireDupAcaoToggles();

      if (resumen) {
        resumen.classList.add('muted');
        resumen.textContent = `${sel.length} job(s) selecionado(s) para duplicar a partir dos Finalizados. Defina os parâmetros e clique em “Lançar”.`;
      }
      dlgDup2.showModal();
    });

    // ao clicar em "Lançar" dentro do modalDup2, iniciamos a normalização de OT
    const btnLaunch = document.getElementById('dup2Lancar');
    if (btnLaunch && !btnLaunch._wvPatched){
      btnLaunch.addEventListener('click', ()=>{
        const rSim = document.getElementById('dupAcaoSim');
        const inp  = document.getElementById('dupAcaoNome');
        window.WV = window.WV || {};
        window.WV._dupActionName = (rSim && rSim.checked && inp) ? (inp.value||'').trim() : '';
        ensureNormalizeLoop(); // <<< dispara o normalizador OT-x
      });
      btnLaunch._wvPatched = true;
    }
  })();


  /* =========================================================
   * 3) NORMALIZADOR — converte TUDO para “OT-x” (sem zeros)
   *    - roda várias vezes após clicar em “Lançar” (duplica)
   *    - corrige jobs.csv e jobs_encerrados.csv
   * ========================================================= */
  const GHCFG = { owner:'JPVectorsitem', repo:'LINKS-img', branch:'main', jobs:'jobs.csv', encerr:'jobs_encerrados.csv' };

  function getToken(){
    try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }
    catch{ return (window.gh&&window.gh.token)||''; }
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const a=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) a[i]=bin.charCodeAt(i); return new TextDecoder().decode(a); }
  function utf8ToB64(str){ const a=new TextEncoder().encode(str); let bin=''; for(let i=0;i<a.length;i++) bin+=String.fromCharCode(a[i]); return btoa(bin); }
  async function ghGetFile(path){
    const tok=getToken(); if(!tok) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GHCFG.owner)}/${encodeURIComponent(GHCFG.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(GHCFG.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(tok)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); return { text: j.content? b64ToUtf8(j.content):'', sha:j.sha||null };
  }
  async function ghPutFile(path, text, message){
    const tok=getToken(); if(!tok) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GHCFG.owner)}/${encodeURIComponent(GHCFG.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(text), branch:GHCFG.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(tok),'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
  }

  function parseCsv(t){
    if(!t) return []; const out=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"'; i++;} else q=false; } else cur+=c; }
      else { if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
             else if(c=='\r'){} else if(c=='\n'){row.push(cur); out.push(row); row=[]; cur='';}
             else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); out.push(row); }
    return out;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return {header:[],rows:[]};
    const H=rows[0]; const R=[];
    for(let i=1;i<rows.length;i++){ const rr=rows[i]; if(!rr || (rr.length===1&&rr[0]==='')) continue; const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; R.push(o); }
    return {header:H,rows:R};
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }

  const parseOTNum = ot => { const m=String(ot||'').match(/ot[-\s]*0*(\d+)$/i); return m? parseInt(m[1],10): null; };
  const normOT     = ot => { const n=parseOTNum(ot); return n? `OT-${n}`: String(ot||''); };
  const isBadOT    = ot => !/^OT-\d+$/.test(String(ot||'')); // inclui zeros à esquerda

  async function normalizeFile(path){
    const { text } = await ghGetFile(path);
    if(!text) return false;
    const { header:H, rows } = csvToObjsAndHeader(text);
    if(!H.length || !rows.length) return false;

    let changed=false;
    for(const r of rows){
      const cur=r.ot;
      const norm = normOT(cur);
      if(cur!==norm || isBadOT(cur)){ r.ot = norm; changed=true; }
    }
    if(!changed) return false;

    const next = toCsv(H, rows);
    await ghPutFile(path, next, `chore(csv): normalize OT -> OT-x (no zeros)`);
    return true;
  }

  // roda algumas vezes em loop (para pegar o commit do duplicar que pode demorar um pouco)
  let NORMALIZER_RUNNING = false;
  function ensureNormalizeLoop(){
    if(NORMALIZER_RUNNING) return;
    NORMALIZER_RUNNING = true;

    const attemptsMax = 12; // ~24s total
    let n = 0;

    const run = async () => {
      try {
        // normaliza ambos os arquivos
        const a = await normalizeFile(GHCFG.jobs);
        const b = await normalizeFile(GHCFG.encerr);
        // se já não há mais OTs ruins, podemos encerrar antes
        const { text } = await ghGetFile(GHCFG.jobs);
        const { rows } = csvToObjsAndHeader(text);
        const stillBad = rows.some(r => isBadOT(r.ot));
        if(!stillBad){ NORMALIZER_RUNNING=false; return; }
      } catch(e) {
        // silencioso, vamos tentar novamente
        console.warn('OT normalizer pass failed:', e);
      }
      n++;
      if(n < attemptsMax){
        setTimeout(run, 2000);
      } else {
        NORMALIZER_RUNNING=false;
      }
    };
    run();
  }

  /* também engata no botão do “Duplicar” comum, se existir */
  (function hookDuplicarComum(){
    const b = document.getElementById('btnDupLancar')
          || document.getElementById('btnDuplicarLancar')
          || document.getElementById('btnDuplicarSalvar');
    if(!b || b._otHooked) return;
    b.addEventListener('click', ensureNormalizeLoop);
    b._otHooked = true;
  })();

})();
</script>
<!-- /AJUSTES DUPLICAR COM OT sem zeros FIM-->



<!// AJUTES - OT GLOBAL (Lançados e Finalizados) ---->

<script>
(function(){
  "use strict";

  /* ===========================
   *  CONFIG DO FORMATO DA OT
   * =========================== */
  const OT_FMT = { prefix: 'OT-', pad: 5 }; // resultado: OT-00001, OT-00002, ...

  /* ===========================
   *  CONFIG GITHUB
   *  (ajuste se seu owner/repo/branch forem outros)
   * =========================== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    jobsPath: 'jobs.csv',
    encPath:  'jobs_encerrados.csv',
    counterPath: 'ot_counter.txt'
  };

  /* ===========================
   *  HELPERS GERAIS
   * =========================== */
  const sleep = (ms)=> new Promise(r=> setTimeout(r, ms));

  function getToken(){
    try{
      const saved = JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}');
      return (window.gh && window.gh.token) || saved.token || '';
    }catch{
      return (window.gh && window.gh.token) || '';
    }
  }
  function ghHeaders(token, extra={}){
    return {
      'Accept':'application/vnd.github+json',
      'X-GitHub-Api-Version':'2022-11-28',
      ...(token ? {'Authorization':`Bearer ${token}`} : {}),
      ...extra
    };
  }
  function b64ToUtf8(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
  function utf8ToB64(str){
    const bytes = new TextEncoder().encode(str);
    let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  function formatOT(n){
    const s = String(n).padStart(OT_FMT.pad, '0');
    return `${OT_FMT.prefix}${s}`;
  }
  function numFromOT(ot){
    // extrai só os dígitos (ex.: "OT-00012" => 12)
    const m = String(ot||'').match(/(\d+)/);
    return m ? parseInt(m[1],10) : NaN;
  }

  // CSV simples (rápido)
  function parseCsv(text){
    if (!text) return [];
    const out=[]; let row=[], cur='', q=false;
    for(let i=0;i<text.length;i++){
      const c=text[i];
      if(q){
        if(c=='"'){ if(text[i+1]=='"'){cur+='"'; i++;} else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){ /* ignore */ }
        else if(c=='\n'){ row.push(cur); out.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0 || row.length>0){ row.push(cur); out.push(row); }
    return out;
  }
  function csvToObjs(text){
    const rows = parseCsv(text);
    if (!rows.length) return { head:[], rows:[] };
    const head = rows[0];
    const list=[];
    for(let i=1;i<rows.length;i++){
      const r=rows[i]; if(!r || (r.length===1 && r[0]==='')) continue;
      const o={}; for(let j=0;j<head.length;j++) o[head[j]] = r[j] ?? '';
      list.push(o);
    }
    return { head, rows:list };
  }
  const csvEsc = v => {
    v = v==null ? '' : String(v);
    return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
  };
  function objsToCsv(head, rows){
    const H = head.slice();
    const body = rows.map(o => H.map(h => csvEsc(o[h] ?? '')).join(',')).join('\n');
    return H.join(',') + '\n' + (body ? (body+'\n') : '');
  }

  /* ======================================================
   *  FETCH ORIGINAL & GUARDA-CHUVA PRA EVITAR RECURSÃO
   * ====================================================== */
  const _origFetch = window.fetch.bind(window);
  let _otHookInFlight = false; // evita loop quando usamos fetch internamente

  async function ghGetContent(path, headers, branch){
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r = await _origFetch(url, { headers });
    if (r.status === 404) return { text:'', sha:null };
    if (!r.ok) throw new Error('GET '+path+' '+r.status);
    const j = await r.json();
    const text = j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha: j.sha || null };
  }
  async function ghPutContent(path, newText, message, headers, branch, sha){
    const url = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: message || `chore: update ${path}`,
      content: utf8ToB64(newText),
      branch: branch || GH.branch,
      ...(sha ? { sha } : {})
    };
    const r = await _origFetch(url, {
      method:'PUT',
      headers: { ...headers, 'Content-Type':'application/json' },
      body: JSON.stringify(body)
    });
    if (!r.ok) {
      const t = await r.text();
      throw new Error('PUT '+path+' '+r.status+': '+t);
    }
    const et = r.headers.get('ETag') || null;
    let newSha=null; try{ const jj=await r.clone().json(); newSha = jj?.content?.sha || null; }catch{}
    return { sha: newSha, etag: et };
  }

  /* ======================================================
   *  COUNTER GLOBAL DE OT (ot_counter.txt)
   *  - Se não existir, cria com base no maior OT dos CSVs
   * ====================================================== */
  async function ensureCounter(headers){
    // tenta ler
    try{
      const { text, sha } = await ghGetContent(GH.counterPath, headers, GH.branch);
      const n = parseInt((text||'').trim(), 10);
      if (!isNaN(n)) return { value:n, sha };
    }catch{ /* continua */ }

    // não existe ou inválido -> calcular pelo maior OT nos dois CSVs
    let maxN = 0;
    try{
      const { text: jobsT } = await ghGetContent(GH.jobsPath, headers, GH.branch);
      const { text: encT  } = await ghGetContent(GH.encPath,  headers, GH.branch);
      const both = [jobsT, encT].filter(Boolean);
      for (const t of both){
        const { rows, head } = csvToObjs(t);
        const colOT = (head||[]).includes('ot') ? 'ot' : null;
        if (!colOT) continue;
        for (const r of rows){
          const n = numFromOT(r.ot);
          if (!isNaN(n) && n > maxN) maxN = n;
        }
      }
    }catch{/* ignore */}

    const initVal = maxN; // valor atual no arquivo; o próximo emitido será +1
    const put = await ghPutContent(GH.counterPath, String(initVal), 'chore(ot): init counter', headers, GH.branch, null);
    return { value: initVal, sha: put.sha || null };
  }

  async function reserveOTs(qty, headers, retries=3){
    if (qty <= 0) return [];
    let attempt = 0;
    while (attempt <= retries){
      attempt++;
      try{
        const { text, sha } = await ghGetContent(GH.counterPath, headers, GH.branch);
        const cur = parseInt((text||'').trim(),10);
        if (isNaN(cur)) throw new Error('counter invalid');
        const start = cur + 1;
        const end   = cur + qty;
        // grava novo valor (end) atomizando
        await ghPutContent(GH.counterPath, String(end), `chore(ot): reserve ${qty}`, headers, GH.branch, sha);
        // retorna formatado
        const arr=[]; for (let n=start;n<=end;n++) arr.push(formatOT(n));
        return arr;
      }catch(e){
        // Se 404, cria
        if (String(e).includes('404') || String(e).includes('counter invalid')){
          await ensureCounter(headers);
          continue; // tenta de novo
        }
        // conflito (409) ou intermitência -> espera e tenta
        await sleep(250 + Math.random()*400);
      }
    }
    throw new Error('Falha ao reservar OTs (concorrência).');
  }

  /* ======================================================
   *  AJUSTE DO PUT DE jobs.csv:
   *   - Intercepta PUT do GitHub API p/ jobs.csv
   *   - Garante OTs únicas (gera para novas/duplicadas)
   * ====================================================== */
  function urlIsJobsPut(url, method){
    if (String(method||'').toUpperCase() !== 'PUT') return false;
    return /\/repos\/[^/]+\/[^/]+\/contents\/jobs\.csv(\?|$)/.test(String(url));
  }

  function decodePutBody(init){
    const b = init && init.body;
    if (!b) return null;
    try{
      const obj = (typeof b === 'string') ? JSON.parse(b) : (b instanceof Blob ? null : b);
      if (!obj || !obj.content) return null;
      return obj;
    }catch{ return null; }
  }

  function cloneInitWithBody(init, bodyObj){
    const newInit = { ...(init||{}) };
    newInit.body = JSON.stringify(bodyObj);
    return newInit;
  }

  function countBy(arr, getKey){
    const m = new Map();
    arr.forEach((x,i)=>{
      const k = getKey(x,i);
      m.set(k, (m.get(k)||0)+1);
    });
    return m;
  }

  async function fixJobsCsvBeforePut(url, init){
    // headers do put original
    const token = getToken();
    const headers = ghHeaders(token, { 'Content-Type':'application/json' });

    // 1) conteúdo novo pretendido
    const putBody = decodePutBody(init);
    if (!putBody) return init; // sem body json? deixa seguir
    const newTextRaw = b64ToUtf8(putBody.content||'');
    const { head: newHead, rows: newRows } = csvToObjs(newTextRaw);
    if (!newHead.length || !newRows.length) return init;

    // 2) carrega CSV atual (antes do PUT) e finalizados
    const [{ text: curJobs }, { text: curEnc }] = await Promise.all([
      ghGetContent(GH.jobsPath, headers, GH.branch).catch(()=>({text:''})),
      ghGetContent(GH.encPath,  headers, GH.branch).catch(()=>({text:''}))
    ]);
    const { rows: oldRows } = csvToObjs(curJobs);
    const { rows: encRows } = csvToObjs(curEnc);

    const oldOTs = new Set(oldRows.map(r => String(r.ot||'')).filter(Boolean));
    const encOTs = new Set(encRows.map(r => String(r.ot||'')).filter(Boolean));
    const usedGlobal = new Set([...oldOTs, ...encOTs].filter(Boolean));

    // 3) detectar linhas candidatas a receber OT nova
    //    - sem OT
    //    - duplicadas de OT *dentro do próprio novo arquivo* (segunda ocorrência em diante)
    //    - com OT ainda não existente no jobs atual, mas que colide com enc (raro) => emitir nova
    const counts = countBy(newRows, r => String(r.ot||''));
    const needAssignIdx = []; // índices em newRows que precisam de OT
    const seen = new Set();   // para identificar "segunda ocorrência"

    for (let i=0;i<newRows.length;i++){
      const r = newRows[i];
      const ot = String(r.ot||'').trim();

      if (!ot){ needAssignIdx.push(i); continue; }

      // duplicado dentro do próprio arquivo novo?
      const key = ot + '|' + (counts.get(ot)||0);
      if (counts.get(ot) > 1){
        // marca todas menos a 1ª ocorrência
        if (seen.has(ot)) { needAssignIdx.push(i); continue; }
        seen.add(ot);
      }

      // se ot não existia no jobs atual, mas existe em finalizados -> trocamos
      if (!oldOTs.has(ot) && encOTs.has(ot)){
        needAssignIdx.push(i); continue;
      }
      // Se já existia no jobs atual, assumimos ser edição -> mantém OT
    }

    if (!needAssignIdx.length){
      // Nada a fazer; retorna init original
      return init;
    }

    // 4) reservar OTs e aplicar
    // garante counter
    await ensureCounter(headers);
    const freshOTs = await reserveOTs(needAssignIdx.length, headers);
    needAssignIdx.forEach((idx, j)=> {
      newRows[idx].ot = freshOTs[j];
    });

    // 5) reconstroi novo csv e reempacota body
    const fixedText = objsToCsv(newHead, newRows);
    const bodyObj = { ...putBody, content: utf8ToB64(fixedText) };
    return cloneInitWithBody(init, bodyObj);
  }

  // ============ PATCH GLOBAL DO FETCH ============
  window.fetch = async function(input, init){
    try{
      if (_otHookInFlight) {
        return _origFetch(input, init); // chamadas internas do patch
      }

      const url = (typeof input === 'string') ? input : (input && input.url) || '';
      const method = init && init.method;

      // intercepta somente PUT de jobs.csv
      if (urlIsJobsPut(url, method)) {
        _otHookInFlight = true;
        try{
          const nextInit = await fixJobsCsvBeforePut(url, init);
          return await _origFetch(input, nextInit);
        } finally {
          _otHookInFlight = false;
        }
      }

      return await _origFetch(input, init);
    }catch(e){
      // fallback em caso de erro no patch
      try{ return await _origFetch(input, init); } catch { throw e; }
    }
  };

  /* ======================================================
   *  API opcional (se quiser usar direto nos seus handlers)
   *   window.getNextOT(): Promise<string>
   *   window.reserveOTs(n): Promise<string[]>
   * ====================================================== */
  window.getNextOT = async function(){
    const token = getToken();
    const headers = ghHeaders(token);
    await ensureCounter(headers);
    const arr = await reserveOTs(1, headers);
    return arr[0];
  };
  window.reserveOTs = async function(n){
    const token = getToken();
    const headers = ghHeaders(token);
    await ensureCounter(headers);
    return reserveOTs(n, headers);
  };

  // Aviso no console
  console.log('[WV OT] Hook de OT global ativo: OTs únicas entre jobs.csv e jobs_encerrados.csv');

})();
</script>

<!// AJUTES - OT GLOBAL (Lançados e Finalizados) FIM ---->


<!-- ============================ GATE (PORTA DE ACESSO) — MODAL SÓLIDO v2 ============================ -->
<style>
  body.gate-locked { overflow: hidden; }
  body.gate-locked #loginView,
  body.gate-locked #jobsApp { display: none !important; }

  dialog#gateModal { border:none; padding:0; width:min(900px,96vw); max-width:900px; background:transparent; }
  dialog#gateModal::backdrop { background:rgba(0,0,0,.85); }

  #gateWrap{ background:#0e1730; color:#eaf0ff; border:1px solid rgba(255,255,255,.12);
    border-radius:16px; box-shadow:0 18px 60px rgba(0,0,0,.65); overflow:hidden; }
  #gateHdr{ padding:18px 22px; border-bottom:1px solid rgba(255,255,255,.08) }
  #gateHdr h1{ margin:0; font-size:1.25rem }
  #gateHdr .muted{ margin:6px 0 0; color:#9fb0d0; font-size:.95rem }
  #gateBody{ padding:20px 22px 8px }
  #gateGrid{ display:grid; grid-template-columns:repeat(12,1fr); gap:12px }
  .col-12{ grid-column:span 12 } .col-8{ grid-column:span 8 } .col-6{ grid-column:span 6 } .col-4{ grid-column:span 4 }
  .field{ display:grid; gap:6px } .field label{ font-weight:600; font-size:.95rem }
  .muted{ color:#9fb0d0 }
  #gateBody input, #gateBody button{ font-family:inherit; font-size:.95rem }
  #gateBody input{ width:100%; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.16);
    background:#0b1426; color:#eaf0ff; outline:none; transition:.2s border-color,.2s box-shadow }
  #gateBody input:focus{ border-color:#2a60ff; box-shadow:0 0 0 3px rgba(42,96,255,.15) }
  .btn{ appearance:none; border:1px solid rgba(255,255,255,.16); background:#0d1628; color:#eaf0ff; padding:10px 14px;
    border-radius:10px; cursor:pointer; font-weight:700; transition:.2s transform,.2s background,.2s border-color,.2s box-shadow }
  .btn:hover{ transform:translateY(-1px); border-color:rgba(255,255,255,.28) }
  .btn.primary{ background:linear-gradient(180deg,#2a60ff,#1b47c9); border-color:transparent }
  .btn.small{ padding:6px 10px; font-size:.85rem }
  .chip{ display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); font-size:.8rem }
  .ok{ color:#86efac } .warn{ color:#facc15 } .err{ color:#f87171 }
  .captchaBox{ border:1px dashed rgba(255,255,255,.18); padding:10px; border-radius:10px }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
  .timer{ font-variant-numeric:tabular-nums; font-weight:700 }
  #gateFoot{ padding:16px 22px 18px; display:flex; justify-content:flex-end; gap:10px; border-top:1px solid rgba(255,255,255,.08) }
  /* por padrão, o botão de gerar fica oculto; JS mostra só quando expira */
  #gateGen{ display:none; }
</style>

<dialog id="gateModal">
  <div id="gateWrap" role="dialog" aria-modal="true" aria-labelledby="gateTitle">
    <div id="gateHdr">
      <h1 id="gateTitle">Workflow Vector — Porta de Acesso</h1>
      <p class="muted">Ferramenta de uso interno. Preencha os passos para liberar o acesso.</p>
    </div>

    <div id="gateBody">
      <div id="gateGrid">
        <!-- 1) TOKEN -->
        <div class="col-12"><h2 style="margin:0 0 6px 0">1) Token de acesso</h2></div>
        <div class="col-8">
          <div class="field">
            <label for="gateTok">Insira o token</label>
            <input id="gateTok" type="password" placeholder="ghp_xxx..." autocomplete="off">
            <div class="muted">Ao salvar, uma senha global de 10 min será gerada automaticamente.</div>
          </div>
        </div>
        <div class="col-4" style="display:flex;align-items:end">
          <button id="gateSaveTok" class="btn">Salvar token</button>
        </div>

        <div class="col-12"><hr style="border-color:rgba(255,255,255,.12)"></div>

        <!-- 2) SENHA GLOBAL (10 min) -->
        <div class="col-12"><h2 style="margin:0 0 6px 0">2) Senha de liberação</h2></div>
        <div class="col-6">
          <div class="field">
            <label for="gatePassInput">Senha vigente</label>
            <input id="gatePassInput" type="password" placeholder="Digite a senha" autocomplete="off">
            <div class="muted">Tempo restante: <span id="gateTimer" class="timer">--:--</span></div>
          </div>
        </div>
        <div class="col-6">
          <div class="row" style="margin-top:26px">
            <button id="gateGen" class="btn small" type="button">Atualizar/Gerar senha</button>
            <span id="gatePassState" class="chip">Aguardando…</span>
          </div>
        </div>

        <!-- 3) CAPTCHA -->
        <div class="col-12"><h2 style="margin:4px 0 6px 0">3) Não sou um robô</h2></div>
        <div class="col-12">
          <div class="captchaBox">
            <div class="row">
              <label class="row" style="gap:8px"><input id="gateChk" type="checkbox"> Não sou um robô</label>
              <span id="gateCaptchaState" class="chip">Desativado</span>
            </div>
            <div id="gateQA" class="row" style="margin-top:10px;display:none;align-items:flex-end">
              <div style="flex:1 1 480px">
                <div class="field">
                  <label for="gateQ">Pergunta</label>
                  <input id="gateQ" type="text" readonly>
                </div>
              </div>
              <div style="flex:1 1 260px">
                <div class="field">
                  <label for="gateA">Resposta</label>
                  <input id="gateA" type="text" placeholder="Digite a resposta">
                </div>
              </div>
              <button id="gateNewQ" class="btn small" type="button">Trocar pergunta</button>
            </div>
            <div class="muted" style="margin-top:6px">Responda corretamente para liberar o acesso.</div>
          </div>
        </div>
      </div>
    </div>

    <div id="gateFoot">
      <button id="gateAccess" class="btn primary">Acessar</button>
    </div>
  </div>
</dialog>

<script>
(()=> {
  /* ===================== CONFIG REPO ===================== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    passPath: 'segurancaallow_ip.txt',  // WV_PASS/CREATED/EXPIRES
    qaPath:  'perguntas_respostas.csv'
  };

  /* ===================== ELEMENTOS ===================== */
  const dlg       = document.getElementById('gateModal');
  const wrap      = document.getElementById('gateWrap');
  const elTok     = document.getElementById('gateTok');
  const btSaveTok = document.getElementById('gateSaveTok');
  const elPassInp = document.getElementById('gatePassInput');
  const elTimer   = document.getElementById('gateTimer');
  const elPassSt  = document.getElementById('gatePassState');
  const btGen     = document.getElementById('gateGen');
  const chkBot    = document.getElementById('gateChk');
  const capState  = document.getElementById('gateCaptchaState');
  const qaWrap    = document.getElementById('gateQA');
  const elQ       = document.getElementById('gateQ');
  const elA       = document.getElementById('gateA');
  const btNewQ    = document.getElementById('gateNewQ');
  const btAccess  = document.getElementById('gateAccess');

  const loginView = document.getElementById('loginView');
  const jobsApp   = document.getElementById('jobsApp');

  /* ===================== STATE ===================== */
  let PASS_VALUE = '';
  let PASS_EXP   = null; // ISO
  let tickTimer  = null;
  let QA = [];
  let curIdx = -1;

  /* ===================== UTILS ===================== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ console.log('[GATE]',m); return; }
    t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }
  function setToken(tok){ window.gh=window.gh||{}; window.gh.token=tok; try{ localStorage.setItem('wv_gh_cfg', JSON.stringify({token:tok})); }catch{} }
  function fmtMMSS(ms){ const s=Math.max(0,Math.floor(ms/1000)); const m=Math.floor(s/60); const r=s%60; return String(m).padStart(2,'0')+':'+String(r).padStart(2,'0'); }
  function msLeft(expISO){ const t=Date.parse(expISO); if(isNaN(t)) return 0; return Math.max(0,t-Date.now()); }

  /* ===================== PARSERS ===================== */
  function parseCsv(text){ if(!text) return []; const out=[]; let row=[],cur='',q=false;
    for(let i=0;i<text.length;i++){ const c=text[i];
      if(q){ if(c=='"'){ if(text[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else{ if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
        else if(c=='\r'){} else if(c=='\n'){row.push(cur);out.push(row);row=[];cur='';} else cur+=c; } }
    if(cur.length>0||row.length>0){ row.push(cur); out.push(row); } return out; }
  function csvToQAs(csv){ const rows=parseCsv(csv); if(!rows.length) return []; const H=rows[0].map(h=>String(h||'').trim().toLowerCase());
    const iQ=H.indexOf('perguntas'), iA=H.indexOf('respostas'); if(iQ<0||iA<0) return []; const arr=[];
    for(let i=1;i<rows.length;i++){ const r=rows[i]; if(!r||(!r[iQ]&&!r[iA])) continue; arr.push({q:r[iQ]||'', a:r[iA]||''}); } return arr; }
  function parseTxt(txt){ const out={pass:'',exp:null,created:null};
    String(txt||'').split(/\r?\n/).forEach(line=>{ const s=line.trim(); if(!s) return; const idx=s.indexOf(':'); if(idx<0) return;
      const k=s.slice(0,idx).trim().toUpperCase(); const v=s.slice(idx+1).trim();
      if(k==='WV_PASS') out.pass=v; else if(k==='EXPIRES') out.exp=v; else if(k==='CREATED') out.created=v; });
    return out; }

  /* ===================== GITHUB HELPERS ===================== */
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){ const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)}); if(r.status===404) return {text:'',sha:null}; if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j&&j.content ? b64ToUtf8(j.content) : ''; return {text, sha:j.sha||null}; }
  async function ghPutFile(path,newText,message){ const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path,GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={message:message||`chore(gate): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{})};
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token),'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); } return true; }

  /* ===================== UI STATE HELPERS ===================== */
  function showGen(show){ btGen.style.display = show ? 'inline-block' : 'none'; }
  function updateGenVisibility(){
    const left = msLeft(PASS_EXP);
    if(!PASS_VALUE || left<=0){ setPassState('Expirada ou ausente','err'); showGen(true); elTimer.textContent='00:00'; }
    else { setPassState('Ativa','ok'); showGen(false); }
  }
  function setPassState(txt, cls){ elPassSt.textContent=txt; elPassSt.className='chip '+(cls||''); }
  function setCaptchaState(txt, cls){ capState.textContent=txt; capState.className='chip '+(cls||''); }

  /* ===================== TIMER ===================== */
  function startTimer(){
    stopTimer();
    const tick=()=>{
      const ms=msLeft(PASS_EXP);
      elTimer.textContent = fmtMMSS(ms);
      if(ms<=0){
        elTimer.textContent='00:00';
        setPassState('Expirada','err');
        showGen(true);
        stopTimer();
      }
    };
    tickTimer=setInterval(tick,1000);
    tick(); // já pinta
  }
  function stopTimer(){ if(tickTimer){ clearInterval(tickTimer); tickTimer=null; } }

  /* ===================== LOADERS ===================== */
  async function loadPass(){
    const { text } = await ghGetFile(GH.passPath, GH.branch);
    const meta = parseTxt(text);
    PASS_VALUE = meta.pass || '';
    PASS_EXP   = meta.exp  || null;
    updateGenVisibility();
    if(PASS_VALUE && msLeft(PASS_EXP)>0) startTimer(); else stopTimer();
  }
  async function loadQA(){
    const { text } = await ghGetFile(GH.qaPath, GH.branch);
    QA = csvToQAs(text);
    if(!QA.length){ setCaptchaState('Perguntas indisponíveis','err'); } else { setCaptchaState('Pronto para desafio','ok'); }
  }

  /* ===================== ROTATE PASS (+ iniciar contador) ===================== */
  async function rotatePassAndStart(){
    const alpha='ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let pass=''; for(let i=0;i<12;i++) pass+=alpha[Math.floor(Math.random()*alpha.length)];
    const now=new Date(); const exp=new Date(now.getTime()+10*60*1000);
    const txt=[`WV_PASS:${pass}`,`CREATED:${now.toISOString()}`,`EXPIRES:${exp.toISOString()}`].join('\n')+'\n';
    await ghPutFile(GH.passPath, txt, 'chore(gate): rotate WV_PASS (10min)');
    PASS_VALUE=pass; PASS_EXP=exp.toISOString();
    setPassState('Ativa','ok'); showGen(false); startTimer();
  }

  /* ===================== AÇÕES ===================== */
  async function saveToken(){
    const tok=(elTok.value||'').trim(); if(!tok){ toast('Informe o token.'); return; }
    setToken(tok);
    try{
      setBusy(true,'Carregando…');
      await loadQA();                 // carrega perguntas
      await rotatePassAndStart();     // já gera a senha e inicia timer
      setBusy(false);
      toast('Token salvo e senha gerada.');
    }catch(e){
      console.error(e); setBusy(false); toast('Erro ao salvar token/gerar senha.');
    }
  }
  async function genPass(){
    if(!getToken()){ toast('Salve o token primeiro.'); return; }
    try{
      setBusy(true,'Gerando senha…');
      await rotatePassAndStart();
      setBusy(false);
      toast('Senha gerada.');
    }catch(e){ console.error(e); setBusy(false); toast('Falha ao gerar senha.'); }
  }
  function pickQuestion(){ if(!QA.length){ elQ.value=''; elA.value=''; return; } const i=Math.floor(Math.random()*QA.length); elQ.value=QA[i].q||''; elA.value=''; }

  function isUnlocked(){ return localStorage.getItem('wv_gate_ok')==='1'; }
  function lockUnderlay(on){
    document.body.classList.toggle('gate-locked', !!on);
    if(loginView) loginView.inert = !!on;
    if(jobsApp)   jobsApp.inert   = !!on;
  }
  function ensureOpen(){ if(!isUnlocked()){ try{ if(!dlg.open && dlg.showModal) dlg.showModal(); }catch{} lockUnderlay(true); } }

  async function access(){
    // valida expiração
    if(msLeft(PASS_EXP)<=0){ setPassState('Expirada','err'); toast('Senha expirada. Gere novamente.'); return; }
    // token
    if(!getToken()){ toast('Salve o token primeiro.'); return; }
    // senha
    const typed=(elPassInp.value||'').trim();
    if(!typed){ toast('Digite a senha.'); return; }
    if(!PASS_VALUE){ toast('Senha indisponível. Gere/atualize.'); return; }
    // captcha
    if(!chkBot.checked){ toast('Marque "Não sou um robô".'); return; }
    if(!QA.length || !elQ.value){ toast('Carregando pergunta…'); return; }
    const qa = QA.find(q=> q.q===elQ.value) || {a:''};
    const okAns=(qa.a||'').trim().toLowerCase();
    const okPass=(typed===PASS_VALUE);
    const ans   =(elA.value||'').trim().toLowerCase();
    if(!okPass || ans!==okAns){ toast(!okPass ? 'Senha incorreta.' : 'Resposta incorreta.'); pickQuestion(); return; }

    localStorage.setItem('wv_gate_ok','1');
    try{ dlg.close(); }catch{}
    lockUnderlay(false);
    toast('Acesso liberado.');
  }

  /* ===================== BINDINGS ===================== */
  btSaveTok.addEventListener('click', saveToken);
  btGen.addEventListener('click', genPass);
  btAccess.addEventListener('click', access);
  btNewQ.addEventListener('click', pickQuestion);
  chkBot.addEventListener('change', ()=>{ if(chkBot.checked){ qaWrap.style.display='flex'; setCaptchaState('Desafio ativo','ok'); if(!QA.length) loadQA().then(pickQuestion); else pickQuestion(); }else{ qaWrap.style.display='none'; setCaptchaState('Desativado',''); } });
  document.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && dlg.open){ e.preventDefault(); access(); } });

  // Esconde botão "Configurar GitHub" do login (se existir)
  const cfgBtn=document.getElementById('btnConfigGH'); if(cfgBtn) cfgBtn.style.display='none';

  /* ===================== BOOT ===================== */
  (async function boot(){
    if(isUnlocked()){ lockUnderlay(false); try{ dlg.close(); }catch{} return; }
    ensureOpen();
    const tok=getToken(); if(tok) elTok.value=tok;
    if(tok){
      try{
        setBusy(true,'Preparando…');
        await Promise.all([loadQA(), loadPass()]);
        setBusy(false);
      }catch(e){
        console.error(e); setBusy(false);
        setPassState('Erro ao ler senha','err'); setCaptchaState('Erro ao carregar','err');
      }
    }else{
      setPassState('Informe o token primeiro','warn');
      elTimer.textContent='00:00';
      showGen(true); // deixar visível para quando token for salvo e usuário quiser gerar manualmente
    }
  })();
})();
</script>
<!-- ============================ /GATE — MODAL SÓLIDO v2 ============================ -->


<!-- ===== Ocultar "Config GitHub" no LOGIN ===== -->
<style>
  /* se souber algum id/classe específico, já esconde por CSS também */
  #loginView #btnConfigGH,
  #loginView #btnConfigGithub,
  #loginView #btnGithub,
  #loginView #btnConfig,
  #loginView .btn-config-gh,
  #loginView [data-role="cfg-gh"]{
    display:none !important;
  }
</style>
<script>
(function(){
  function hideGitCfgInLogin(){
    const login = document.getElementById('loginView');
    if(!login) return;

    // 1) Seletores comuns (ids/classes/atributos)
    const selectors = [
      '#btnConfigGH','#btnConfigGithub','#btnGithub','#btnConfig','#btnCFG',
      '.btn-config-gh','.btnCfgGh','.btn-gh-config',
      '[data-role="cfg-gh"]','button[data-action="configGithub"]',
      'button[aria-label*="GitHub" i]','button[title*="GitHub" i]'
    ];
    selectors.forEach(sel=>{
      login.querySelectorAll(sel).forEach(el=>{
        el.style.display='none';
        el.setAttribute('aria-hidden','true');
        el.tabIndex = -1;
        try{ el.disabled = true; }catch{}
      });
    });

    // 2) Fallback por texto (caso o botão não tenha id/classe previsível)
    const maybe = login.querySelectorAll('button, a, [role="button"]');
    maybe.forEach(el=>{
      const t = (el.textContent||'').toLowerCase().replace(/\s+/g,' ').trim();
      if(
        (t.includes('config') && (t.includes('github') || t.includes('git hub'))) ||
        t.includes('configurar github') ||
        t === '⚙'
      ){
        el.style.display='none';
        el.setAttribute('aria-hidden','true');
        el.tabIndex = -1;
        try{ el.disabled = true; }catch{}
      }
    });

    // 3) Se existir algum modal de config que apareça automaticamente no login, garante oculto
    const strayModals = login.querySelectorAll('[id*="config"][id*="gh" i], [class*="config"][class*="gh" i]');
    strayModals.forEach(m=>{
      m.style.display='none';
      m.setAttribute('aria-hidden','true');
    });
  }

  // roda já e também após pequenas mudanças na DOM do login
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', hideGitCfgInLogin);
  }else{
    hideGitCfgInLogin();
  }

  // observa mutações no #loginView (ex.: frameworks que montam depois)
  const login = document.getElementById('loginView');
  if(login && 'MutationObserver' in window){
    const mo = new MutationObserver(()=> hideGitCfgInLogin());
    mo.observe(login, { childList:true, subtree:true });
  }
})();
</script>
<!-- ===== /Ocultar "Config GitHub" no LOGIN ===== -->


<!// Tamanho fonte linha>

<style>
  /* Tamanho do texto das linhas de jobs lançados */
  #jobsBody tr[data-ot] td {
    font-size: 7pt;          /* “tamanho 7” */
    line-height: 1.2;
  }

  /* Mantém botões legíveis, se existirem dentro das células */
  #jobsBody tr[data-ot] td button,
  #jobsBody tr[data-ot] td .btn {
    font-size: 8.5pt;
  }
</style>
<!// Tamanho fonte linha FIM>

<!-- ======= AJUSTES FINAIS v2: ellipsis + neutraliza "Ver lojas" + compacta ======= -->
<style>
  /* Linhas compactas */
  #jobsBody tr[data-ot] td {
    padding: 3px 6px;
    font-size: 7pt;
    line-height: 1.15;
    vertical-align: middle;
  }

  /* Força largura fixa nas colunas desejadas (com table-layout: fixed) */
  #jobsBody td.col-nome    { width: 260px; max-width: 260px; }
  #jobsBody td.col-filiais { width: 320px; max-width: 320px; }

  /* Conteúdo com ellipsis */
  .cell-clip {
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .cell-clickable { cursor: zoom-in; }

  /* Botão "+" menor */
  #jobsBody tr[data-ot] td .btnPlusMini,
  #jobsBody tr[data-ot] td .btnStepPlus {
    width: 20px; height: 20px; min-width: 20px;
    font-size: 12px; line-height: 18px; padding: 0; border-radius: 6px;
  }

  /* Título de área à esquerda */
  #jobsBody tr.areaTitleRow td { text-align: left !important; }

  /* Mini viewer */
  #miniViewer { border: none; padding: 0; width: min(680px, 96vw); background: transparent; }
  #miniViewer::backdrop { background: rgba(0,0,0,.65); }
  #miniCard {
    background: #0e1730; color: #eaf0ff;
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 14px; box-shadow: 0 18px 60px rgba(0,0,0,.55);
    overflow: hidden;
  }
  #miniHdr { padding: 12px 16px; border-bottom: 1px solid rgba(255,255,255,.08); font-weight: 700; }
  #miniCnt { padding: 14px 16px; max-height: 60vh; overflow: auto; }
  #miniCnt ul { margin: 0; padding-left: 18px; }
  #miniCnt .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; }
  #miniAct { padding: 10px 16px 14px; border-top: 1px solid rgba(255,255,255,.08); text-align: right; }
  #miniAct .btn { appearance: none; border: 1px solid rgba(255,255,255,.16); background: #0d1628; color: #eaf0ff;
                  padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 700; }
</style>

<dialog id="miniViewer">
  <div id="miniCard" role="dialog" aria-modal="true" aria-labelledby="miniTitle">
    <div id="miniHdr"><span id="miniTitle">Detalhes</span></div>
    <div id="miniCnt"></div>
    <div id="miniAct"><button class="btn" id="miniClose" type="button">Fechar</button></div>
  </div>
</dialog>

<script>
(() => {
  const jobsBody = document.getElementById('jobsBody');
  const miniDlg  = document.getElementById('miniViewer');
  const miniT    = document.getElementById('miniTitle');
  const miniCnt  = document.getElementById('miniCnt');
  const miniClose= document.getElementById('miniClose');

  // Índices das colunas (ajuste se a ordem for diferente)
  const COL = { ot:0, regional:1, tipoLoja:2, tipoJob:3, nome:4, compl:5, uf:6, filiais:7, ini:8, fim:9, tam:10, qtd:11, status:12 };

  const htmlEscape = s => String(s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
  const isAreaTitleRow = tr => !tr.hasAttribute('data-ot') && /^(REGIONAL |ESPECIAL NACIONAL)/i.test((tr.textContent||'').trim());

  function openMini(title, fullText, listStyle=false){
    miniT.textContent = title || 'Detalhes';
    if(listStyle){
      const arr = String(fullText||'')
        .split(/[\n;,]+/).map(s=>s.trim()).filter(Boolean);
      miniCnt.innerHTML = arr.length
        ? '<ul>'+arr.map(x=>'<li>'+htmlEscape(x)+'</li>').join('')+'</ul>'
        : '<div class="mono">'+htmlEscape(fullText||'')+'</div>';
    } else {
      miniCnt.innerHTML = '<div class="mono">'+htmlEscape(fullText||'')+'</div>';
    }
    try{ miniDlg.showModal(); }catch{}
  }

  function findAnyDataFull(td){
    // procura data-full em qualquer descendente
    const el = td.querySelector('[data-full]');
    if (el && el.getAttribute('data-full')) return el.getAttribute('data-full');
    // tenta title (muitos botões "Ver lojas" guardam no title)
    const titled = td.querySelector('[title]');
    if (titled && /[,;\n]/.test(titled.getAttribute('title')||'')) return titled.getAttribute('title');
    // tenta no próprio td
    if (td.dataset && td.dataset.full) return td.dataset.full;
    if (td.title && /[,;\n]/.test(td.title)) return td.title;
    return '';
  }

  function getRowStores(tr){
    // tenta várias fontes confiáveis para as filiais
    const ot = tr?.dataset?.ot || '';
    if (tr?.dataset?.filiais) return tr.dataset.filiais;

    if (window.jobsByOT && window.jobsByOT[ot]) {
      return window.jobsByOT[ot].filial || window.jobsByOT[ot].filiais || '';
    }
    if (typeof window.getRowDataByOT === 'function') {
      try {
        const r = window.getRowDataByOT(ot);
        if (r) return r.filial || r.filiais || r.lojas || '';
      } catch {}
    }
    return '';
  }

  function buildClip(td, full){
    td.innerHTML = '';
    const span = document.createElement('span');
    span.className = 'cell-clip';
    span.textContent = String(full||'').replace(/\s+/g,' ').trim();
    span.dataset.full = full || '';
    td.appendChild(span);
    td.classList.add('cell-clickable');
    return span;
  }

  function decorateOneRow(tr){
    if (!tr || !tr.children) return;

    // Área/título
    if (isAreaTitleRow(tr)) { tr.classList.add('areaTitleRow'); return; }
    if (!tr.hasAttribute('data-ot')) return;

    // NOME
    const tdNome = tr.children[COL.nome];
    if (tdNome) {
      let full = tdNome.querySelector('.cell-clip')?.dataset.full || (tdNome.textContent||'').trim();
      tdNome.classList.add('col-nome');
      const sp = buildClip(tdNome, full);
      tdNome.addEventListener('click', (e)=>{ e.stopPropagation(); openMini('Nome do tabloide', sp.dataset.full, false); });
    }

    // FILIAIS: neutraliza "Ver lojas"
    const tdFil = tr.children[COL.filiais];
    if (tdFil) {
      let full = findAnyDataFull(tdFil);

      // se ainda vier "Ver lojas" ou vazio, tenta buscar em outras fontes
      if (!full || /^ver\s+lojas$/i.test((tdFil.textContent||'').trim())) {
        const fallback = getRowStores(tr);
        if (fallback) full = fallback;
      }

      // remove "Ver lojas" do texto bruto
      if (/^ver\s+lojas$/i.test((tdFil.textContent||'').trim())) {
        tdFil.textContent = '';
      }

      tdFil.classList.add('col-filiais');
      const sp = buildClip(tdFil, full);
      tdFil.addEventListener('click', (e)=>{ e.stopPropagation(); openMini('Filiais', sp.dataset.full, true); });
    }

    // botão "+"
    const plusBtn =
      tr.querySelector('.btnStepPlus, .btnStep, .btn-plus, button.plus, [data-action="step-plus"]') ||
      [...tr.querySelectorAll('button')].find(b => b.textContent.trim() === '+');
    if (plusBtn) plusBtn.classList.add('btnPlusMini');
  }

  function decorateAll(){
    if (!jobsBody) return;
    // força table-layout: fixed no <table>
    const tbl = jobsBody.closest('table');
    if (tbl) { tbl.style.tableLayout = 'fixed'; tbl.style.width = '100%'; }
    [...jobsBody.querySelectorAll('tr')].forEach(decorateOneRow);
  }

  // APIs para reaplicar quando a tabela recarregar
  window.decorateInlineCells = decorateAll;
  window.decorateFiliaisCellForOT = (ot)=>{
    const tr = jobsBody?.querySelector(`tr[data-ot="${CSS.escape(ot)}"]`);
    if (tr) decorateOneRow(tr);
  };
  window.decorateNomeCellForOT = window.decorateFiliaisCellForOT;

  // Hook após loadJobsFromGitHub se existir
  if (typeof window.loadJobsFromGitHub === 'function'){
    const _orig = window.loadJobsFromGitHub;
    window.loadJobsFromGitHub = async function(...args){
      const r = await _orig.apply(this, args);
      requestAnimationFrame(decorateAll);
      return r;
    };
  }

  // Botão fechar do mini viewer
  miniClose?.addEventListener('click', ()=> { try{ miniDlg.close(); }catch{} });

  // Aplica agora
  decorateAll();
})();
</script>
<!-- ======= /AJUSTES FINAIS v2 ======= FIM -->

<!-- ============== OT-x HOOK (gera OT sem zeros no momento de salvar) ============== -->
<script>
(() => {
  "use strict";

  /* ===== CONFIG REPO ===== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    jobs:   'jobs.csv',
    encerr: 'jobs_encerrados.csv'
  };
  const CONTENTS_BASE = `https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/`;

  /* ===== Helpers gerais ===== */
  function getToken(){
    try{
      const s = JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}');
      return (window.gh && window.gh.token) || s.token || '';
    }catch{ return (window.gh && window.gh.token) || ''; }
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const a=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) a[i]=bin.charCodeAt(i); return new TextDecoder().decode(a); }
  function utf8ToB64(str){ const a=new TextEncoder().encode(str); let bin=''; for(let i=0;i<a.length;i++) bin+=String.fromCharCode(a[i]); return btoa(bin); }

  /* ===== CSV ===== */
  function parseCsv(t){
    if(!t) return []; const out=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"'; i++;} else q=false; } else cur+=c; }
      else { if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
             else if(c=='\r'){} else if(c=='\n'){row.push(cur); out.push(row); row=[]; cur='';}
             else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); out.push(row); }
    return out;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return {header:[],rows:[]};
    const H=rows[0]; const R=[];
    for(let i=1;i<rows.length;i++){ const rr=rows[i]; if(!rr || (rr.length===1&&rr[0]==='')) continue; const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; R.push(o); }
    return {header:H,rows:R};
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }

  /* ===== OT utils ===== */
  const rxGoodOT  = /^OT-(\d+)$/i;           // OT-123
  const rxZeroOT  = /^OT-0+(\d+)$/i;         // OT-000123
  const rxAnyNum  = /^OT-0*(\d+)$/i;         // OT-000123 ou OT-123

  const getNum = (ot)=>{ const m=String(ot||'').match(rxAnyNum); return m? parseInt(m[1],10):null; };
  const isGood = (ot)=> rxGoodOT.test(String(ot||''));
  const isZero = (ot)=> rxZeroOT.test(String(ot||''));
  const norm   = (n)=> `OT-${n}`;

  /* ===== Cache do maior OT em jobs_encerrados ===== */
  let MAX_ENC = 0;
  let encCachedAt = 0;

  async function fetchEncMaxIfNeeded(){
    // revalida a cada 60s
    if(MAX_ENC && (Date.now() - encCachedAt) < 60000) return MAX_ENC;
    const tok = getToken();
    if(!tok) return MAX_ENC||0;

    const url = `${CONTENTS_BASE}${encodeURIComponent(GH.encerr)}?ref=${encodeURIComponent(GH.branch)}`;
    try{
      const r = await fetch(url, { headers: ghHeaders(tok) });
      if(!r.ok) return MAX_ENC||0;
      const j = await r.json();
      const text = j && j.content ? b64ToUtf8(j.content) : '';
      if(!text) return MAX_ENC||0;
      const { header:H, rows } = csvToObjsAndHeader(text);
      if(!H.length) return MAX_ENC||0;

      let maxN = 0;
      for(const r of rows){
        const n = getNum(r.ot);
        if(n!=null && isGood(r.ot)) maxN = Math.max(maxN, n);
      }
      MAX_ENC = maxN;
      encCachedAt = Date.now();
    }catch(_){}
    return MAX_ENC||0;
  }

  /* ===== Patch de fetch para PUT de jobs.csv =====
     Intercepta qualquer PUT para /contents/jobs.csv,
     normaliza as OTs do payload para OT-x (sem zeros),
     e garante que os zero-padded recém-criados recebam
     números sequenciais > max(jobs.csv atual sem zeros, jobs_encerrados.csv).
  */
  const _origFetch = window.fetch.bind(window);

  window.fetch = async function(url, options){
    try{
      const isPut = options && String(options.method||'').toUpperCase()==='PUT';
      const isJobsPut = isPut && typeof url === 'string' && /\/contents\/jobs\.csv(?:\?|$)/.test(url);

      if(!isJobsPut) return await _origFetch(url, options);

      // tenta ler body JSON do PUT GitHub
      let bodyObj = null;
      try{ bodyObj = options && options.body ? JSON.parse(options.body) : null; }catch{}
      if(!bodyObj || !bodyObj.content) return await _origFetch(url, options);

      // decode CSV que está prestes a ser salvo
      const incomingCsv = b64ToUtf8(bodyObj.content);
      const { header:H, rows } = csvToObjsAndHeader(incomingCsv);
      if(!H.length || !rows.length) return await _origFetch(url, options);

      // 1) calcula maior OT "boa" já presente no CSV que será salvo
      let maxJobs = 0;
      for(const r of rows){
        if(isGood(r.ot)){
          const n = getNum(r.ot);
          if(n!=null) maxJobs = Math.max(maxJobs, n);
        }
      }

      // 2) inclui o maior de jobs_encerrados (sem zeros)
      const maxEnc = await fetchEncMaxIfNeeded();
      let next = Math.max(maxJobs, maxEnc);

      // 3) reatribui apenas OTs "zeradas" OU formatos não conformes
      for(const r of rows){
        const ot = String(r.ot||'');
        if(isGood(ot)) continue;            // já está certo, mantém
        const n = getNum(ot);
        if(n!=null && !isGood(ot)){         // zero-padded ou com espaços
          next += 1;
          r.ot = norm(next);
        }
      }

      // 4) reserializa e segue com o PUT
      const newCsv = toCsv(H, rows);
      const newBody = { ...bodyObj, content: utf8ToB64(newCsv) };
      const newOpts = { ...options, body: JSON.stringify(newBody) };
      return await _origFetch(url, newOpts);
    }catch(e){
      // fallback seguro
      return await _origFetch(url, options);
    }
  };

})();
</script>
<!-- ============== /OT-x HOOK ============== FIM-->

<!// OT sem zeros no LANÇAR ----->

<script>
(function(){
  "use strict";

  /* ====== CONFIG ====== */
  const GH = {
    owner: 'JPVectorsitem',
    repo:  'LINKS-img',
    branch:'main',
    jobsPath: 'jobs.csv',
    encPath:  'jobs_encerrados.csv'
  };

  /* ====== UX ====== */
  const toast = (m)=>{
    const t=document.getElementById('toast');
    if(!t){ alert(m); return; }
    t.textContent=m; t.style.display='block';
    setTimeout(()=>t.style.display='none',1800);
  };
  const setBusy=(v,msg)=>{
    const o=document.getElementById('busy'); if(!o) return;
    o.style.display=v?'grid':'none';
    if(msg) o.querySelector('.box').textContent=msg;
  };
  function getToken(){
    try{
      const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}');
      return (window.gh&&window.gh.token)||s.token||'';
    }catch{ return (window.gh&&window.gh.token)||''; }
  }

  /* ====== CSV utils ====== */
  function parseCsv(t){
    if(!t) return [];
    const r=[]; let row=[], cur='', q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){
        if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; }
        else cur+=c;
      }else{
        if(c=='"') q=true;
        else if(c==','){ row.push(cur); cur=''; }
        else if(c=='\r'){}
        else if(c=='\n'){ row.push(cur); r.push(row); row=[]; cur=''; }
        else cur+=c;
      }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  const csvEsc=v=>{ v=v==null?'':String(v); return /[",\n]/.test(v)?`"${v.replace(/"/g,'""')}"`:v; };
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0].map(h=>String(h||'').trim()); const out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1&&rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]??'';
      out.push(o);
    }
    return { header:H, rows:out };
  }
  function toCsv(H, rows){
    const head=H.join(',')+'\n';
    const body=rows.map(o=> H.map(k=> csvEsc(o[k]??'')).join(',')).join('\n');
    return head + (body? body+'\n' : '');
  }
  function ensureHeaderColumns(H, rows, needed){
    const head=H.slice(); const have=new Set(head.map(h=>String(h)));
    let changed=false;
    needed.forEach(col=>{ if(!have.has(col)){ head.push(col); changed=true; } });
    if(changed){ rows.forEach(r=> needed.forEach(col=>{ if(r[col]===undefined) r[col]=''; })); }
    return { head, rows };
  }

  /* ====== GitHub helpers ====== */
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  function utf8ToB64(str){ const bytes=new TextEncoder().encode(str); let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }
  async function ghPutFile(path, newText, message){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    let sha=null; try{ const cur=await ghGetFile(path, GH.branch); sha=cur.sha; }catch{}
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}`;
    const body={ message:message||`chore(csv): update ${path}`, content:utf8ToB64(newText), branch:GH.branch, ...(sha?{sha}:{}) };
    const r=await fetch(url,{method:'PUT', headers:{...ghHeaders(token),'Content-Type':'application/json'}, body:JSON.stringify(body)});
    if(!r.ok){ const t=await r.text(); throw new Error('Falha ao salvar ('+r.status+'): '+t); }
    return true;
  }

  /* ====== OT (sem zeros) ====== */
  const parseOTnum = (ot)=> {
    // aceita OT-7, OT-0007, ot:7 etc
    const m=String(ot||'').match(/ot[-:\s]*0*([0-9]+)/i);
    return m ? parseInt(m[1],10) : NaN;
  };
  async function getNextOTNoZeros(){
    const [j, e] = await Promise.all([
      ghGetFile(GH.jobsPath, GH.branch),
      ghGetFile(GH.encPath,  GH.branch).catch(()=>({text:''}))
    ]);
    let maxN=0;
    [j.text, e.text].forEach(text=>{
      const {header, rows} = csvToObjsAndHeader(text||'');
      const has = header.findIndex(h=>String(h).toLowerCase()==='ot');
      if(has<0) return;
      for(const r of rows){
        const n = parseOTnum(r.ot);
        if(!isNaN(n) && n>maxN) maxN=n;
      }
    });
    return 'OT-' + (maxN+1);
  }

  /* ====== coleta seleção/params do modal DUP2 ====== */
  function getDupContext(){
    // 1) preferir contexto que salvamos quando o usuário clicou em “Avançar”/“Duplicar selecionados”
    if(window.WV && window.WV._dupContext && Array.isArray(window.WV._dupContext.ots) && window.WV._dupContext.ots.length){
      return { ots: window.WV._dupContext.ots.slice() };
    }
    // 2) fallback: pegar checados da tabela #finzList
    const list=document.getElementById('finzList');
    if(list){
      const sel=[...list.querySelectorAll('input[type="checkbox"][data-ot]:checked')].map(b=> b.getAttribute('data-ot'));
      if(sel.length) return { ots: sel };
    }
    return { ots: [] };
  }
  function getDupAcaoParams(){
    const rSim=document.getElementById('dupAcaoSim');
    const isNac=!!(rSim&&rSim.checked);
    const nome=(document.getElementById('dupAcaoNome')?.value||'').trim();
    return { isNacional: isNac, acaoNome: isNac ? nome : '' };
  }

  /* ====== DUPLICAR SALVANDO OTs SEM ZEROS ====== */
  async function duplicateFinalizadosWithPlainOTs(){
    if(!getToken()){ toast('Configure o token antes.'); return; }
    const ctx = getDupContext();
    if(!ctx.ots.length){ toast('Selecione itens em “Finalizados” e clique em Avançar.'); return; }

    setBusy(true,'Duplicando…');
    try{
      // carrega enc + jobs
      const [encFile, jobsFile] = await Promise.all([
        ghGetFile(GH.encPath,  GH.branch),
        ghGetFile(GH.jobsPath, GH.branch)
      ]);
      let { header: Hj, rows: rowsJobs } = csvToObjsAndHeader(jobsFile.text||'');
      let { header: He, rows: rowsEnc  } = csvToObjsAndHeader(encFile.text||'');

      // normaliza cabeçalhos mínimos
      ({ head: Hj, rows: rowsJobs } = ensureHeaderColumns(Hj, rowsJobs, [
        'ot','regional','tipoLoja','tipoJob','nome','compl','uf','filial','ini','fim','tam','qtd',
        'status','statusStep','isNacional','acaoNome','link','logs','atualizado_em'
      ]));

      const encByOT = new Map(rowsEnc.map(r=> [String(r.ot||'').trim(), r]));
      const params  = getDupAcaoParams();

      // próximo número base
      let nextOT = await getNextOTNoZeros();
      let nextN  = parseOTnum(nextOT); // inteiro

      const nowISO = new Date().toISOString();
      const actor  = (window.currentUser && window.currentUser.nome) ? String(window.currentUser.nome) : '—';

      const created = [];

      for(const oldOT of ctx.ots){
        const src = encByOT.get(String(oldOT).trim());
        if(!src) continue;

        const newOT = 'OT-' + (nextN++); // sempre sem zeros
        const r = {
          ot: newOT,
          regional:   src.regional||'',
          tipoLoja:   src.tipoLoja||'',
          tipoJob:    src.tipoJob||'',
          nome:       src.nome||'',
          compl:      src.compl||'',
          uf:         src.uf||'',
          filial:     src.filial||'',
          ini:        src.ini||'',
          fim:        src.fim||'',
          tam:        src.tam||'',
          qtd:        src.qtd||'',
          status:     'Novo',
          statusStep: '',
          isNacional: params.isNacional ? 'true' : 'false',
          acaoNome:   params.isNacional ? (params.acaoNome||'') : '',
          link:       src.link||'',
          logs:       JSON.stringify({ duplicadoDe: String(oldOT), por: actor, ts: nowISO }),
          atualizado_em: nowISO
        };
        rowsJobs.push(r);
        created.push(newOT);
      }

      const nextCsv = toCsv(Hj, rowsJobs);
      await ghPutFile(GH.jobsPath, nextCsv, `chore(csv): duplicar ${created.length} job(s) (OT sem zeros)`);

      // fecha modal e recarrega UI se existir
      try{ document.getElementById('modalDup2')?.close(); }catch{}
      try{ document.getElementById('modalFinalizados')?.close(); }catch{}
      if(typeof window.loadJobsFromGitHub==='function'){ await window.loadJobsFromGitHub(); }

      toast(`${created.length} job(s) lançados: ${created.join(', ')}`);
    }catch(e){
      console.error(e);
      toast('Falha ao duplicar. Tente novamente.');
    }finally{
      setBusy(false);
    }
  }

  /* ====== PATCH do botão “Lançar” na 2ª janela do Duplicar ====== */
  function patchDup2Lancar(){
    const btn = document.getElementById('dup2Lancar');
    if(!btn || btn._wvPatchedNoZeros) return;
    btn.addEventListener('click', (ev)=>{
      // cancela o handler antigo e usa o nosso
      ev.preventDefault(); ev.stopImmediatePropagation();
      duplicateFinalizadosWithPlainOTs();
    }, true); // captura para vencer handlers existentes
    btn._wvPatchedNoZeros = true;
  }

  /* ====== BOOT ====== */
  // quando abrir o modal da 2ª etapa, aplicamos o patch
  const dup2 = document.getElementById('modalDup2');
  if(dup2){
    dup2.addEventListener('show', patchDup2Lancar);
    // alguns browsers não disparam 'show', então garantimos pós-click do abrir:
    document.addEventListener('click', (e)=>{
      if(e.target && e.target.id==='finzDuplicar'){ // seu botão que abre a 2ª janela
        setTimeout(patchDup2Lancar, 50);
      }
      if(e.target && e.target.id==='finzAvancar'){   // caso use “Avançar”
        setTimeout(patchDup2Lancar, 50);
      }
    });
  }else{
    // fallback: tenta patch periodicamente até achar o botão
    const iv = setInterval(()=>{
      patchDup2Lancar();
      if(document.getElementById('dup2Lancar')?._wvPatchedNoZeros) clearInterval(iv);
    }, 500);
  }

})();
</script>
<!// OT sem zeros no LANÇAR - FIM---->

<!// NOVO MODELO VISUALIZAR FINALIZADOS---->

<script>
(function(){
  "use strict";

  /* ====== CONFIG GH ====== */
  const GH = {
    owner:  'JPVectorsitem',
    repo:   'LINKS-img',
    branch: 'main',
    encPath:'jobs_encerrados.csv'
  };

  /* ====== ELEMENTOS ====== */
  const btnOpen   = document.getElementById('btnVerFinalizados'); // botão que abre o modal
  const dlg       = document.getElementById('modalFinalizados');
  const selReg    = document.getElementById('finzReg');
  const inpIni    = document.getElementById('finzIni');
  const inpFim    = document.getElementById('finzFim');
  const btnFilter = document.getElementById('finzFiltrar');
  const btnClose  = document.getElementById('finzFechar');
  const listBody  = document.getElementById('finzList');

  /* ====== STATE ====== */
  let _allRows = []; // linhas brutas de jobs_encerrados.csv (objetos)

  /* ====== UX helpers ====== */
  function toast(m){ const t=document.getElementById('toast'); if(!t){ alert(m); return; } t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',2200); }
  function setBusy(v,msg){ const o=document.getElementById('busy'); if(!o) return; o.style.display=v?'grid':'none'; if(msg) o.querySelector('.box').textContent=msg; }
  function getToken(){ try{ const s=JSON.parse(localStorage.getItem('wv_gh_cfg')||'{}'); return (window.gh&&window.gh.token)||s.token||''; }catch{ return (window.gh&&window.gh.token)||''; } }

  /* ====== CSV/GitHub ====== */
  function parseCsv(t){
    if(!t) return []; const r=[]; let row=[],cur='',q=false;
    for(let i=0;i<t.length;i++){
      const c=t[i];
      if(q){ if(c=='"'){ if(t[i+1]=='"'){cur+='"';i++;} else q=false; } else cur+=c; }
      else { if(c=='"') q=true; else if(c==','){row.push(cur);cur='';}
      else if(c=='\r'){} else if(c=='\n'){row.push(cur);r.push(row);row=[];cur='';} else cur+=c; }
    }
    if(cur.length>0||row.length>0){ row.push(cur); r.push(row); }
    return r;
  }
  function csvToObjsAndHeader(text){
    const rows=parseCsv(text); if(!rows.length) return { header:[], rows:[] };
    const H=rows[0], out=[];
    for(let i=1;i<rows.length;i++){
      const rr=rows[i]; if(!rr || (rr.length===1 && rr[0]==='')) continue;
      const o={}; for(let j=0;j<H.length;j++) o[H[j]]=rr[j]||''; out.push(o);
    }
    return { header:H, rows:out };
  }
  const GH_API_VER='2022-11-28';
  const ghHeaders=(tok)=>({'Accept':'application/vnd.github+json','X-GitHub-Api-Version':GH_API_VER, ...(tok?{'Authorization':`Bearer ${tok}`}:{})});
  function b64ToUtf8(b64){ const bin=atob(b64); const bytes=new Uint8Array(bin.length); for(let i=0;i<bytes.length;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
  async function ghGetFile(path, branch){
    const token=getToken(); if(!token) throw new Error('Token GitHub não configurado.');
    const url=`https://api.github.com/repos/${encodeURIComponent(GH.owner)}/${encodeURIComponent(GH.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch||GH.branch)}`;
    const r=await fetch(url,{headers:ghHeaders(token)});
    if(r.status===404) return { text:'', sha:null };
    if(!r.ok) throw new Error('Falha ao ler ('+r.status+')');
    const j=await r.json(); const text=j && j.content ? b64ToUtf8(j.content) : '';
    return { text, sha:j.sha||null };
  }

  /* ====== UTILS ====== */
  // Trunca visualmente, mantendo original em data-full (útil p/ seu modalCell global, se existir)
  function clipHTML(full, max=60){
    const s = String(full||'').trim();
    if(!s) return '—';
    const short = s.length>max ? s.slice(0,max-1)+'…' : s;
    return `<span class="clip" data-full="${s.replace(/"/g,'&quot;')}">${short.replace(/</g,'&lt;')}</span>`;
  }
  function toDate(x){ const d = x ? new Date(x) : null; return (d && !isNaN(d)) ? d : null; }
  function datesOverlap(jobIni, jobFim, fIni, fFim){
    if(!fIni && !fFim) return true;
    if(fIni && !fFim)  return !jobFim || jobFim >= fIni;
    if(!fIni && fFim)  return !jobIni || jobIni <= fFim;
    // ambos
    return !( (jobFim && jobFim < fIni) || (jobIni && jobIni > fFim) );
  }

  /* ====== RENDER ====== */
  function render(list){
    if(!listBody) return;
    if(!list.length){
      listBody.innerHTML = `<tr><td colspan="11" class="hint">Nenhum finalizado com esse filtro.</td></tr>`;
      return;
    }
    // ordena por OT numérico
    list.sort((a,b)=> {
      const na = parseInt(String(a.ot||'').match(/\d+/)?.[0]||'0',10);
      const nb = parseInt(String(b.ot||'').match(/\d+/)?.[0]||'0',10);
      return (na-nb)|| String(a.ot||'').localeCompare(String(b.ot||''));
    });

    const frag=document.createDocumentFragment();
    list.forEach(r=>{
      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>${r.ot||'—'}</td>
        <td>${r.regional||'—'}</td>
        <td>${r.tipoJob||'—'}</td>
        <td>${clipHTML(r.nome||'')}</td>
        <td>${clipHTML(r.compl||'')}</td>
        <td>${r.uf||'—'}</td>
        <td>${clipHTML(r.filial||'')}</td>
        <td>${r.ini||'—'}</td>
        <td>${r.fim||'—'}</td>
        <td>${r.tam||'—'}</td>
        <td>${r.qtd||'—'}</td>`;
      frag.appendChild(tr);
    });
    listBody.innerHTML=''; listBody.appendChild(frag);
  }

  /* ====== FILTER ====== */
  function applyFilter(){
    const reg = (selReg?.value || '(todas)').trim();
    const fIni = toDate(inpIni?.value);
    const fFim = toDate(inpFim?.value);

    const out = _allRows.filter(r=>{
      const okReg = reg==='(todas)' || String(r.regional||'')===reg;
      const jIni = toDate(r.ini), jFim = toDate(r.fim);
      const okPer = datesOverlap(jIni, jFim, fIni, fFim);
      return okReg && okPer;
    });
    render(out);
  }

  function populateRegionaisFromData(rows){
    if(!selReg) return;
    const set = new Set(['(todas)']);
    rows.forEach(r=>{ const v=(r.regional||'').trim(); if(v) set.add(v); });
    selReg.innerHTML = '';
    [...set].sort((a,b)=> a.localeCompare(b,'pt-BR')).forEach(v=>{
      const o=document.createElement('option'); o.value=v; o.textContent=v; selReg.appendChild(o);
    });
  }

  /* ====== OPEN ====== */
  async function openFinalizados(){
    if(!getToken()){ toast('Configurar GitHub primeiro (⚙).'); return; }
    setBusy(true,'Carregando finalizados…');
    try{
      const { text } = await ghGetFile(GH.encPath, GH.branch);
      const parsed = csvToObjsAndHeader(text);
      _allRows = parsed.rows || [];

      populateRegionaisFromData(_allRows);

      // Zera filtros de data na abertura
      if(inpIni) inpIni.value = '';
      if(inpFim) inpFim.value = '';

      // Render inicial (sem filtro = todos)
      render(_allRows);

      dlg && dlg.showModal();
    }catch(e){
      console.error(e);
      toast('Falha ao carregar jobs finalizados.');
      if(listBody) listBody.innerHTML = `<tr><td colspan="11" class="hint">Erro ao carregar.</td></tr>`;
      dlg && dlg.showModal();
    }finally{
      setBusy(false);
    }
  }

  /* ====== Binds ====== */
  if(btnOpen)    btnOpen.addEventListener('click', openFinalizados);
  if(btnFilter)  btnFilter.addEventListener('click', applyFilter);
  if(btnClose)   btnClose.addEventListener('click', ()=> dlg && dlg.close());

})();
</script>

<!// NOVO MODELO VISUALIZAR FINALIZADOS- FIM --->

<!-- PATCH: remover "Ver lojas" mantendo filiais (+ellipsis e modal) -->
<script>
(function(){
  "use strict";
  const COL = { filiais: 7 }; // índice da coluna FILIAL(S)
  const tbody = document.getElementById('jobsBody');
  if (!tbody) return;

  // estiliza o “clip” com reticências
  const css = document.createElement('style');
  css.textContent = `
    #jobsBody td .clip{
      display:inline-block; max-width:100%;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      border-bottom:1px dotted rgba(255,255,255,.35); cursor:pointer;
    }`;
  document.head.appendChild(css);

  function renderClip(td, fullText){
    const full = String(fullText||'').trim();
    td.innerHTML = '';
    if (!full) return;
    const span = document.createElement('span');
    span.className = 'clip';
    span.setAttribute('data-full', full);
    span.textContent = full;               // o ellipsis vem do CSS acima
    td.appendChild(span);
  }

  // transforma a célula de filiais da linha
  function fixRow(tr){
    if (!tr || !tr.children || tr.classList.contains('sep-row') || tr.classList.contains('sub-row')) return;
    const td = tr.children[COL.filiais];
    if (!td) return;

    // tenta extrair o texto completo das filiais
    let full =
      td.querySelector('.btnVerLojas, .ver-lojas')?.dataset?.full ||
      td.querySelector('.clip[data-full], .cell-clip[data-full]')?.dataset?.full ||
      td.getAttribute('data-full') ||
      (td.textContent || '').replace(/^\s*ver\s+lojas\s*$/i,'').trim();

    renderClip(td, full);
  }

  function fixAll(){ tbody.querySelectorAll('tr[data-ot]').forEach(fixRow); }

  // clique no “clip” abre o modal padrão (#modalCell)
  document.addEventListener('click', function(e){
    const sp = e.target.closest('#jobsBody td .clip');
    if (!sp) return;
    const full = sp.getAttribute('data-full') || sp.textContent || '';
    const dlg  = document.getElementById('modalCell');
    const ttl  = document.getElementById('cellTitle');
    const body = document.getElementById('cellBody');
    if (!dlg || !ttl || !body) return;

    ttl.textContent = 'Filiais';
    const items = full.split(/[,;]+/).map(s=>s.trim()).filter(Boolean);
    body.innerHTML = items.length
      ? '<ul style="margin:0;padding-left:18px">' + items.map(s=>`<li>${s}</li>`).join('') + '</ul>'
      : '<em>Sem dados</em>';

    try{ dlg.showModal(); }catch{}
  });

  // observa novas linhas adicionadas na tabela
  const mo = new MutationObserver(muts=>{
    muts.forEach(m=> m.addedNodes.forEach(n=>{
      if (n.nodeType===1 && n.matches('tr[data-ot]')) fixRow(n);
    }));
  });
  mo.observe(tbody, { childList:true });

  // passa inicial
  fixAll();
})();
</script>

<!-- PATCH: remover "Ver lojas" mantendo filiais (+ellipsis e modal) FIM -->

</body>
</html>
